{"ast":null,"code":"/**\r\n * This software may be freely distributed and used under the following MIT license:\r\n *\r\n * Copyright (c) 2017 Finnish Meteorological Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the\r\n * Software without restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n * Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\r\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\n// Strict mode for whole file.\n\"use strict\"; // Requires jQuery, lodash, async\n\nvar jQuery = require('jquery');\n\nvar _ = require('lodash');\n\nvar async = require('async'); // import jQuery from 'jquery';\n// import _ from 'lodash';\n// import async from 'async';\n// Requires SplitterCache, WfsRequestParser\n\n\nvar SplitterCache = require('./splittercache.js');\n\nvar WfsRequestParser = require('./wfsrequestparser.js'); // import SplitterCache from './splittercache.js';\n// import WfsRequestParser from './wfsrequestparser.js';\n\n/**\r\n * WfsConnection object acts as an interface that provides functions\r\n * to asynchronously request XML data from the server and to get\r\n * the requested data in a parsed structure.\r\n *\r\n * WfsConnection wraps cache, request and parser functionality.\r\n * Notice, if you do not require cache functionality, you may\r\n * want to use parser, {@link WfsRequestParser},\r\n * directly without using this class as an intermediate object.\r\n *\r\n * API functions are defined in the end of the constructor,\r\n * {connectionConstructor}, as priviledged functions.\r\n * See API description there.\r\n *\r\n * Example:\r\n *      var connection = new WfsConnection();\r\n *      if (connection.connect(SERVER_URL, STORED_QUERY_OBSERVATION)) {\r\n *          // Connection was properly initialized. So, get the data.\r\n *          connection.getData({\r\n *              requestParameter : \"td,ws_10min\",\r\n *              // Integer values are used to init dates for older browsers.\r\n *              // (new Date(\"2013-05-10T08:00:00Z\")).getTime()\r\n *              // (new Date(\"2013-05-12T10:00:00Z\")).getTime()\r\n *              begin : new Date(1368172800000),\r\n *              end : new Date(1368352800000),\r\n *              timestep : 60 * 60 * 1000,\r\n *              sites : [\"Kaisaniemi,Helsinki\", \"Turku\"],\r\n *              callback : function(data, errors) {\r\n *                  // Handle the data and errors object in a way you choose.\r\n *                  handleCallback(data, errors);\r\n *                  // If the connection will not be used anymore later,\r\n *                  // the connection may be disconnected because the flow has finished.\r\n *                  connection.disconnect();\r\n *              }\r\n *          });\r\n *      }\r\n */\n\n\nvar WfsConnection = function () {\n  /**\r\n   * @private\r\n   *\r\n   * Data fetcher name for cache when sites are used for fetching.\r\n   */\n  var DATA_FETCHER_NAME_SITES = \"parserSites\";\n  /**\r\n   * @private\r\n   *\r\n   * Parameter values are separated by this string.\r\n   */\n\n  var PARAMETER_SEPARATOR = \",\";\n  /**\r\n   * @private\r\n   *\r\n   * Location name and region strings may be separated by this string\r\n   * in server responses.\r\n   */\n\n  var LOCATION_NAME_REGION_SEPARATOR = \" \";\n  /**\r\n   * @private\r\n   *\r\n   * Geoid location name prefix for cache.\r\n   */\n\n  var LOCATION_GEOID_PREFIX = \"g_\";\n  /**\r\n   * @private\r\n   *\r\n   * WMO location name prefix for cache.\r\n   */\n\n  var LOCATION_WMO_PREFIX = \"w_\";\n  /**\r\n   * @private\r\n   *\r\n   * FMISID location name prefix for cache.\r\n   */\n\n  var LOCATION_FMISID_PREFIX = \"f_\";\n  /**\r\n   * @private\r\n   *\r\n   * Sites location name prefix for cache.\r\n   */\n\n  var LOCATION_SITES_PREFIX = \"s_\";\n  /**\r\n   * @private\r\n   *\r\n   * General text that describes an error that has been found in cache.\r\n   */\n\n  var CACHE_ERROR_TEXT = \"ERROR: Cache found error(s)!\";\n  /**\r\n   * @private\r\n   *\r\n   * Trim single site string for cache flow.\r\n   *\r\n   * @param {String} May not be {undefined} or {null}.\r\n   */\n\n  function trimSingleSite(site) {\n    return jQuery.trim(site).replace(/,\\s+/, PARAMETER_SEPARATOR);\n  }\n  /**\r\n   * @private\r\n   *\r\n   * Trim unnecessary white spaces from sites string(s).\r\n   *\r\n   * Notice, new content is returned. Then, original values are not changed if an array is given.\r\n   *\r\n   * @param {Array(String)|String} Site strings in an array or one site may be given as a single string.\r\n   *                               May be {udefined} or {null} but then operation is ignored.\r\n   * @param {String} prefix Prefix string that is used with the value(s).\r\n   *                        This is meant for cache but should not be used for parser.\r\n   *                        May be {udefined} or {null}. Then, empty string is used.\r\n   * @return {Array(String)} Trimmed site(s) in an array. May not be {undefined} or {null}.\r\n   */\n\n\n  function trimSites(sites, prefix) {\n    var trimmed = [];\n\n    if (!_.isString(prefix)) {\n      // Make sure prefix is at least an empty string.\n      prefix = \"\";\n    } // Handle sites as string(s).\n\n\n    if (sites && _.isString(sites)) {\n      // Trim possible white spaces.\n      // Location and its region may be separated by using comma but there should not be whitespaces after comma.\n      // Then, later it is easier to compare server responses with given sites when data is handled for cache.\n      trimmed.push(prefix + trimSingleSite(sites));\n    } else if (_.isArray(sites)) {\n      for (var i = 0; i < sites.length; ++i) {\n        var site = sites[i];\n\n        if (site && _.isString(site)) {\n          trimmed.push(prefix + trimSingleSite(site));\n        }\n      }\n    }\n\n    return trimmed;\n  }\n  /**\r\n   * @private\r\n   *\r\n   * Trim unnecessary white spaces from string(s).\r\n   *\r\n   * Notice, new content is returned. Then, original values are not changed if an array is given.\r\n   *\r\n   * @param {Array(String|int)|String|int} property Strings or integers in an array\r\n   *                                                or one item as a single string or integer.\r\n   *                                                May be {udefined} or {null}.\r\n   * @param {String} prefix Prefix string that is used with the value(s).\r\n   *                        This is meant for cache but should not be used for parser.\r\n   *                        May be {udefined} or {null}. Then, empty string is used.\r\n   * @return {Array(String)} Trimmed value(s) in an array. May not be {undefined} or {null}.\r\n   */\n\n\n  function trimProperty(property, prefix) {\n    var trimmed = [];\n\n    if (!_.isString(prefix)) {\n      // Make sure prefix is at least an empty string.\n      prefix = \"\";\n    }\n\n    if (_.isNumber(property) || property && _.isString(property)) {\n      trimmed.push(jQuery.trim(prefix + property));\n    } else if (_.isArray(property)) {\n      for (var i = 0; i < property.length; ++i) {\n        var tmp = property[i]; // Handle property as string.\n\n        if (_.isNumber(tmp) || tmp && _.isString(tmp)) {\n          trimmed.push(jQuery.trim(prefix + tmp));\n        }\n      }\n    }\n\n    return trimmed;\n  }\n  /**\r\n   * @private\r\n   *\r\n   * Cache {taskDef} location should contain all the locations (not just sites names).\r\n   * This function combines all the location information into one array that is\r\n   * set as {location} -property for the cache {taskDef}. Also, other properties that\r\n   * are used for {taskDef} location property are set.\r\n   *\r\n   * @param {Object} taskDef Target for location settings.\r\n   *                         Operation is ignored if {undefined} or {null}.\r\n   * @param {Object} options Options object given through the API.\r\n   *                         Provides location data for {taskDef}.\r\n   *                         Operation is ignored if {undefined} or {null}.\r\n   */\n\n\n  function setTaskDefLocations(taskDef, options) {\n    if (taskDef && options) {\n      var location = [];\n      taskDef.location = location; // Notice, these properties are used to provide additional information\n      // that can be given for the parser. The cache uses location property\n      // to create the cache hierarchy.\n\n      taskDef.geoid = trimProperty(options.geoid);\n      taskDef.wmo = trimProperty(options.wmo);\n      taskDef.fmisid = trimProperty(options.fmisid);\n      taskDef.sites = trimSites(options.sites); // Combine locations information for taskDef location.\n      // Notice, prefix is used for cache. Then, it is sure that different location\n      // requests do not have same string for key (really rare case).\n\n      location.push.apply(location, trimProperty(options.geoid, LOCATION_GEOID_PREFIX));\n      location.push.apply(location, trimProperty(options.wmo, LOCATION_WMO_PREFIX));\n      location.push.apply(location, trimProperty(options.fmisid, LOCATION_FMISID_PREFIX));\n      location.push.apply(location, trimSites(options.sites, LOCATION_SITES_PREFIX));\n    }\n  }\n  /**\r\n   * @private\r\n   *\r\n   * Check that time-value-pair objects are not missing from the given array.\r\n   * If an object is missing, time-value-pair of the correct time and NaN value\r\n   * is inserted into the array according to the resolution step.\r\n   *\r\n   * @param {[]} array Array that contains time-value-pair objects.\r\n   *                   Operation is ignored if {undefined} or {null}.\r\n   * @param {Integer} resolution Time in milliseconds to describe timesteps between values.\r\n   *                             Operation is ignored if {undefined}, {null}, zero or negative.\r\n   */\n\n\n  function checkResolutionSteps(array, resolution) {\n    if (_.isArray(array) && resolution && resolution > 0) {\n      for (var i = 1; i < array.length; ++i) {\n        var previousTimeValuePair = array[i - 1];\n        var timeValuePair = array[i];\n\n        if (_.isObject(timeValuePair)) {\n          var previousTime = _.isObject(previousTimeValuePair) ? previousTimeValuePair.time : undefined;\n          var time = timeValuePair.time;\n\n          if (undefined !== previousTime && null !== previousTime && undefined !== time && null !== time && resolution < time - previousTime) {\n            // Time-value-pair object is missing between two array objects.\n            // Insert a new NaN value pair into array.\n            // Notice, time of this new object is compared in next round to the\n            // same object that is checked already in this round.\n            // Then, missing resolution objects are added properly into too large gaps.\n            time = previousTime + resolution;\n            array.splice(i, 0, {\n              time: time,\n              value: NaN\n            });\n          }\n\n          previousTime = time;\n        }\n      }\n    }\n  }\n  /**\r\n   * @private\r\n   *\r\n   * Check if given {list} contains an equal to the given {item}.\r\n   *\r\n   * Performs an optimized deep comparison between the objects of the {list} and given {item},\r\n   * to determine if they should be considered equal.\r\n   *\r\n   * @param {Array} list List whose items are compared to {item}. May be {undefined} or {null}.\r\n   * @param {Object} item Item that is compared to the list items. May be {undefined} or {null}.\r\n   * @return {Boolean} {true} if {item} equals at least one item in {list}.\r\n   */\n\n\n  function contains(list, item) {\n    return _.find(list, function (currentItem) {\n      return _.isEqual(currentItem, item);\n    });\n  }\n  /**\r\n   * @private\r\n   *\r\n   * Converts errors given by cache to the error objects given through API.\r\n   * Possible duplicates are not included into the returned array.\r\n   *\r\n   * @param {Array} errors Errors array from the cache that is converted to API errors array.\r\n   *                       May be {undefined} or {null}.\r\n   * @return {Array} Converted errors in an array. May not be {undefined} or {null}.\r\n   */\n\n\n  function convertCacheErrorsForApi(errors) {\n    var apiErrors = [];\n\n    if (_.isArray(errors)) {\n      for (var i = 0; i < errors.length; ++i) {\n        var error = errors[i]; // Flag to inform if error item should just be wrapped as a general cache error\n        // or if error content has been handled separately. Always include wrapped error\n        // into array if cache error root level already contains errorCode or errorText information.\n\n        var useWrapError = _.isObject(error) && (error.errorCode || error.errorText); // Cache error structure may wrap errors gotten from parser.\n        // Check if parser has provided errors. Then, that error information can be included\n        // in the root level of the API error.\n\n        if (_.isObject(error) && _.isArray(error.error) && error.error.length > 0) {\n          var errorArray = error.error;\n\n          for (var j = 0; j < errorArray.length; ++j) {\n            // Error array may contain the actual parse error.\n            // Check if the error code and text are available for API error object.\n            // If multiple error items are in the array. Handle them all as a separate error.\n            var errorItem = errorArray[j];\n\n            if (_.isObject(errorItem) && (errorItem.errorCode || errorItem.errorText)) {\n              var newError = {\n                errorCode: errorItem.errorCode,\n                errorText: errorItem.errorText,\n                // Reference to the original error structure.\n                // Then, additional information is available also through API if needed.\n                extension: error\n              }; // Perform an optimized deep comparison between already included errors and new error,\n              // to determine if the new error should be included or if it is a duplicate.\n\n              if (!contains(apiErrors, newError)) {\n                apiErrors.push(newError);\n              }\n            } else {\n              // Wrap the whole error as a cache error\n              // because unknown structure has been given.\n              useWrapError = true;\n            }\n          }\n        } else {\n          // Wrap the whole error as a cache error\n          // because unknown structure has been given.\n          useWrapError = true;\n        } // Check if the original error should be wrapped as an extension for API error object.\n\n\n        if (useWrapError) {\n          // Create api error from the cache error.\n          var newWrapError = {\n            errorCode: _.isObject(error) ? error.errorCode : undefined,\n            errorText: _.isObject(error) && _.isString(error.errorText) ? error.errorText : CACHE_ERROR_TEXT,\n            extension: error\n          }; // Perform an optimized deep comparison between already included errors and new error,\n          // to determine if the new error should be included or if it is a duplicate.\n\n          if (!contains(apiErrors, newWrapError)) {\n            apiErrors.push(newWrapError);\n          }\n        }\n      }\n    }\n\n    return apiErrors;\n  }\n  /**\r\n   * @private\r\n   *\r\n   * Convert sites data received from the parser to the structure that cache can handle.\r\n   *\r\n   * Notice, this function is called only if parser was used for the server requests.\r\n   * If data was already in cache, the flow does not come here.\r\n   *\r\n   * Notice, data is provided as structure of the objects.\r\n   * {@link SplitterCache#fillWith} function describes\r\n   * the object structure of the converted data. Cache data blocks are provided\r\n   * as the structure leaf objects. Notice, even if structure is created by using\r\n   * objects, it is better to include all the persisting data in the leaf cache block\r\n   * objects instead in the common parts in the middle of the structure. Then, data will\r\n   * always be available when data is requested from the cache.\r\n   *\r\n   * @param {Object} taskDef Definition object to describe cache blocks of the operation.\r\n   *                         May not be {undefined} or {null}.\r\n   * @param {Object} data Data from the parser. May be {undefined} or {null}.\r\n   * @param {Object} errors Errors that have occurred during loading and parsing data.\r\n   *                        May be {undefined} or {null}.\r\n   * @return {Object} Object that contains converted errors and converted data.\r\n   *                  {@link SplitterCache#fillWith} function describes\r\n   *                  the object structure of the converted data. May not be {undefined} or {null}.\r\n   */\n\n\n  function convertSitesDataFromParserForCache(taskDef, data, errors) {\n    var converted = {\n      // Data is converted below into the data object if data is available.\n      data: data ? {} : undefined,\n      // Cache handles errors according to node.js error convention.\n      // Therefore, instead of passing empty array for cache,\n      // error object should be set null if there are no errors.\n      errors: errors && !errors.length ? null : errors\n    };\n\n    if (data) {\n      // Convert the given data into the correct structure that is inserted\n      // into the convert object. Convert object contains location specific objects,\n      // which in turn contain measurement parameter specific objects, which contain arrays for\n      // cache data block objects. See SplitterCache#fillWith\n      // function for the corresponding structure that cache requires.\n      _.each(data.locations, function (location, key) {\n        // Location name is used as a key for the location object.\n        var locationName = taskDef.location[key];\n\n        if (!converted.data[locationName]) {\n          // Initialize converted data to contain location object identified by the location name.\n          converted.data[locationName] = {};\n        } // Location contains data array that contains measurement data objects\n        // and measurement related information.\n\n\n        _.each(location.data, function (dataObject, keyRequestParameter) {\n          if (!converted.data[locationName][keyRequestParameter]) {\n            // Initialize converted location object to contain measurement array\n            // identified by request parameter key. Notice, cache will internally loop\n            // through the cache block array by indexing it.\n            converted.data[locationName][keyRequestParameter] = [];\n          } // Loop through the actual measurement time-value-pair data objects.\n          // Also, check timesteps before giving array to cache.\n          // This may fix some indexing problems in cache if server has skipped some values.\n\n\n          checkResolutionSteps(dataObject.timeValuePairs, taskDef.resolution);\n\n          _.each(dataObject.timeValuePairs, function (timeValuePair) {\n            // This object is inserted into the cache as the actual data cache block.\n            // Notice, cache block have references to the same objects which means some redundancy.\n            // But, this way required data is always available when data is requested from the cache.\n            var cacheBlock = {\n              info: data.info,\n              properties: data.properties,\n              locationInfo: location.info,\n              blockProperty: dataObject.property,\n              timeValuePair: timeValuePair\n            };\n            converted.data[locationName][keyRequestParameter].push(cacheBlock);\n          });\n        });\n      });\n    }\n\n    return converted;\n  }\n  /**\r\n   * @private\r\n   *\r\n   * Convert sites data received from the cache to the structure that is provided through API.\r\n   *\r\n   * This data has been set in {convertSitesDataFromParserForCache} function for the cache.\r\n   *\r\n   * @param {Object} taskDef Definition object to describe cache blocks of the operation.\r\n   *                         May be {undefined} or {null}.\r\n   * @param {Object} data Parsed data from cache. May be {undefined} or {null}.\r\n   * @param {Array} errors Errors that have occurred during loading, parsing and caching data.\r\n   *                       May be {undefined} or {null}.\r\n   * @return {Object} Object that contains converted errors and converted data.\r\n   */\n\n\n  function convertSitesDataFromCacheForApi(taskDef, data, errors) {\n    var converted = {\n      // Data is converted below into the data object if data is available.\n      data: data ? {\n        info: undefined,\n        properties: undefined,\n        locations: []\n      } : undefined,\n      errors: convertCacheErrorsForApi(errors)\n    };\n\n    if (data) {\n      // Data provided before from parser and set by convertSitesDataFromParserForCache\n      // function for the cache is in data.data object. Notice, data is provided as\n      // data object hierarchy. Time values that cache has set itself are given as array.\n      // Notice, data.data object structure also contains the parsed time values from server.\n      // Here, data object contains locations that are identified by the location name key.\n      _.each(data.data, function (location) {\n        var convertedLocation = {\n          info: undefined,\n          data: {}\n        }; // Location object contains objects that are identified by the request parameters.\n\n        _.each(location, function (container, requestParameterKey) {\n          // Container object for the converted cache block data.\n          var convertedData = {\n            property: undefined,\n            timeValuePairs: []\n          }; // Each container identified by request parameter key contains cache data blocks in an array.\n\n          _.each(container, function (cacheBlock) {\n            // cacheBlock may be undefined if cache has reserved\n            // more timesteps for certain time range than parser has gotten\n            // for server request. Ignore undefined objects. Notice, that the\n            // correct times from server are still available in timeValuePair\n            // objects. Also, it is better to provide the parsed server data\n            // through API instead of extra undefined objects.\n            if (cacheBlock) {\n              if (!converted.data.info) {\n                // All locations have the same info object.\n                // Therefore, set content if data has not been set before.\n                converted.data.info = cacheBlock.info;\n              }\n\n              if (!converted.data.properties) {\n                // All locations have the same properties object.\n                // Therefore, set content if data has not been set before.\n                converted.data.properties = cacheBlock.properties;\n              }\n\n              if (!convertedData.property) {\n                // All the blocks of same location refere to the same property info.\n                // Therefore, set the information to the converted data object\n                // if data has not been set before.\n                convertedData.property = cacheBlock.blockProperty;\n              }\n\n              if (!convertedLocation.info) {\n                // All the block of same location refere to the same location info.\n                // Therefore, set the information to the converted location object\n                // if data has not been set before.\n                convertedLocation.info = cacheBlock.locationInfo;\n              } // Insert datablock time-value-pair into the datablock time-value-pair array.\n\n\n              convertedData.timeValuePairs.push(cacheBlock.timeValuePair);\n            }\n          }); // Insert converted datablock into the location.\n\n\n          convertedLocation.data[requestParameterKey] = convertedData;\n        }); // Insert converted location data into converted data locations array.\n\n\n        converted.data.locations.push(convertedLocation);\n      });\n    }\n\n    return converted;\n  }\n  /**\r\n   * @private\r\n   *\r\n   * This callback is set for sites cache data fetcher.\r\n   *\r\n   * Parser will provide the fetched and parsed data for this callback.\r\n   * This callback will forward the data in a correct format for the cache.\r\n   *\r\n   * @param {Object} container Object that provides connection instance specific private member variables.\r\n   *                           May not be {undefined} or {null}.\r\n   * @param {Object} taskDef Definition object to describe cache blocks of the operation.\r\n   *                         May not be {undefined} or {null}.\r\n   * @param {function(errors, data)} taskCallback Called with the parsed data and errors array when operation finishes.\r\n   *                                              May not be {undefined} or {null}.\r\n   */\n\n\n  function cacheSitesDataFetcherCallback(container, taskDef, taskCallback) {\n    container.parser.getData({\n      url: getUrlString(container.connectionUrl),\n      storedQueryId: container.storedQueryId,\n      requestParameter: taskDef.parameter,\n      begin: taskDef.start,\n      end: taskDef.end,\n      timestep: taskDef.resolution,\n      // If time adjusting is requested, it has been done before giving times to cache.\n      // Therefore, do not let parser do adjusting.\n      denyTimeAdjusting: true,\n      // Notice, instead of using taskDef.location for properties here,\n      // specific location related properties are used.\n      geoid: taskDef.geoid,\n      wmo: taskDef.wmo,\n      fmisid: taskDef.fmisid,\n      sites: taskDef.sites,\n      crs: taskDef.crs,\n      queryExtension: taskDef.queryExtension,\n      callback: function (data, errors) {\n        // Forward callback to the cache.\n        // Cache will forward the callback to callbacks given through the API when the retrieve flow has been started.\n        var converted = convertSitesDataFromParserForCache.call(container, taskDef, data, errors);\n        taskCallback(converted.errors, converted.data);\n      }\n    });\n  }\n  /**\r\n   * @private\r\n   *\r\n   * Request cache to retrive sites data.\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * Notice, this flow will also continue\r\n   * to data fetcher callback if parser should be used to retrieve data\r\n   * from the server. The callback function is set for cache when it is\r\n   * initialized. Callbacks given and set in this function are called when\r\n   * the data is gotten either from the server or directly from the cache.\r\n   *\r\n   * See API for function description.\r\n   */\n\n\n  var retrieveSitesData = function (options) {\n    var that = this;\n\n    if (!options.timestep || options.timestep === 1) {\n      // Cache requires that timestep is the actual timestep that is used for data.\n      // But, in speacial cases server may use magic numbers to handle data differently.\n      // Cache can not be used with the given options. Therefore, use parser directly.\n      that.parser.getData({\n        url: getUrlString(that.connectionUrl),\n        storedQueryId: that.storedQueryId,\n        requestParameter: options.requestParameter,\n        begin: options.begin,\n        end: options.end,\n        timestep: options.timestep,\n        // When parser is used directly, it can handle time adjusting automatically if requested.\n        denyTimeAdjusting: options.denyTimeAdjusting,\n        geoid: trimProperty(options.geoid),\n        wmo: trimProperty(options.wmo),\n        fmisid: trimProperty(options.fmisid),\n        sites: trimSites(options.sites),\n        crs: options.crs,\n        queryExtension: options.queryExtension,\n        callback: options.callback\n      });\n    } else {\n      // Use cache for sites data.\n      // If time adjusting is requested, it is done before values are given for the cache.\n      var beginDate = options.begin;\n      var endDate = options.end;\n      var resolution = options.timestep;\n\n      if (!options.denyTimeAdjusting) {\n        beginDate = that.parser.adjustBeginTime(resolution, beginDate);\n        endDate = that.parser.adjustEndTime(resolution, endDate, beginDate);\n      }\n\n      var taskDef = {\n        service: DATA_FETCHER_NAME_SITES,\n        parameter: _.isString(options.requestParameter) ? options.requestParameter.split(PARAMETER_SEPARATOR) : options.requestParameter,\n        // Make sure parameter(s) are integers instead of Date objects when they are given to cache.\n        start: beginDate instanceof Date ? beginDate.getTime() : beginDate,\n        end: endDate instanceof Date ? endDate.getTime() : endDate,\n        resolution: resolution,\n        crs: options.crs,\n        queryExtension: options.queryExtension\n      }; // Because locations can be given in multiple ways, location related properties are\n      // set separately for taskDef to combine all location informations for cache.\n\n      setTaskDefLocations(taskDef, options);\n      this.cache.fetch(taskDef, function (errors, result) {\n        var converted = convertSitesDataFromCacheForApi(taskDef, result, errors);\n        options.callback(converted.data, converted.errors);\n      }, options.progressCallback);\n    }\n  };\n  /**\r\n   * @private\r\n   *\r\n   * Request parser directly to retrive spatial data.\r\n   *\r\n   * Notice, cache is not used for spatial data.\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * Notice, this flow will also continue\r\n   * to data fetcher callback if parser should be used to retrieve data\r\n   * from the server. The callback function is set for cache when it is\r\n   * initialized. Callbacks given and set in this function are called when\r\n   * the data is gotten either from the server or directly from the cache.\r\n   *\r\n   */\n\n\n  var retrieveSpatialData = function (options) {\n    var that = this;\n    that.parser.getData({\n      url: getUrlString(that.connectionUrl),\n      storedQueryId: that.storedQueryId,\n      requestParameter: options.requestParameter,\n      begin: options.begin,\n      end: options.end,\n      timestep: options.timestep,\n      // When parser is used directly, it can handle time adjusting automatically if requested.\n      denyTimeAdjusting: options.denyTimeAdjusting,\n      // Include also other sites related options if they are given.\n      // But, bbox is the reason that all data is provided directly for the parser.\n      geoid: trimProperty(options.geoid),\n      wmo: trimProperty(options.wmo),\n      fmisid: trimProperty(options.fmisid),\n      sites: trimSites(options.sites),\n      bbox: options.bbox,\n      crs: options.crs,\n      latlon: options.latlon,\n      queryExtension: options.queryExtension,\n      callback: options.callback\n    });\n  };\n  /**\r\n   * @private\r\n   *\r\n   * Wraps the function calls inside try-catch before calling.\r\n   *\r\n   * Instead of using multiple try catches in many functions only one is used here.\r\n   * This style may improve performance.\r\n   *\r\n   * Notice, this function applies this-reference to the function calls.\r\n   *\r\n   * @param {function} func Function that should be called.\r\n   *                        May not be {undefined} or {null}.\r\n   * @param {function} callback Callback function that is called if an exception occurs\r\n   *                            during this synchronous part of the flow. Notice, this\r\n   *                            is a callback that may be provided for asynchronous flow.\r\n   *                            May be {undefined} or {null}.\r\n   * @return {boolean} {true} if operation starts successfully. Else {false}.\r\n   *                          Notice, if {callback} is given, it is also called\r\n   *                          if false is returned for success.\r\n   */\n\n\n  var makeSafe = function (func, callback) {\n    var success = true;\n\n    try {\n      // Call the correct function with the original arguments.\n      // Function reference itself is removed from the arguments.\n      // Also, callback reference provided for synchronous exception\n      // handling is removed from the arguments.\n      var args = Array.prototype.slice.call(arguments);\n      args.shift();\n      args.shift();\n      func.apply(this, args);\n    } catch (e) {\n      var errorStr = \"ERROR: API level error occurred in a synchronous flow!\";\n\n      if (\"undefined\" !== typeof console && console) {\n        console.error(errorStr);\n        console.error(e);\n      }\n\n      success = false;\n\n      if (callback) {\n        // Inform callback about exception in the flow.\n        // Then, caller knows that asynchronous flow has ended.\n        var error = {\n          errorText: errorStr\n        };\n        callback(undefined, error);\n      }\n    }\n\n    return success;\n  };\n  /**\r\n   * @private\r\n   *\r\n   * Get a URL string. If an array of URLs has been set to make use of domain sharding, a random array member is returned.\r\n   *\r\n   */\n\n\n  var getUrlString = function (urlOption) {\n    if (_.isArray(urlOption)) {\n      return urlOption[Math.floor(Math.random() * urlOption.length)];\n    } else {\n      return urlOption;\n    }\n  };\n  /**\r\n   * @private\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * See API for function description.\r\n   */\n\n\n  var getUrl = function () {\n    return this.connectionUrl;\n  };\n  /**\r\n   * @private\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * See API for function description.\r\n   */\n\n\n  var getStoredQueryId = function () {\n    return this.storedQueryId;\n  };\n  /**\r\n   * @private\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * See API for function description.\r\n   */\n\n\n  var connect = function (url, storedQueryId) {\n    // Skip if already connected.\n    // Notice, if already connected, this function does not reconnect\n    // even if a new URL would be different than the old one.\n    if (!this.connectionUrl) {\n      if (!_.isString(url) && !_.isArray(url) || !url.length || !url) {\n        var urlErrorStr = \"ERROR: WfsConnection URL must be a string or an array and not empty!\";\n\n        if (\"undefined\" !== typeof console && console) {\n          console.error(urlErrorStr);\n        }\n\n        throw urlErrorStr;\n      }\n\n      if (!_.isString(storedQueryId) || !storedQueryId) {\n        var idErrorStr = \"ERROR: WfsConnection stored query ID must be a string and not empty!\";\n\n        if (\"undefined\" !== typeof console && console) {\n          console.error(idErrorStr);\n        }\n\n        throw idErrorStr;\n      }\n\n      this.connectionUrl = url;\n      this.storedQueryId = storedQueryId;\n    }\n  };\n  /**\r\n   * @private\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * See API for function description.\r\n   */\n\n\n  var disconnect = function () {\n    this.connectionUrl = undefined;\n    this.storedQueryId = undefined;\n    resetCache.call(this);\n  };\n  /**\r\n   * @private\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * See API for function description.\r\n   */\n\n\n  var resetCache = function () {\n    this.cache.clearCache();\n  };\n  /**\r\n   * @private\r\n   *\r\n   * See API for function description.\r\n   */\n\n\n  var getData = function (options) {\n    if (options) {\n      if (options.bbox || options.latlon) {\n        // BBox nor LatLon are not supported by the cache at the moment.\n        // Therefore, pass the whole query to the parser.\n        retrieveSpatialData.call(this, options);\n      } else if (options.geoid || options.wmo || options.fmisid || options.sites) {\n        retrieveSitesData.call(this, options);\n      } else {\n        var errorStr = \"ERROR: Either geoid, wmo, fmisid, sites, bbox or latlon is mandatory in options!\";\n\n        if (\"undefined\" !== typeof console && console) {\n          console.error(errorStr);\n        }\n\n        throw errorStr;\n      }\n    } else {\n      var optionsErrorStr = \"ERROR: Options object is mandatory!\";\n\n      if (\"undefined\" !== typeof console && console) {\n        console.error(optionsErrorStr);\n      }\n\n      throw optionsErrorStr;\n    }\n  };\n  /**\r\n   * Constructor for the connection instance.\r\n   *\r\n   * Notice, this constructor is returned from {WfsConnection}\r\n   * and can be used for instantiation later.\r\n   */\n\n\n  var connectionConstructor = function (splitterCacheConfig) {\n    // Reference to the connection instance object.\n    var that = this; // {SplitterCache} configuration\n\n    splitterCacheConfig = splitterCacheConfig || {\n      sideFetchAfterFactor: 1,\n      sideFetchBeforeFactor: 0.5,\n      maxBlockDataPoints: 200,\n      maxCacheDataSize: 4000\n    }; // Private object is used for API functions to provide them private member variables.\n    // Instance specific data is available for API functions when reference to this private\n    // object is applied to the function calls by using this private object. Then, these\n    // variables and functions are capsulated and are not available outside of the connection\n    // instance.\n\n    this._private = {\n      // Reference to the connection instance object.\n      connectionInstance: that,\n      // Member variables that are initialized to undefined.\n      // When connection function is called these are set.\n      connectionUrl: undefined,\n      storedQueryId: undefined,\n      // Member variables that are initialized to values that are used\n      // throughout the lifetime of object instance.\n      // Cache for retrieved data.\n      cache: new SplitterCache(splitterCacheConfig),\n      parser: new WfsRequestParser()\n    }; //=================================================================\n    // Public WfsConnection API is defined here as priviledged functions.\n    //=================================================================\n\n    /**\r\n     * Synchronous.\r\n     *\r\n     * @return {String} URL that is used for the connection and\r\n     *                  has been set when {connect} function is called.\r\n     *                  May be {undefined} if state is not connected.\r\n     */\n\n    this.getUrl = function () {\n      return getUrl.call(this._private);\n    };\n    /**\r\n     * Synchronous.\r\n     *\r\n     * @return {String} Stored query ID that is used for the connection\r\n     *                  and has been set when {connect} function is called.\r\n     *                  May be {undefined} if state is not connected.\r\n     */\n\n\n    this.getStoredQueryId = function () {\n      return getStoredQueryId.call(this._private);\n    };\n    /**\r\n     * Synchronous.\r\n     *\r\n     * Notice, if already connected, this function does not reconnect\r\n     * even if a new URL would be different than the old one.\r\n     *\r\n     * @param {String} url URL that is used for the connection.\r\n     *                     May not be {undefined}, {null} or empty.\r\n     * @param {String} storedQueryId Stored query ID to identify the data that is requested.\r\n     *                               For example, stored query ID may be used to request\r\n     *                               observed data or forecast data.\r\n     *                               May not be {undefined}, {null} or empty.\r\n     * @return {boolean} {true} if synchronous operation was successfull. Else {false}.\r\n     */\n\n\n    this.connect = function (url, storedQueryId) {\n      var that = this; // Set data fetcher that cache uses for the given type of the data.\n\n      this._private.cache.addDataProvider(DATA_FETCHER_NAME_SITES, function (taskDef, callback) {\n        cacheSitesDataFetcherCallback(that._private, taskDef, callback);\n      });\n\n      return makeSafe.call(that._private, connect, undefined, url, storedQueryId);\n    };\n    /**\r\n     * Synchronous.\r\n     *\r\n     * Releases resources.\r\n     *\r\n     * @return {boolean} {true} if synchronous operation was successfull. Else {false}.\r\n     */\n\n\n    this.disconnect = function () {\n      return makeSafe.call(this._private, disconnect, undefined);\n    };\n    /**\r\n     * Synchronous.\r\n     *\r\n     * Releases cache resources.\r\n     *\r\n     * @return {boolean} {true} if synchronous operation was successfull. Else {false}.\r\n     */\n\n\n    this.resetCache = function () {\n      return makeSafe.call(this._private, resetCache, undefined);\n    };\n    /**\r\n     * Request data.\r\n     *\r\n     * Operation is asynchronous.\r\n     *\r\n     * Notice, callback is {function(data, errors){}}.\r\n     *      - data: Data object provides locations data.\r\n     *              May be {undefined} if an error has occurred.\r\n     *              The object is of this structure:\r\n     *          {\r\n     *              // General information received in the server response for the request.\r\n     *              // May not be {undefined} or {null}.\r\n     *              // Content properties are set if given in the server response.\r\n     *              info : {\r\n     *                  begin : {Date|undefined},\r\n     *                  end : {Date|undefined}\r\n     *              },\r\n     *              // Properties provide descriptive property objects that correspond to\r\n     *              // the parameter keys that have been given for the request. Notice,\r\n     *              // property data is also available inside locations data objects.\r\n     *              // This object is provided as a complementary object, if reference to a single\r\n     *              // wrapper object is later needed for general information about properties.\r\n     *              properties : {\r\n     *                  parameterAsKey : { label : \"labelString\",\r\n     *                                     unit : \"measurementUnitString\",\r\n     *                                     phenomenon : \"phenomenonString\",\r\n     *                                     statisticalFunction : \"statisticalFunctionString\",\r\n     *                                     statisticalPeriod : \"statisticalAggregationTimePeriod\" },\r\n     *                  ...\r\n     *              },\r\n     *              // Data of locations. May be empty if sites data is not provided.\r\n     *              // May not be {undefined} or {null}.\r\n     *              locations : [\r\n     *                  {\r\n     *                      info : {\r\n     *                          id : \"location id string\",\r\n     *                          geoid : \"geoid string\",\r\n     *                          wmo : \"wmo string\",\r\n     *                          fmisid : \"fmisid string\",\r\n     *                          name : \"location name string\",\r\n     *                          region : \"region name string\",\r\n     *                          country : \"country name string\",\r\n     *                          timezone : \"timezone name string\",\r\n     *                          position : [ \"positionStringPart1\", \"positionStringPart2\", ... ]\r\n     *                      },\r\n     *                      data : {\r\n     *                          // Data property keys correspond to the parameter keys\r\n     *                          // that have been given for the request.\r\n     *                          parameterAsKey : {\r\n     *                            property : { label : \"labelString\",\r\n     *                                         unit : \"measurementUnitString\",\r\n     *                                         phenomenon : \"phenomenonString\",\r\n     *                                         statisticalFunction : \"statisticalFunctionString\",\r\n     *                                         statisticalPeriod : \"statisticalAggregationTimePeriod\" },\r\n     *                            timeValuePairs : [ { time : intTimeInMsSince01011970,\r\n     *                                                 value : floatMeasurementValue }, ... ]\r\n     *                          },\r\n     *                          ...\r\n     *                      }\r\n     *                  },\r\n     *                  ...\r\n     *              ]\r\n     *          }\r\n     *      - errors: Array that contains possible errors that occurred during the flow. Array is\r\n     *                always provided even if it may be empty. If an error occurs in this parser,\r\n     *                an error string is pushed here. Also, when an HTTP error occurs, error contains\r\n     *                the textual portion of the HTTP status, such as \"Not Found\" or \"Internal Server Error.\"\r\n     *                Errors parameter is of this structure:\r\n     *          [\r\n     *              {\r\n     *                  // None, one, or more of the following error values may exist.\r\n     *                  // Values may also be {undefined} or {null}.\r\n     *                  errorCode : \"errorCodeString\",\r\n     *                  errorText : \"errorTextString\",\r\n     *                  extension : {Object}\r\n     *              },\r\n     *              ...\r\n     *          ]\r\n     *\r\n     * Notice, object properties of the function {options} parameter are URL encoded by this library\r\n     * before they are inserted into the request URL.\r\n     *\r\n     * @param {Object} options Mandatory. May not be {undefined} or {null}. Object structure:\r\n     *     {\r\n     *         requestParameter : {String|Array(String)}\r\n     *                            Mandatory property. May not be {undefined} or {null}. Array may not be empty.\r\n     *                            This is one of the parameter strings that is part of\r\n     *                            URL parameters to define which data is requested from the server.\r\n     *                            Parameter string may contain request for multiple parameters.\r\n     *                            For example, value for dew point temperature may be \"td\".\r\n     *                            If an array is given, strings are given as separate array string items.\r\n     *         begin : {int|Date}\r\n     *                 Mandatory property. May not be {undefined} or {null}.\r\n     *                 The begin time for the data.\r\n     *                 Integer value is number of milliseconds since 01.01.1970 that can be gotten,\r\n     *                 for example, with {Date::getTime()}. Alternatively, {Date} object may be given.\r\n     *         end : {int|Date}\r\n     *               Mandatory property. May not be {undefined} or {null}.\r\n     *               The end time for the data.\r\n     *               Value is number of milliseconds since 01.01.1970 that can be gotten,\r\n     *               for example, with {Date::getTime()}. Alternatively, {Date} object may be given.\r\n     *         timestep : {int}\r\n     *                    May be {undefined} or {null}.\r\n     *                    Timestep in milliseconds.\r\n     *                    If {undefined}, {null} or zero, server returns all data for\r\n     *                    the given time interval. If timestep is 1, server uses the default\r\n     *                    timestep. Notice, even if time is in milliseconds here, it is converted\r\n     *                    and floored to minutes before sending for the server.\r\n     *         denyTimeAdjusting : {boolean}\r\n     *                             May be {undefined} or {null}.\r\n     *                             If {true}, {begin} and {end} times are not adjusted for server but given values\r\n     *                             are used exactly for requests. Otherwise, times are adjusted.\r\n     *         geoid : {Array(String|int)|String|int}\r\n     *                 May be {undefined} or {null} or empty if {wmo}, {fmisid}, {sites} or {bbox} is given.\r\n     *                 Array of Geographical name ID (geonames.org) strings or integers.\r\n     *                 One geoid can be given as a single string or integer.\r\n     *                 Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n     *         wmo : {Array(String|int)|String|int}\r\n     *               May be {undefined} or {null} or empty if {geoid}, {fmisid}, {sites} or {bbox} is given.\r\n     *               Array of World Meteorological Organization (WMO) identifier strings or integers.\r\n     *               One wmo can be given as a single string or integer.\r\n     *               Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n     *         fmisid : {Array(String|int)|String|int}\r\n     *                  May be {undefined} or {null} or empty if {geoid}, {wmo}, {sites} or {bbox} is given.\r\n     *                  Array of FMI observation station identifiers (fmisid) strings or integers.\r\n     *                  One fmisid can be given as a single string or integer.\r\n     *                  Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n     *         sites : {Array(String)|String}\r\n     *                 May be {undefined} or {null} or empty if {geoid}, {wmo}, {fmisid} or {bbox} is given.\r\n     *                 Array of site name strings. One site can be given as a single string.\r\n     *                 Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n     *         bbox : {String}\r\n     *                May be {undefined}, {null} or empty if {geoid}, {wmo}, {fmisid} or {sites} is given.\r\n     *                BBOX string. Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n     *                Notice, cache is not used if spatial data (bbox) is queried.\r\n     *         crs : {String}\r\n     *               May be {undefined}, {null} or empty.\r\n     *               Coordinate Reference System (CRS) string.\r\n     *         queryExtension : {Object}\r\n     *                          Optional. May be {undefined} or {null}.\r\n     *                          Property values may be {undefined}, {null} or {string}.\r\n     *                          This property is not needed in normal use cases of the API.\r\n     *                          But, this property may be used if API does not support field-value-pairs\r\n     *                          that need to be included into request URL query. The key-value-pairs of\r\n     *                          the property are URL encoded and included as URL query field-value-pairs\r\n     *                          in the request. If property value is {undefined} or {null}, it is interpreted\r\n     *                          as an empty string. Notice, other API properties should be used instead of this\r\n     *                          extension if possible.\r\n     *         callback : {function(data, errors)}\r\n     *                    Mandatory property. May not be {undefined} or {null}.\r\n     *                    Callback is called with the parsed data and errors array when operation finishes.\r\n     *                    If an error occurs, data is set {undefined} for the callback. Possible errors are\r\n     *                    given inside the array that is always provided.\r\n     *         progressCallback : {function(err, partStart, partEnd)}\r\n     *                            Not mandatory property.\r\n     *                            Called when part of the flow has finished.\r\n     *                            Function is called with {err}, {partStart} and {partEnd} parameters.\r\n     *     }\r\n     * @return {boolean} {true} if asynchronous operation is successfully started. Else {false}.\r\n     */\n\n\n    this.getData = function (options) {\n      return makeSafe.call(this._private, getData, options ? options.callback : undefined, options);\n    };\n  }; // Constructor function is returned for later instantiation.\n\n\n  return connectionConstructor;\n}();\n\nmodule.exports = WfsConnection;","map":{"version":3,"sources":["C:/Users/Ossi Laurila/Desktop/weatherapp/node_modules/@fmidev/metolib/wfsconnection.js"],"names":["jQuery","require","_","async","SplitterCache","WfsRequestParser","WfsConnection","DATA_FETCHER_NAME_SITES","PARAMETER_SEPARATOR","LOCATION_NAME_REGION_SEPARATOR","LOCATION_GEOID_PREFIX","LOCATION_WMO_PREFIX","LOCATION_FMISID_PREFIX","LOCATION_SITES_PREFIX","CACHE_ERROR_TEXT","trimSingleSite","site","trim","replace","trimSites","sites","prefix","trimmed","isString","push","isArray","i","length","trimProperty","property","isNumber","tmp","setTaskDefLocations","taskDef","options","location","geoid","wmo","fmisid","apply","checkResolutionSteps","array","resolution","previousTimeValuePair","timeValuePair","isObject","previousTime","time","undefined","splice","value","NaN","contains","list","item","find","currentItem","isEqual","convertCacheErrorsForApi","errors","apiErrors","error","useWrapError","errorCode","errorText","errorArray","j","errorItem","newError","extension","newWrapError","convertSitesDataFromParserForCache","data","converted","each","locations","key","locationName","dataObject","keyRequestParameter","timeValuePairs","cacheBlock","info","properties","locationInfo","blockProperty","convertSitesDataFromCacheForApi","convertedLocation","container","requestParameterKey","convertedData","cacheSitesDataFetcherCallback","taskCallback","parser","getData","url","getUrlString","connectionUrl","storedQueryId","requestParameter","parameter","begin","start","end","timestep","denyTimeAdjusting","crs","queryExtension","callback","call","retrieveSitesData","that","beginDate","endDate","adjustBeginTime","adjustEndTime","service","split","Date","getTime","cache","fetch","result","progressCallback","retrieveSpatialData","bbox","latlon","makeSafe","func","success","args","Array","prototype","slice","arguments","shift","e","errorStr","console","urlOption","Math","floor","random","getUrl","getStoredQueryId","connect","urlErrorStr","idErrorStr","disconnect","resetCache","clearCache","optionsErrorStr","connectionConstructor","splitterCacheConfig","sideFetchAfterFactor","sideFetchBeforeFactor","maxBlockDataPoints","maxCacheDataSize","_private","connectionInstance","addDataProvider","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * This software may be freely distributed and used under the following MIT license:\r\n *\r\n * Copyright (c) 2017 Finnish Meteorological Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the\r\n * Software without restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n * Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\r\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n// Strict mode for whole file.\r\n\"use strict\";\r\n\r\n// Requires jQuery, lodash, async\r\nvar jQuery = require('jquery');\r\nvar _ = require('lodash');\r\nvar async = require('async');\r\n// import jQuery from 'jquery';\r\n// import _ from 'lodash';\r\n// import async from 'async';\r\n\r\n// Requires SplitterCache, WfsRequestParser\r\nvar SplitterCache = require('./splittercache.js');\r\nvar WfsRequestParser = require('./wfsrequestparser.js');\r\n// import SplitterCache from './splittercache.js';\r\n// import WfsRequestParser from './wfsrequestparser.js';\r\n\r\n/**\r\n * WfsConnection object acts as an interface that provides functions\r\n * to asynchronously request XML data from the server and to get\r\n * the requested data in a parsed structure.\r\n *\r\n * WfsConnection wraps cache, request and parser functionality.\r\n * Notice, if you do not require cache functionality, you may\r\n * want to use parser, {@link WfsRequestParser},\r\n * directly without using this class as an intermediate object.\r\n *\r\n * API functions are defined in the end of the constructor,\r\n * {connectionConstructor}, as priviledged functions.\r\n * See API description there.\r\n *\r\n * Example:\r\n *      var connection = new WfsConnection();\r\n *      if (connection.connect(SERVER_URL, STORED_QUERY_OBSERVATION)) {\r\n *          // Connection was properly initialized. So, get the data.\r\n *          connection.getData({\r\n *              requestParameter : \"td,ws_10min\",\r\n *              // Integer values are used to init dates for older browsers.\r\n *              // (new Date(\"2013-05-10T08:00:00Z\")).getTime()\r\n *              // (new Date(\"2013-05-12T10:00:00Z\")).getTime()\r\n *              begin : new Date(1368172800000),\r\n *              end : new Date(1368352800000),\r\n *              timestep : 60 * 60 * 1000,\r\n *              sites : [\"Kaisaniemi,Helsinki\", \"Turku\"],\r\n *              callback : function(data, errors) {\r\n *                  // Handle the data and errors object in a way you choose.\r\n *                  handleCallback(data, errors);\r\n *                  // If the connection will not be used anymore later,\r\n *                  // the connection may be disconnected because the flow has finished.\r\n *                  connection.disconnect();\r\n *              }\r\n *          });\r\n *      }\r\n */\r\n\r\nvar WfsConnection = (function() {\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Data fetcher name for cache when sites are used for fetching.\r\n     */\r\n    var DATA_FETCHER_NAME_SITES = \"parserSites\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Parameter values are separated by this string.\r\n     */\r\n    var PARAMETER_SEPARATOR = \",\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Location name and region strings may be separated by this string\r\n     * in server responses.\r\n     */\r\n    var LOCATION_NAME_REGION_SEPARATOR = \" \";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Geoid location name prefix for cache.\r\n     */\r\n    var LOCATION_GEOID_PREFIX = \"g_\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * WMO location name prefix for cache.\r\n     */\r\n    var LOCATION_WMO_PREFIX = \"w_\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * FMISID location name prefix for cache.\r\n     */\r\n    var LOCATION_FMISID_PREFIX = \"f_\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Sites location name prefix for cache.\r\n     */\r\n    var LOCATION_SITES_PREFIX = \"s_\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * General text that describes an error that has been found in cache.\r\n     */\r\n    var CACHE_ERROR_TEXT = \"ERROR: Cache found error(s)!\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Trim single site string for cache flow.\r\n     *\r\n     * @param {String} May not be {undefined} or {null}.\r\n     */\r\n    function trimSingleSite(site) {\r\n        return jQuery.trim(site).replace(/,\\s+/, PARAMETER_SEPARATOR);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Trim unnecessary white spaces from sites string(s).\r\n     *\r\n     * Notice, new content is returned. Then, original values are not changed if an array is given.\r\n     *\r\n     * @param {Array(String)|String} Site strings in an array or one site may be given as a single string.\r\n     *                               May be {udefined} or {null} but then operation is ignored.\r\n     * @param {String} prefix Prefix string that is used with the value(s).\r\n     *                        This is meant for cache but should not be used for parser.\r\n     *                        May be {udefined} or {null}. Then, empty string is used.\r\n     * @return {Array(String)} Trimmed site(s) in an array. May not be {undefined} or {null}.\r\n     */\r\n    function trimSites(sites, prefix) {\r\n        var trimmed = [];\r\n        if (!_.isString(prefix)) {\r\n            // Make sure prefix is at least an empty string.\r\n            prefix = \"\";\r\n        }\r\n        // Handle sites as string(s).\r\n        if (sites && _.isString(sites)) {\r\n            // Trim possible white spaces.\r\n            // Location and its region may be separated by using comma but there should not be whitespaces after comma.\r\n            // Then, later it is easier to compare server responses with given sites when data is handled for cache.\r\n            trimmed.push(prefix + trimSingleSite(sites));\r\n\r\n        } else if (_.isArray(sites)) {\r\n            for (var i = 0; i < sites.length; ++i) {\r\n                var site = sites[i];\r\n                if (site && _.isString(site)) {\r\n                    trimmed.push(prefix + trimSingleSite(site));\r\n                }\r\n            }\r\n        }\r\n        return trimmed;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Trim unnecessary white spaces from string(s).\r\n     *\r\n     * Notice, new content is returned. Then, original values are not changed if an array is given.\r\n     *\r\n     * @param {Array(String|int)|String|int} property Strings or integers in an array\r\n     *                                                or one item as a single string or integer.\r\n     *                                                May be {udefined} or {null}.\r\n     * @param {String} prefix Prefix string that is used with the value(s).\r\n     *                        This is meant for cache but should not be used for parser.\r\n     *                        May be {udefined} or {null}. Then, empty string is used.\r\n     * @return {Array(String)} Trimmed value(s) in an array. May not be {undefined} or {null}.\r\n     */\r\n    function trimProperty(property, prefix) {\r\n        var trimmed = [];\r\n        if (!_.isString(prefix)) {\r\n            // Make sure prefix is at least an empty string.\r\n            prefix = \"\";\r\n        }\r\n        if (_.isNumber(property) || property && _.isString(property)) {\r\n            trimmed.push(jQuery.trim(prefix + property));\r\n\r\n        } else if (_.isArray(property)) {\r\n            for (var i = 0; i < property.length; ++i) {\r\n                var tmp = property[i];\r\n                // Handle property as string.\r\n                if (_.isNumber(tmp) || tmp && _.isString(tmp)) {\r\n                    trimmed.push(jQuery.trim(prefix + tmp));\r\n                }\r\n            }\r\n        }\r\n        return trimmed;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Cache {taskDef} location should contain all the locations (not just sites names).\r\n     * This function combines all the location information into one array that is\r\n     * set as {location} -property for the cache {taskDef}. Also, other properties that\r\n     * are used for {taskDef} location property are set.\r\n     *\r\n     * @param {Object} taskDef Target for location settings.\r\n     *                         Operation is ignored if {undefined} or {null}.\r\n     * @param {Object} options Options object given through the API.\r\n     *                         Provides location data for {taskDef}.\r\n     *                         Operation is ignored if {undefined} or {null}.\r\n     */\r\n    function setTaskDefLocations(taskDef, options) {\r\n        if (taskDef && options) {\r\n            var location = [];\r\n            taskDef.location = location;\r\n            // Notice, these properties are used to provide additional information\r\n            // that can be given for the parser. The cache uses location property\r\n            // to create the cache hierarchy.\r\n            taskDef.geoid = trimProperty(options.geoid);\r\n            taskDef.wmo = trimProperty(options.wmo);\r\n            taskDef.fmisid = trimProperty(options.fmisid);\r\n            taskDef.sites = trimSites(options.sites);\r\n            // Combine locations information for taskDef location.\r\n            // Notice, prefix is used for cache. Then, it is sure that different location\r\n            // requests do not have same string for key (really rare case).\r\n            location.push.apply(location, trimProperty(options.geoid, LOCATION_GEOID_PREFIX));\r\n            location.push.apply(location, trimProperty(options.wmo, LOCATION_WMO_PREFIX));\r\n            location.push.apply(location, trimProperty(options.fmisid, LOCATION_FMISID_PREFIX));\r\n            location.push.apply(location, trimSites(options.sites, LOCATION_SITES_PREFIX));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Check that time-value-pair objects are not missing from the given array.\r\n     * If an object is missing, time-value-pair of the correct time and NaN value\r\n     * is inserted into the array according to the resolution step.\r\n     *\r\n     * @param {[]} array Array that contains time-value-pair objects.\r\n     *                   Operation is ignored if {undefined} or {null}.\r\n     * @param {Integer} resolution Time in milliseconds to describe timesteps between values.\r\n     *                             Operation is ignored if {undefined}, {null}, zero or negative.\r\n     */\r\n    function checkResolutionSteps(array, resolution) {\r\n        if (_.isArray(array) && resolution && resolution > 0) {\r\n            for (var i = 1; i < array.length; ++i) {\r\n                var previousTimeValuePair = array[i - 1];\r\n                var timeValuePair = array[i];\r\n                if (_.isObject(timeValuePair)) {\r\n                    var previousTime = _.isObject(previousTimeValuePair) ? previousTimeValuePair.time : undefined;\r\n                    var time = timeValuePair.time;\r\n                    if (undefined !== previousTime && null !== previousTime && undefined !== time && null !== time && resolution < time - previousTime) {\r\n                        // Time-value-pair object is missing between two array objects.\r\n                        // Insert a new NaN value pair into array.\r\n                        // Notice, time of this new object is compared in next round to the\r\n                        // same object that is checked already in this round.\r\n                        // Then, missing resolution objects are added properly into too large gaps.\r\n                        time = previousTime + resolution;\r\n                        array.splice(i, 0, {\r\n                            time : time,\r\n                            value : NaN\r\n                        });\r\n                    }\r\n                    previousTime = time;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Check if given {list} contains an equal to the given {item}.\r\n     *\r\n     * Performs an optimized deep comparison between the objects of the {list} and given {item},\r\n     * to determine if they should be considered equal.\r\n     *\r\n     * @param {Array} list List whose items are compared to {item}. May be {undefined} or {null}.\r\n     * @param {Object} item Item that is compared to the list items. May be {undefined} or {null}.\r\n     * @return {Boolean} {true} if {item} equals at least one item in {list}.\r\n     */\r\n    function contains(list, item) {\r\n        return _.find(list, function(currentItem) {\r\n            return _.isEqual(currentItem, item);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Converts errors given by cache to the error objects given through API.\r\n     * Possible duplicates are not included into the returned array.\r\n     *\r\n     * @param {Array} errors Errors array from the cache that is converted to API errors array.\r\n     *                       May be {undefined} or {null}.\r\n     * @return {Array} Converted errors in an array. May not be {undefined} or {null}.\r\n     */\r\n    function convertCacheErrorsForApi(errors) {\r\n        var apiErrors = [];\r\n        if (_.isArray(errors)) {\r\n            for (var i = 0; i < errors.length; ++i) {\r\n                var error = errors[i];\r\n                // Flag to inform if error item should just be wrapped as a general cache error\r\n                // or if error content has been handled separately. Always include wrapped error\r\n                // into array if cache error root level already contains errorCode or errorText information.\r\n                var useWrapError = _.isObject(error) && (error.errorCode || error.errorText);\r\n                // Cache error structure may wrap errors gotten from parser.\r\n                // Check if parser has provided errors. Then, that error information can be included\r\n                // in the root level of the API error.\r\n                if (_.isObject(error) && _.isArray(error.error) && error.error.length > 0) {\r\n                    var errorArray = error.error;\r\n                    for (var j = 0; j < errorArray.length; ++j) {\r\n                        // Error array may contain the actual parse error.\r\n                        // Check if the error code and text are available for API error object.\r\n                        // If multiple error items are in the array. Handle them all as a separate error.\r\n                        var errorItem = errorArray[j];\r\n                        if (_.isObject(errorItem) && (errorItem.errorCode || errorItem.errorText)) {\r\n                            var newError = {\r\n                                errorCode : errorItem.errorCode,\r\n                                errorText : errorItem.errorText,\r\n                                // Reference to the original error structure.\r\n                                // Then, additional information is available also through API if needed.\r\n                                extension : error\r\n                            };\r\n                            // Perform an optimized deep comparison between already included errors and new error,\r\n                            // to determine if the new error should be included or if it is a duplicate.\r\n                            if (!contains(apiErrors, newError)) {\r\n                                apiErrors.push(newError);\r\n                            }\r\n\r\n                        } else {\r\n                            // Wrap the whole error as a cache error\r\n                            // because unknown structure has been given.\r\n                            useWrapError = true;\r\n                        }\r\n                    }\r\n\r\n                } else {\r\n                    // Wrap the whole error as a cache error\r\n                    // because unknown structure has been given.\r\n                    useWrapError = true;\r\n                }\r\n                // Check if the original error should be wrapped as an extension for API error object.\r\n                if (useWrapError) {\r\n                    // Create api error from the cache error.\r\n                    var newWrapError = {\r\n                        errorCode : _.isObject(error) ? error.errorCode : undefined,\r\n                        errorText : _.isObject(error) && _.isString(error.errorText) ? error.errorText : CACHE_ERROR_TEXT,\r\n                        extension : error\r\n                    };\r\n                    // Perform an optimized deep comparison between already included errors and new error,\r\n                    // to determine if the new error should be included or if it is a duplicate.\r\n                    if (!contains(apiErrors, newWrapError)) {\r\n                        apiErrors.push(newWrapError);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return apiErrors;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Convert sites data received from the parser to the structure that cache can handle.\r\n     *\r\n     * Notice, this function is called only if parser was used for the server requests.\r\n     * If data was already in cache, the flow does not come here.\r\n     *\r\n     * Notice, data is provided as structure of the objects.\r\n     * {@link SplitterCache#fillWith} function describes\r\n     * the object structure of the converted data. Cache data blocks are provided\r\n     * as the structure leaf objects. Notice, even if structure is created by using\r\n     * objects, it is better to include all the persisting data in the leaf cache block\r\n     * objects instead in the common parts in the middle of the structure. Then, data will\r\n     * always be available when data is requested from the cache.\r\n     *\r\n     * @param {Object} taskDef Definition object to describe cache blocks of the operation.\r\n     *                         May not be {undefined} or {null}.\r\n     * @param {Object} data Data from the parser. May be {undefined} or {null}.\r\n     * @param {Object} errors Errors that have occurred during loading and parsing data.\r\n     *                        May be {undefined} or {null}.\r\n     * @return {Object} Object that contains converted errors and converted data.\r\n     *                  {@link SplitterCache#fillWith} function describes\r\n     *                  the object structure of the converted data. May not be {undefined} or {null}.\r\n     */\r\n    function convertSitesDataFromParserForCache(taskDef, data, errors) {\r\n        var converted = {\r\n            // Data is converted below into the data object if data is available.\r\n            data : data ? {} : undefined,\r\n            // Cache handles errors according to node.js error convention.\r\n            // Therefore, instead of passing empty array for cache,\r\n            // error object should be set null if there are no errors.\r\n            errors : errors && !errors.length ? null : errors\r\n        };\r\n        if (data) {\r\n            // Convert the given data into the correct structure that is inserted\r\n            // into the convert object. Convert object contains location specific objects,\r\n            // which in turn contain measurement parameter specific objects, which contain arrays for\r\n            // cache data block objects. See SplitterCache#fillWith\r\n            // function for the corresponding structure that cache requires.\r\n            _.each(data.locations, function(location, key) {\r\n                // Location name is used as a key for the location object.\r\n                var locationName = taskDef.location[key];\r\n                if (!converted.data[locationName]) {\r\n                    // Initialize converted data to contain location object identified by the location name.\r\n                    converted.data[locationName] = {};\r\n                }\r\n                // Location contains data array that contains measurement data objects\r\n                // and measurement related information.\r\n                _.each(location.data, function(dataObject, keyRequestParameter) {\r\n                    if (!converted.data[locationName][keyRequestParameter]) {\r\n                        // Initialize converted location object to contain measurement array\r\n                        // identified by request parameter key. Notice, cache will internally loop\r\n                        // through the cache block array by indexing it.\r\n                        converted.data[locationName][keyRequestParameter] = [];\r\n                    }\r\n                    // Loop through the actual measurement time-value-pair data objects.\r\n                    // Also, check timesteps before giving array to cache.\r\n                    // This may fix some indexing problems in cache if server has skipped some values.\r\n                    checkResolutionSteps(dataObject.timeValuePairs, taskDef.resolution);\r\n                    _.each(dataObject.timeValuePairs, function(timeValuePair) {\r\n                        // This object is inserted into the cache as the actual data cache block.\r\n                        // Notice, cache block have references to the same objects which means some redundancy.\r\n                        // But, this way required data is always available when data is requested from the cache.\r\n                        var cacheBlock = {\r\n                            info : data.info,\r\n                            properties : data.properties,\r\n                            locationInfo : location.info,\r\n                            blockProperty : dataObject.property,\r\n                            timeValuePair : timeValuePair\r\n                        };\r\n                        converted.data[locationName][keyRequestParameter].push(cacheBlock);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        return converted;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Convert sites data received from the cache to the structure that is provided through API.\r\n     *\r\n     * This data has been set in {convertSitesDataFromParserForCache} function for the cache.\r\n     *\r\n     * @param {Object} taskDef Definition object to describe cache blocks of the operation.\r\n     *                         May be {undefined} or {null}.\r\n     * @param {Object} data Parsed data from cache. May be {undefined} or {null}.\r\n     * @param {Array} errors Errors that have occurred during loading, parsing and caching data.\r\n     *                       May be {undefined} or {null}.\r\n     * @return {Object} Object that contains converted errors and converted data.\r\n     */\r\n    function convertSitesDataFromCacheForApi(taskDef, data, errors) {\r\n        var converted = {\r\n            // Data is converted below into the data object if data is available.\r\n            data : data ? {\r\n                info : undefined,\r\n                properties : undefined,\r\n                locations : []\r\n            } : undefined,\r\n            errors : convertCacheErrorsForApi(errors)\r\n        };\r\n        if (data) {\r\n            // Data provided before from parser and set by convertSitesDataFromParserForCache\r\n            // function for the cache is in data.data object. Notice, data is provided as\r\n            // data object hierarchy. Time values that cache has set itself are given as array.\r\n            // Notice, data.data object structure also contains the parsed time values from server.\r\n            // Here, data object contains locations that are identified by the location name key.\r\n            _.each(data.data, function(location) {\r\n                var convertedLocation = {\r\n                    info : undefined,\r\n                    data : {}\r\n                };\r\n                // Location object contains objects that are identified by the request parameters.\r\n                _.each(location, function(container, requestParameterKey) {\r\n                    // Container object for the converted cache block data.\r\n                    var convertedData = {\r\n                        property : undefined,\r\n                        timeValuePairs : []\r\n                    };\r\n\r\n                    // Each container identified by request parameter key contains cache data blocks in an array.\r\n                    _.each(container, function(cacheBlock) {\r\n                        // cacheBlock may be undefined if cache has reserved\r\n                        // more timesteps for certain time range than parser has gotten\r\n                        // for server request. Ignore undefined objects. Notice, that the\r\n                        // correct times from server are still available in timeValuePair\r\n                        // objects. Also, it is better to provide the parsed server data\r\n                        // through API instead of extra undefined objects.\r\n                        if (cacheBlock) {\r\n                            if (!converted.data.info) {\r\n                                // All locations have the same info object.\r\n                                // Therefore, set content if data has not been set before.\r\n                                converted.data.info = cacheBlock.info;\r\n                            }\r\n\r\n                            if (!converted.data.properties) {\r\n                                // All locations have the same properties object.\r\n                                // Therefore, set content if data has not been set before.\r\n                                converted.data.properties = cacheBlock.properties;\r\n                            }\r\n\r\n                            if (!convertedData.property) {\r\n                                // All the blocks of same location refere to the same property info.\r\n                                // Therefore, set the information to the converted data object\r\n                                // if data has not been set before.\r\n                                convertedData.property = cacheBlock.blockProperty;\r\n                            }\r\n\r\n                            if (!convertedLocation.info) {\r\n                                // All the block of same location refere to the same location info.\r\n                                // Therefore, set the information to the converted location object\r\n                                // if data has not been set before.\r\n                                convertedLocation.info = cacheBlock.locationInfo;\r\n                            }\r\n\r\n                            // Insert datablock time-value-pair into the datablock time-value-pair array.\r\n                            convertedData.timeValuePairs.push(cacheBlock.timeValuePair);\r\n                        }\r\n                    });\r\n                    // Insert converted datablock into the location.\r\n                    convertedLocation.data[requestParameterKey] = convertedData;\r\n                });\r\n                // Insert converted location data into converted data locations array.\r\n                converted.data.locations.push(convertedLocation);\r\n            });\r\n        }\r\n        return converted;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * This callback is set for sites cache data fetcher.\r\n     *\r\n     * Parser will provide the fetched and parsed data for this callback.\r\n     * This callback will forward the data in a correct format for the cache.\r\n     *\r\n     * @param {Object} container Object that provides connection instance specific private member variables.\r\n     *                           May not be {undefined} or {null}.\r\n     * @param {Object} taskDef Definition object to describe cache blocks of the operation.\r\n     *                         May not be {undefined} or {null}.\r\n     * @param {function(errors, data)} taskCallback Called with the parsed data and errors array when operation finishes.\r\n     *                                              May not be {undefined} or {null}.\r\n     */\r\n    function cacheSitesDataFetcherCallback(container, taskDef, taskCallback) {\r\n        container.parser.getData({\r\n            url : getUrlString(container.connectionUrl),\r\n            storedQueryId : container.storedQueryId,\r\n            requestParameter : taskDef.parameter,\r\n            begin : taskDef.start,\r\n            end : taskDef.end,\r\n            timestep : taskDef.resolution,\r\n            // If time adjusting is requested, it has been done before giving times to cache.\r\n            // Therefore, do not let parser do adjusting.\r\n            denyTimeAdjusting : true,\r\n            // Notice, instead of using taskDef.location for properties here,\r\n            // specific location related properties are used.\r\n            geoid : taskDef.geoid,\r\n            wmo : taskDef.wmo,\r\n            fmisid : taskDef.fmisid,\r\n            sites : taskDef.sites,\r\n            crs : taskDef.crs,\r\n            queryExtension : taskDef.queryExtension,\r\n            callback : function(data, errors) {\r\n                // Forward callback to the cache.\r\n                // Cache will forward the callback to callbacks given through the API when the retrieve flow has been started.\r\n                var converted = convertSitesDataFromParserForCache.call(container, taskDef, data, errors);\r\n                taskCallback(converted.errors, converted.data);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Request cache to retrive sites data.\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * Notice, this flow will also continue\r\n     * to data fetcher callback if parser should be used to retrieve data\r\n     * from the server. The callback function is set for cache when it is\r\n     * initialized. Callbacks given and set in this function are called when\r\n     * the data is gotten either from the server or directly from the cache.\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var retrieveSitesData = function(options) {\r\n\r\n        var that = this;\r\n\r\n        if (!options.timestep || options.timestep === 1) {\r\n            // Cache requires that timestep is the actual timestep that is used for data.\r\n            // But, in speacial cases server may use magic numbers to handle data differently.\r\n            // Cache can not be used with the given options. Therefore, use parser directly.\r\n\r\n            that.parser.getData({\r\n                url : getUrlString(that.connectionUrl),\r\n                storedQueryId : that.storedQueryId,\r\n                requestParameter : options.requestParameter,\r\n                begin : options.begin,\r\n                end : options.end,\r\n                timestep : options.timestep,\r\n                // When parser is used directly, it can handle time adjusting automatically if requested.\r\n                denyTimeAdjusting : options.denyTimeAdjusting,\r\n                geoid : trimProperty(options.geoid),\r\n                wmo : trimProperty(options.wmo),\r\n                fmisid : trimProperty(options.fmisid),\r\n                sites : trimSites(options.sites),\r\n                crs : options.crs,\r\n                queryExtension : options.queryExtension,\r\n                callback : options.callback\r\n            });\r\n\r\n        } else {\r\n            // Use cache for sites data.\r\n            // If time adjusting is requested, it is done before values are given for the cache.\r\n            var beginDate = options.begin;\r\n            var endDate = options.end;\r\n            var resolution = options.timestep;\r\n            if (!options.denyTimeAdjusting) {\r\n                beginDate = that.parser.adjustBeginTime(resolution, beginDate);\r\n                endDate = that.parser.adjustEndTime(resolution, endDate, beginDate);\r\n            }\r\n            var taskDef = {\r\n                service : DATA_FETCHER_NAME_SITES,\r\n                parameter : _.isString(options.requestParameter) ? options.requestParameter.split(PARAMETER_SEPARATOR) : options.requestParameter,\r\n                // Make sure parameter(s) are integers instead of Date objects when they are given to cache.\r\n                start : beginDate instanceof Date ? beginDate.getTime() : beginDate,\r\n                end : endDate instanceof Date ? endDate.getTime() : endDate,\r\n                resolution : resolution,\r\n                crs : options.crs,\r\n                queryExtension : options.queryExtension\r\n            };\r\n            // Because locations can be given in multiple ways, location related properties are\r\n            // set separately for taskDef to combine all location informations for cache.\r\n            setTaskDefLocations(taskDef, options);\r\n            this.cache.fetch(taskDef, function(errors, result) {\r\n                var converted = convertSitesDataFromCacheForApi(taskDef, result, errors);\r\n                options.callback(converted.data, converted.errors);\r\n            }, options.progressCallback);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Request parser directly to retrive spatial data.\r\n     *\r\n     * Notice, cache is not used for spatial data.\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * Notice, this flow will also continue\r\n     * to data fetcher callback if parser should be used to retrieve data\r\n     * from the server. The callback function is set for cache when it is\r\n     * initialized. Callbacks given and set in this function are called when\r\n     * the data is gotten either from the server or directly from the cache.\r\n     *\r\n     */\r\n    var retrieveSpatialData = function(options) {\r\n        var that = this;\r\n        that.parser.getData({\r\n            url : getUrlString(that.connectionUrl),\r\n            storedQueryId : that.storedQueryId,\r\n            requestParameter : options.requestParameter,\r\n            begin : options.begin,\r\n            end : options.end,\r\n            timestep : options.timestep,\r\n            // When parser is used directly, it can handle time adjusting automatically if requested.\r\n            denyTimeAdjusting : options.denyTimeAdjusting,\r\n            // Include also other sites related options if they are given.\r\n            // But, bbox is the reason that all data is provided directly for the parser.\r\n            geoid : trimProperty(options.geoid),\r\n            wmo : trimProperty(options.wmo),\r\n            fmisid : trimProperty(options.fmisid),\r\n            sites : trimSites(options.sites),\r\n            bbox : options.bbox,\r\n            crs : options.crs,\r\n            latlon : options.latlon,\r\n            queryExtension : options.queryExtension,\r\n            callback : options.callback\r\n        });\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Wraps the function calls inside try-catch before calling.\r\n     *\r\n     * Instead of using multiple try catches in many functions only one is used here.\r\n     * This style may improve performance.\r\n     *\r\n     * Notice, this function applies this-reference to the function calls.\r\n     *\r\n     * @param {function} func Function that should be called.\r\n     *                        May not be {undefined} or {null}.\r\n     * @param {function} callback Callback function that is called if an exception occurs\r\n     *                            during this synchronous part of the flow. Notice, this\r\n     *                            is a callback that may be provided for asynchronous flow.\r\n     *                            May be {undefined} or {null}.\r\n     * @return {boolean} {true} if operation starts successfully. Else {false}.\r\n     *                          Notice, if {callback} is given, it is also called\r\n     *                          if false is returned for success.\r\n     */\r\n    var makeSafe = function(func, callback) {\r\n        var success = true;\r\n        try {\r\n            // Call the correct function with the original arguments.\r\n            // Function reference itself is removed from the arguments.\r\n            // Also, callback reference provided for synchronous exception\r\n            // handling is removed from the arguments.\r\n            var args = Array.prototype.slice.call(arguments);\r\n            args.shift();\r\n            args.shift();\r\n            func.apply(this, args);\r\n\r\n        } catch(e) {\r\n            var errorStr = \"ERROR: API level error occurred in a synchronous flow!\";\r\n            if (\"undefined\" !== typeof console && console) {\r\n                console.error(errorStr);console.error(e);\r\n            }\r\n            success = false;\r\n            if (callback) {\r\n                // Inform callback about exception in the flow.\r\n                // Then, caller knows that asynchronous flow has ended.\r\n                var error = {\r\n                    errorText : errorStr\r\n                };\r\n                callback(undefined, error);\r\n            }\r\n        }\r\n        return success;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Get a URL string. If an array of URLs has been set to make use of domain sharding, a random array member is returned.\r\n     *\r\n     */\r\n    var getUrlString = function(urlOption) {\r\n        if(_.isArray(urlOption)){\r\n          return urlOption[ Math.floor( Math.random() * urlOption.length ) ];\r\n        }else{\r\n          return urlOption;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var getUrl = function() {\r\n        return this.connectionUrl;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var getStoredQueryId = function() {\r\n        return this.storedQueryId;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var connect = function(url, storedQueryId) {\r\n        // Skip if already connected.\r\n        // Notice, if already connected, this function does not reconnect\r\n        // even if a new URL would be different than the old one.\r\n        if (!this.connectionUrl) {\r\n            if ((!_.isString(url) && !_.isArray(url)) || !url.length || !url) {\r\n                var urlErrorStr = \"ERROR: WfsConnection URL must be a string or an array and not empty!\";\r\n                if (\"undefined\" !== typeof console && console) {\r\n                    console.error(urlErrorStr);\r\n                }\r\n                throw urlErrorStr;\r\n            }\r\n            if (!_.isString(storedQueryId) || !storedQueryId) {\r\n                var idErrorStr = \"ERROR: WfsConnection stored query ID must be a string and not empty!\";\r\n                if (\"undefined\" !== typeof console && console) {\r\n                    console.error(idErrorStr);\r\n                }\r\n                throw idErrorStr;\r\n            }\r\n            this.connectionUrl = url;\r\n            this.storedQueryId = storedQueryId;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var disconnect = function() {\r\n        this.connectionUrl = undefined;\r\n        this.storedQueryId = undefined;\r\n        resetCache.call(this);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var resetCache = function() {\r\n        this.cache.clearCache();\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var getData = function(options) {\r\n        if (options) {\r\n            if (options.bbox || options.latlon) {\r\n                // BBox nor LatLon are not supported by the cache at the moment.\r\n                // Therefore, pass the whole query to the parser.\r\n                retrieveSpatialData.call(this, options);\r\n\r\n            } else if (options.geoid || options.wmo || options.fmisid || options.sites) {\r\n                retrieveSitesData.call(this, options);\r\n\r\n            } else {\r\n                var errorStr = \"ERROR: Either geoid, wmo, fmisid, sites, bbox or latlon is mandatory in options!\";\r\n                if (\"undefined\" !== typeof console && console) {\r\n                    console.error(errorStr);\r\n                }\r\n                throw errorStr;\r\n            }\r\n\r\n        } else {\r\n            var optionsErrorStr = \"ERROR: Options object is mandatory!\";\r\n            if (\"undefined\" !== typeof console && console) {\r\n                console.error(optionsErrorStr);\r\n            }\r\n            throw optionsErrorStr;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Constructor for the connection instance.\r\n     *\r\n     * Notice, this constructor is returned from {WfsConnection}\r\n     * and can be used for instantiation later.\r\n     */\r\n     var connectionConstructor = function(splitterCacheConfig) {\r\n\r\n        // Reference to the connection instance object.\r\n        var that = this;\r\n\r\n        // {SplitterCache} configuration\r\n        splitterCacheConfig = splitterCacheConfig || {\r\n            sideFetchAfterFactor : 1,\r\n            sideFetchBeforeFactor : 0.5,\r\n            maxBlockDataPoints : 200,\r\n            maxCacheDataSize : 4000\r\n        };\r\n\r\n        // Private object is used for API functions to provide them private member variables.\r\n        // Instance specific data is available for API functions when reference to this private\r\n        // object is applied to the function calls by using this private object. Then, these\r\n        // variables and functions are capsulated and are not available outside of the connection\r\n        // instance.\r\n        this._private = {\r\n            // Reference to the connection instance object.\r\n            connectionInstance : that,\r\n\r\n            // Member variables that are initialized to undefined.\r\n            // When connection function is called these are set.\r\n            connectionUrl : undefined,\r\n            storedQueryId : undefined,\r\n\r\n            // Member variables that are initialized to values that are used\r\n            // throughout the lifetime of object instance.\r\n\r\n            // Cache for retrieved data.\r\n            cache : new SplitterCache(splitterCacheConfig),\r\n\r\n            parser : new WfsRequestParser()\r\n        };\r\n\r\n        //=================================================================\r\n        // Public WfsConnection API is defined here as priviledged functions.\r\n        //=================================================================\r\n\r\n        /**\r\n         * Synchronous.\r\n         *\r\n         * @return {String} URL that is used for the connection and\r\n         *                  has been set when {connect} function is called.\r\n         *                  May be {undefined} if state is not connected.\r\n         */\r\n        this.getUrl = function() {\r\n            return getUrl.call(this._private);\r\n        };\r\n\r\n        /**\r\n         * Synchronous.\r\n         *\r\n         * @return {String} Stored query ID that is used for the connection\r\n         *                  and has been set when {connect} function is called.\r\n         *                  May be {undefined} if state is not connected.\r\n         */\r\n        this.getStoredQueryId = function() {\r\n            return getStoredQueryId.call(this._private);\r\n        };\r\n\r\n        /**\r\n         * Synchronous.\r\n         *\r\n         * Notice, if already connected, this function does not reconnect\r\n         * even if a new URL would be different than the old one.\r\n         *\r\n         * @param {String} url URL that is used for the connection.\r\n         *                     May not be {undefined}, {null} or empty.\r\n         * @param {String} storedQueryId Stored query ID to identify the data that is requested.\r\n         *                               For example, stored query ID may be used to request\r\n         *                               observed data or forecast data.\r\n         *                               May not be {undefined}, {null} or empty.\r\n         * @return {boolean} {true} if synchronous operation was successfull. Else {false}.\r\n         */\r\n        this.connect = function(url, storedQueryId) {\r\n\r\n            var that = this;\r\n            // Set data fetcher that cache uses for the given type of the data.\r\n            this._private.cache.addDataProvider(DATA_FETCHER_NAME_SITES, function(taskDef, callback) {\r\n                cacheSitesDataFetcherCallback(that._private, taskDef, callback);\r\n            });\r\n\r\n            return makeSafe.call(that._private, connect, undefined, url, storedQueryId);\r\n        };\r\n\r\n        /**\r\n         * Synchronous.\r\n         *\r\n         * Releases resources.\r\n         *\r\n         * @return {boolean} {true} if synchronous operation was successfull. Else {false}.\r\n         */\r\n        this.disconnect = function() {\r\n            return makeSafe.call(this._private, disconnect, undefined);\r\n        };\r\n\r\n        /**\r\n         * Synchronous.\r\n         *\r\n         * Releases cache resources.\r\n         *\r\n         * @return {boolean} {true} if synchronous operation was successfull. Else {false}.\r\n         */\r\n        this.resetCache = function() {\r\n            return makeSafe.call(this._private, resetCache, undefined);\r\n        };\r\n\r\n        /**\r\n         * Request data.\r\n         *\r\n         * Operation is asynchronous.\r\n         *\r\n         * Notice, callback is {function(data, errors){}}.\r\n         *      - data: Data object provides locations data.\r\n         *              May be {undefined} if an error has occurred.\r\n         *              The object is of this structure:\r\n         *          {\r\n         *              // General information received in the server response for the request.\r\n         *              // May not be {undefined} or {null}.\r\n         *              // Content properties are set if given in the server response.\r\n         *              info : {\r\n         *                  begin : {Date|undefined},\r\n         *                  end : {Date|undefined}\r\n         *              },\r\n         *              // Properties provide descriptive property objects that correspond to\r\n         *              // the parameter keys that have been given for the request. Notice,\r\n         *              // property data is also available inside locations data objects.\r\n         *              // This object is provided as a complementary object, if reference to a single\r\n         *              // wrapper object is later needed for general information about properties.\r\n         *              properties : {\r\n         *                  parameterAsKey : { label : \"labelString\",\r\n         *                                     unit : \"measurementUnitString\",\r\n         *                                     phenomenon : \"phenomenonString\",\r\n         *                                     statisticalFunction : \"statisticalFunctionString\",\r\n         *                                     statisticalPeriod : \"statisticalAggregationTimePeriod\" },\r\n         *                  ...\r\n         *              },\r\n         *              // Data of locations. May be empty if sites data is not provided.\r\n         *              // May not be {undefined} or {null}.\r\n         *              locations : [\r\n         *                  {\r\n         *                      info : {\r\n         *                          id : \"location id string\",\r\n         *                          geoid : \"geoid string\",\r\n         *                          wmo : \"wmo string\",\r\n         *                          fmisid : \"fmisid string\",\r\n         *                          name : \"location name string\",\r\n         *                          region : \"region name string\",\r\n         *                          country : \"country name string\",\r\n         *                          timezone : \"timezone name string\",\r\n         *                          position : [ \"positionStringPart1\", \"positionStringPart2\", ... ]\r\n         *                      },\r\n         *                      data : {\r\n         *                          // Data property keys correspond to the parameter keys\r\n         *                          // that have been given for the request.\r\n         *                          parameterAsKey : {\r\n         *                            property : { label : \"labelString\",\r\n         *                                         unit : \"measurementUnitString\",\r\n         *                                         phenomenon : \"phenomenonString\",\r\n         *                                         statisticalFunction : \"statisticalFunctionString\",\r\n         *                                         statisticalPeriod : \"statisticalAggregationTimePeriod\" },\r\n         *                            timeValuePairs : [ { time : intTimeInMsSince01011970,\r\n         *                                                 value : floatMeasurementValue }, ... ]\r\n         *                          },\r\n         *                          ...\r\n         *                      }\r\n         *                  },\r\n         *                  ...\r\n         *              ]\r\n         *          }\r\n         *      - errors: Array that contains possible errors that occurred during the flow. Array is\r\n         *                always provided even if it may be empty. If an error occurs in this parser,\r\n         *                an error string is pushed here. Also, when an HTTP error occurs, error contains\r\n         *                the textual portion of the HTTP status, such as \"Not Found\" or \"Internal Server Error.\"\r\n         *                Errors parameter is of this structure:\r\n         *          [\r\n         *              {\r\n         *                  // None, one, or more of the following error values may exist.\r\n         *                  // Values may also be {undefined} or {null}.\r\n         *                  errorCode : \"errorCodeString\",\r\n         *                  errorText : \"errorTextString\",\r\n         *                  extension : {Object}\r\n         *              },\r\n         *              ...\r\n         *          ]\r\n         *\r\n         * Notice, object properties of the function {options} parameter are URL encoded by this library\r\n         * before they are inserted into the request URL.\r\n         *\r\n         * @param {Object} options Mandatory. May not be {undefined} or {null}. Object structure:\r\n         *     {\r\n         *         requestParameter : {String|Array(String)}\r\n         *                            Mandatory property. May not be {undefined} or {null}. Array may not be empty.\r\n         *                            This is one of the parameter strings that is part of\r\n         *                            URL parameters to define which data is requested from the server.\r\n         *                            Parameter string may contain request for multiple parameters.\r\n         *                            For example, value for dew point temperature may be \"td\".\r\n         *                            If an array is given, strings are given as separate array string items.\r\n         *         begin : {int|Date}\r\n         *                 Mandatory property. May not be {undefined} or {null}.\r\n         *                 The begin time for the data.\r\n         *                 Integer value is number of milliseconds since 01.01.1970 that can be gotten,\r\n         *                 for example, with {Date::getTime()}. Alternatively, {Date} object may be given.\r\n         *         end : {int|Date}\r\n         *               Mandatory property. May not be {undefined} or {null}.\r\n         *               The end time for the data.\r\n         *               Value is number of milliseconds since 01.01.1970 that can be gotten,\r\n         *               for example, with {Date::getTime()}. Alternatively, {Date} object may be given.\r\n         *         timestep : {int}\r\n         *                    May be {undefined} or {null}.\r\n         *                    Timestep in milliseconds.\r\n         *                    If {undefined}, {null} or zero, server returns all data for\r\n         *                    the given time interval. If timestep is 1, server uses the default\r\n         *                    timestep. Notice, even if time is in milliseconds here, it is converted\r\n         *                    and floored to minutes before sending for the server.\r\n         *         denyTimeAdjusting : {boolean}\r\n         *                             May be {undefined} or {null}.\r\n         *                             If {true}, {begin} and {end} times are not adjusted for server but given values\r\n         *                             are used exactly for requests. Otherwise, times are adjusted.\r\n         *         geoid : {Array(String|int)|String|int}\r\n         *                 May be {undefined} or {null} or empty if {wmo}, {fmisid}, {sites} or {bbox} is given.\r\n         *                 Array of Geographical name ID (geonames.org) strings or integers.\r\n         *                 One geoid can be given as a single string or integer.\r\n         *                 Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n         *         wmo : {Array(String|int)|String|int}\r\n         *               May be {undefined} or {null} or empty if {geoid}, {fmisid}, {sites} or {bbox} is given.\r\n         *               Array of World Meteorological Organization (WMO) identifier strings or integers.\r\n         *               One wmo can be given as a single string or integer.\r\n         *               Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n         *         fmisid : {Array(String|int)|String|int}\r\n         *                  May be {undefined} or {null} or empty if {geoid}, {wmo}, {sites} or {bbox} is given.\r\n         *                  Array of FMI observation station identifiers (fmisid) strings or integers.\r\n         *                  One fmisid can be given as a single string or integer.\r\n         *                  Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n         *         sites : {Array(String)|String}\r\n         *                 May be {undefined} or {null} or empty if {geoid}, {wmo}, {fmisid} or {bbox} is given.\r\n         *                 Array of site name strings. One site can be given as a single string.\r\n         *                 Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n         *         bbox : {String}\r\n         *                May be {undefined}, {null} or empty if {geoid}, {wmo}, {fmisid} or {sites} is given.\r\n         *                BBOX string. Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n         *                Notice, cache is not used if spatial data (bbox) is queried.\r\n         *         crs : {String}\r\n         *               May be {undefined}, {null} or empty.\r\n         *               Coordinate Reference System (CRS) string.\r\n         *         queryExtension : {Object}\r\n         *                          Optional. May be {undefined} or {null}.\r\n         *                          Property values may be {undefined}, {null} or {string}.\r\n         *                          This property is not needed in normal use cases of the API.\r\n         *                          But, this property may be used if API does not support field-value-pairs\r\n         *                          that need to be included into request URL query. The key-value-pairs of\r\n         *                          the property are URL encoded and included as URL query field-value-pairs\r\n         *                          in the request. If property value is {undefined} or {null}, it is interpreted\r\n         *                          as an empty string. Notice, other API properties should be used instead of this\r\n         *                          extension if possible.\r\n         *         callback : {function(data, errors)}\r\n         *                    Mandatory property. May not be {undefined} or {null}.\r\n         *                    Callback is called with the parsed data and errors array when operation finishes.\r\n         *                    If an error occurs, data is set {undefined} for the callback. Possible errors are\r\n         *                    given inside the array that is always provided.\r\n         *         progressCallback : {function(err, partStart, partEnd)}\r\n         *                            Not mandatory property.\r\n         *                            Called when part of the flow has finished.\r\n         *                            Function is called with {err}, {partStart} and {partEnd} parameters.\r\n         *     }\r\n         * @return {boolean} {true} if asynchronous operation is successfully started. Else {false}.\r\n         */\r\n        this.getData = function(options) {\r\n            return makeSafe.call(this._private, getData, options ? options.callback : undefined, options);\r\n        };\r\n    };\r\n\r\n    // Constructor function is returned for later instantiation.\r\n    return connectionConstructor;\r\n\r\n})();\r\n\r\nmodule.exports = WfsConnection;\r\n"]},"metadata":{},"sourceType":"script"}