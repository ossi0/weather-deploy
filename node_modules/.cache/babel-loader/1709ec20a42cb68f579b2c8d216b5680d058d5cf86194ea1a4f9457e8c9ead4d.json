{"ast":null,"code":"/**\r\n * This software may be freely distributed and used under the following MIT license:\r\n *\r\n * Copyright (c) 2017 Finnish Meteorological Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the\r\n * Software without restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n * Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\r\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\n\n// Strict mode for whole file.\n\"use strict\";\n\n// Requires jQuery, lodash, async\nvar jQuery = require('jquery');\nvar _ = require('lodash');\nvar async = require('async');\n// import jQuery from 'jquery';\n// import _ from 'lodash';\n// import async from 'async';\n\n// Requires SplitterCache, WfsRequestParser\nvar SplitterCache = require('./splittercache.js');\nvar WfsRequestParser = require('./wfsrequestparser.js');\n// import SplitterCache from './splittercache.js';\n// import WfsRequestParser from './wfsrequestparser.js';\n\n/**\r\n * WfsConnection object acts as an interface that provides functions\r\n * to asynchronously request XML data from the server and to get\r\n * the requested data in a parsed structure.\r\n *\r\n * WfsConnection wraps cache, request and parser functionality.\r\n * Notice, if you do not require cache functionality, you may\r\n * want to use parser, {@link WfsRequestParser},\r\n * directly without using this class as an intermediate object.\r\n *\r\n * API functions are defined in the end of the constructor,\r\n * {connectionConstructor}, as priviledged functions.\r\n * See API description there.\r\n *\r\n * Example:\r\n *      var connection = new WfsConnection();\r\n *      if (connection.connect(SERVER_URL, STORED_QUERY_OBSERVATION)) {\r\n *          // Connection was properly initialized. So, get the data.\r\n *          connection.getData({\r\n *              requestParameter : \"td,ws_10min\",\r\n *              // Integer values are used to init dates for older browsers.\r\n *              // (new Date(\"2013-05-10T08:00:00Z\")).getTime()\r\n *              // (new Date(\"2013-05-12T10:00:00Z\")).getTime()\r\n *              begin : new Date(1368172800000),\r\n *              end : new Date(1368352800000),\r\n *              timestep : 60 * 60 * 1000,\r\n *              sites : [\"Kaisaniemi,Helsinki\", \"Turku\"],\r\n *              callback : function(data, errors) {\r\n *                  // Handle the data and errors object in a way you choose.\r\n *                  handleCallback(data, errors);\r\n *                  // If the connection will not be used anymore later,\r\n *                  // the connection may be disconnected because the flow has finished.\r\n *                  connection.disconnect();\r\n *              }\r\n *          });\r\n *      }\r\n */\n\nvar WfsConnection = function () {\n  /**\r\n   * @private\r\n   *\r\n   * Data fetcher name for cache when sites are used for fetching.\r\n   */\n  var DATA_FETCHER_NAME_SITES = \"parserSites\";\n\n  /**\r\n   * @private\r\n   *\r\n   * Parameter values are separated by this string.\r\n   */\n  var PARAMETER_SEPARATOR = \",\";\n\n  /**\r\n   * @private\r\n   *\r\n   * Location name and region strings may be separated by this string\r\n   * in server responses.\r\n   */\n  var LOCATION_NAME_REGION_SEPARATOR = \" \";\n\n  /**\r\n   * @private\r\n   *\r\n   * Geoid location name prefix for cache.\r\n   */\n  var LOCATION_GEOID_PREFIX = \"g_\";\n\n  /**\r\n   * @private\r\n   *\r\n   * WMO location name prefix for cache.\r\n   */\n  var LOCATION_WMO_PREFIX = \"w_\";\n\n  /**\r\n   * @private\r\n   *\r\n   * FMISID location name prefix for cache.\r\n   */\n  var LOCATION_FMISID_PREFIX = \"f_\";\n\n  /**\r\n   * @private\r\n   *\r\n   * Sites location name prefix for cache.\r\n   */\n  var LOCATION_SITES_PREFIX = \"s_\";\n\n  /**\r\n   * @private\r\n   *\r\n   * General text that describes an error that has been found in cache.\r\n   */\n  var CACHE_ERROR_TEXT = \"ERROR: Cache found error(s)!\";\n\n  /**\r\n   * @private\r\n   *\r\n   * Trim single site string for cache flow.\r\n   *\r\n   * @param {String} May not be {undefined} or {null}.\r\n   */\n  function trimSingleSite(site) {\n    return jQuery.trim(site).replace(/,\\s+/, PARAMETER_SEPARATOR);\n  }\n\n  /**\r\n   * @private\r\n   *\r\n   * Trim unnecessary white spaces from sites string(s).\r\n   *\r\n   * Notice, new content is returned. Then, original values are not changed if an array is given.\r\n   *\r\n   * @param {Array(String)|String} Site strings in an array or one site may be given as a single string.\r\n   *                               May be {udefined} or {null} but then operation is ignored.\r\n   * @param {String} prefix Prefix string that is used with the value(s).\r\n   *                        This is meant for cache but should not be used for parser.\r\n   *                        May be {udefined} or {null}. Then, empty string is used.\r\n   * @return {Array(String)} Trimmed site(s) in an array. May not be {undefined} or {null}.\r\n   */\n  function trimSites(sites, prefix) {\n    var trimmed = [];\n    if (!_.isString(prefix)) {\n      // Make sure prefix is at least an empty string.\n      prefix = \"\";\n    }\n    // Handle sites as string(s).\n    if (sites && _.isString(sites)) {\n      // Trim possible white spaces.\n      // Location and its region may be separated by using comma but there should not be whitespaces after comma.\n      // Then, later it is easier to compare server responses with given sites when data is handled for cache.\n      trimmed.push(prefix + trimSingleSite(sites));\n    } else if (_.isArray(sites)) {\n      for (var i = 0; i < sites.length; ++i) {\n        var site = sites[i];\n        if (site && _.isString(site)) {\n          trimmed.push(prefix + trimSingleSite(site));\n        }\n      }\n    }\n    return trimmed;\n  }\n\n  /**\r\n   * @private\r\n   *\r\n   * Trim unnecessary white spaces from string(s).\r\n   *\r\n   * Notice, new content is returned. Then, original values are not changed if an array is given.\r\n   *\r\n   * @param {Array(String|int)|String|int} property Strings or integers in an array\r\n   *                                                or one item as a single string or integer.\r\n   *                                                May be {udefined} or {null}.\r\n   * @param {String} prefix Prefix string that is used with the value(s).\r\n   *                        This is meant for cache but should not be used for parser.\r\n   *                        May be {udefined} or {null}. Then, empty string is used.\r\n   * @return {Array(String)} Trimmed value(s) in an array. May not be {undefined} or {null}.\r\n   */\n  function trimProperty(property, prefix) {\n    var trimmed = [];\n    if (!_.isString(prefix)) {\n      // Make sure prefix is at least an empty string.\n      prefix = \"\";\n    }\n    if (_.isNumber(property) || property && _.isString(property)) {\n      trimmed.push(jQuery.trim(prefix + property));\n    } else if (_.isArray(property)) {\n      for (var i = 0; i < property.length; ++i) {\n        var tmp = property[i];\n        // Handle property as string.\n        if (_.isNumber(tmp) || tmp && _.isString(tmp)) {\n          trimmed.push(jQuery.trim(prefix + tmp));\n        }\n      }\n    }\n    return trimmed;\n  }\n\n  /**\r\n   * @private\r\n   *\r\n   * Cache {taskDef} location should contain all the locations (not just sites names).\r\n   * This function combines all the location information into one array that is\r\n   * set as {location} -property for the cache {taskDef}. Also, other properties that\r\n   * are used for {taskDef} location property are set.\r\n   *\r\n   * @param {Object} taskDef Target for location settings.\r\n   *                         Operation is ignored if {undefined} or {null}.\r\n   * @param {Object} options Options object given through the API.\r\n   *                         Provides location data for {taskDef}.\r\n   *                         Operation is ignored if {undefined} or {null}.\r\n   */\n  function setTaskDefLocations(taskDef, options) {\n    if (taskDef && options) {\n      var location = [];\n      taskDef.location = location;\n      // Notice, these properties are used to provide additional information\n      // that can be given for the parser. The cache uses location property\n      // to create the cache hierarchy.\n      taskDef.geoid = trimProperty(options.geoid);\n      taskDef.wmo = trimProperty(options.wmo);\n      taskDef.fmisid = trimProperty(options.fmisid);\n      taskDef.sites = trimSites(options.sites);\n      // Combine locations information for taskDef location.\n      // Notice, prefix is used for cache. Then, it is sure that different location\n      // requests do not have same string for key (really rare case).\n      location.push.apply(location, trimProperty(options.geoid, LOCATION_GEOID_PREFIX));\n      location.push.apply(location, trimProperty(options.wmo, LOCATION_WMO_PREFIX));\n      location.push.apply(location, trimProperty(options.fmisid, LOCATION_FMISID_PREFIX));\n      location.push.apply(location, trimSites(options.sites, LOCATION_SITES_PREFIX));\n    }\n  }\n\n  /**\r\n   * @private\r\n   *\r\n   * Check that time-value-pair objects are not missing from the given array.\r\n   * If an object is missing, time-value-pair of the correct time and NaN value\r\n   * is inserted into the array according to the resolution step.\r\n   *\r\n   * @param {[]} array Array that contains time-value-pair objects.\r\n   *                   Operation is ignored if {undefined} or {null}.\r\n   * @param {Integer} resolution Time in milliseconds to describe timesteps between values.\r\n   *                             Operation is ignored if {undefined}, {null}, zero or negative.\r\n   */\n  function checkResolutionSteps(array, resolution) {\n    if (_.isArray(array) && resolution && resolution > 0) {\n      for (var i = 1; i < array.length; ++i) {\n        var previousTimeValuePair = array[i - 1];\n        var timeValuePair = array[i];\n        if (_.isObject(timeValuePair)) {\n          var previousTime = _.isObject(previousTimeValuePair) ? previousTimeValuePair.time : undefined;\n          var time = timeValuePair.time;\n          if (undefined !== previousTime && null !== previousTime && undefined !== time && null !== time && resolution < time - previousTime) {\n            // Time-value-pair object is missing between two array objects.\n            // Insert a new NaN value pair into array.\n            // Notice, time of this new object is compared in next round to the\n            // same object that is checked already in this round.\n            // Then, missing resolution objects are added properly into too large gaps.\n            time = previousTime + resolution;\n            array.splice(i, 0, {\n              time: time,\n              value: NaN\n            });\n          }\n          previousTime = time;\n        }\n      }\n    }\n  }\n\n  /**\r\n   * @private\r\n   *\r\n   * Check if given {list} contains an equal to the given {item}.\r\n   *\r\n   * Performs an optimized deep comparison between the objects of the {list} and given {item},\r\n   * to determine if they should be considered equal.\r\n   *\r\n   * @param {Array} list List whose items are compared to {item}. May be {undefined} or {null}.\r\n   * @param {Object} item Item that is compared to the list items. May be {undefined} or {null}.\r\n   * @return {Boolean} {true} if {item} equals at least one item in {list}.\r\n   */\n  function contains(list, item) {\n    return _.find(list, function (currentItem) {\n      return _.isEqual(currentItem, item);\n    });\n  }\n\n  /**\r\n   * @private\r\n   *\r\n   * Converts errors given by cache to the error objects given through API.\r\n   * Possible duplicates are not included into the returned array.\r\n   *\r\n   * @param {Array} errors Errors array from the cache that is converted to API errors array.\r\n   *                       May be {undefined} or {null}.\r\n   * @return {Array} Converted errors in an array. May not be {undefined} or {null}.\r\n   */\n  function convertCacheErrorsForApi(errors) {\n    var apiErrors = [];\n    if (_.isArray(errors)) {\n      for (var i = 0; i < errors.length; ++i) {\n        var error = errors[i];\n        // Flag to inform if error item should just be wrapped as a general cache error\n        // or if error content has been handled separately. Always include wrapped error\n        // into array if cache error root level already contains errorCode or errorText information.\n        var useWrapError = _.isObject(error) && (error.errorCode || error.errorText);\n        // Cache error structure may wrap errors gotten from parser.\n        // Check if parser has provided errors. Then, that error information can be included\n        // in the root level of the API error.\n        if (_.isObject(error) && _.isArray(error.error) && error.error.length > 0) {\n          var errorArray = error.error;\n          for (var j = 0; j < errorArray.length; ++j) {\n            // Error array may contain the actual parse error.\n            // Check if the error code and text are available for API error object.\n            // If multiple error items are in the array. Handle them all as a separate error.\n            var errorItem = errorArray[j];\n            if (_.isObject(errorItem) && (errorItem.errorCode || errorItem.errorText)) {\n              var newError = {\n                errorCode: errorItem.errorCode,\n                errorText: errorItem.errorText,\n                // Reference to the original error structure.\n                // Then, additional information is available also through API if needed.\n                extension: error\n              };\n              // Perform an optimized deep comparison between already included errors and new error,\n              // to determine if the new error should be included or if it is a duplicate.\n              if (!contains(apiErrors, newError)) {\n                apiErrors.push(newError);\n              }\n            } else {\n              // Wrap the whole error as a cache error\n              // because unknown structure has been given.\n              useWrapError = true;\n            }\n          }\n        } else {\n          // Wrap the whole error as a cache error\n          // because unknown structure has been given.\n          useWrapError = true;\n        }\n        // Check if the original error should be wrapped as an extension for API error object.\n        if (useWrapError) {\n          // Create api error from the cache error.\n          var newWrapError = {\n            errorCode: _.isObject(error) ? error.errorCode : undefined,\n            errorText: _.isObject(error) && _.isString(error.errorText) ? error.errorText : CACHE_ERROR_TEXT,\n            extension: error\n          };\n          // Perform an optimized deep comparison between already included errors and new error,\n          // to determine if the new error should be included or if it is a duplicate.\n          if (!contains(apiErrors, newWrapError)) {\n            apiErrors.push(newWrapError);\n          }\n        }\n      }\n    }\n    return apiErrors;\n  }\n\n  /**\r\n   * @private\r\n   *\r\n   * Convert sites data received from the parser to the structure that cache can handle.\r\n   *\r\n   * Notice, this function is called only if parser was used for the server requests.\r\n   * If data was already in cache, the flow does not come here.\r\n   *\r\n   * Notice, data is provided as structure of the objects.\r\n   * {@link SplitterCache#fillWith} function describes\r\n   * the object structure of the converted data. Cache data blocks are provided\r\n   * as the structure leaf objects. Notice, even if structure is created by using\r\n   * objects, it is better to include all the persisting data in the leaf cache block\r\n   * objects instead in the common parts in the middle of the structure. Then, data will\r\n   * always be available when data is requested from the cache.\r\n   *\r\n   * @param {Object} taskDef Definition object to describe cache blocks of the operation.\r\n   *                         May not be {undefined} or {null}.\r\n   * @param {Object} data Data from the parser. May be {undefined} or {null}.\r\n   * @param {Object} errors Errors that have occurred during loading and parsing data.\r\n   *                        May be {undefined} or {null}.\r\n   * @return {Object} Object that contains converted errors and converted data.\r\n   *                  {@link SplitterCache#fillWith} function describes\r\n   *                  the object structure of the converted data. May not be {undefined} or {null}.\r\n   */\n  function convertSitesDataFromParserForCache(taskDef, data, errors) {\n    var converted = {\n      // Data is converted below into the data object if data is available.\n      data: data ? {} : undefined,\n      // Cache handles errors according to node.js error convention.\n      // Therefore, instead of passing empty array for cache,\n      // error object should be set null if there are no errors.\n      errors: errors && !errors.length ? null : errors\n    };\n    if (data) {\n      // Convert the given data into the correct structure that is inserted\n      // into the convert object. Convert object contains location specific objects,\n      // which in turn contain measurement parameter specific objects, which contain arrays for\n      // cache data block objects. See SplitterCache#fillWith\n      // function for the corresponding structure that cache requires.\n      _.each(data.locations, function (location, key) {\n        // Location name is used as a key for the location object.\n        var locationName = taskDef.location[key];\n        if (!converted.data[locationName]) {\n          // Initialize converted data to contain location object identified by the location name.\n          converted.data[locationName] = {};\n        }\n        // Location contains data array that contains measurement data objects\n        // and measurement related information.\n        _.each(location.data, function (dataObject, keyRequestParameter) {\n          if (!converted.data[locationName][keyRequestParameter]) {\n            // Initialize converted location object to contain measurement array\n            // identified by request parameter key. Notice, cache will internally loop\n            // through the cache block array by indexing it.\n            converted.data[locationName][keyRequestParameter] = [];\n          }\n          // Loop through the actual measurement time-value-pair data objects.\n          // Also, check timesteps before giving array to cache.\n          // This may fix some indexing problems in cache if server has skipped some values.\n          checkResolutionSteps(dataObject.timeValuePairs, taskDef.resolution);\n          _.each(dataObject.timeValuePairs, function (timeValuePair) {\n            // This object is inserted into the cache as the actual data cache block.\n            // Notice, cache block have references to the same objects which means some redundancy.\n            // But, this way required data is always available when data is requested from the cache.\n            var cacheBlock = {\n              info: data.info,\n              properties: data.properties,\n              locationInfo: location.info,\n              blockProperty: dataObject.property,\n              timeValuePair: timeValuePair\n            };\n            converted.data[locationName][keyRequestParameter].push(cacheBlock);\n          });\n        });\n      });\n    }\n    return converted;\n  }\n\n  /**\r\n   * @private\r\n   *\r\n   * Convert sites data received from the cache to the structure that is provided through API.\r\n   *\r\n   * This data has been set in {convertSitesDataFromParserForCache} function for the cache.\r\n   *\r\n   * @param {Object} taskDef Definition object to describe cache blocks of the operation.\r\n   *                         May be {undefined} or {null}.\r\n   * @param {Object} data Parsed data from cache. May be {undefined} or {null}.\r\n   * @param {Array} errors Errors that have occurred during loading, parsing and caching data.\r\n   *                       May be {undefined} or {null}.\r\n   * @return {Object} Object that contains converted errors and converted data.\r\n   */\n  function convertSitesDataFromCacheForApi(taskDef, data, errors) {\n    var converted = {\n      // Data is converted below into the data object if data is available.\n      data: data ? {\n        info: undefined,\n        properties: undefined,\n        locations: []\n      } : undefined,\n      errors: convertCacheErrorsForApi(errors)\n    };\n    if (data) {\n      // Data provided before from parser and set by convertSitesDataFromParserForCache\n      // function for the cache is in data.data object. Notice, data is provided as\n      // data object hierarchy. Time values that cache has set itself are given as array.\n      // Notice, data.data object structure also contains the parsed time values from server.\n      // Here, data object contains locations that are identified by the location name key.\n      _.each(data.data, function (location) {\n        var convertedLocation = {\n          info: undefined,\n          data: {}\n        };\n        // Location object contains objects that are identified by the request parameters.\n        _.each(location, function (container, requestParameterKey) {\n          // Container object for the converted cache block data.\n          var convertedData = {\n            property: undefined,\n            timeValuePairs: []\n          };\n\n          // Each container identified by request parameter key contains cache data blocks in an array.\n          _.each(container, function (cacheBlock) {\n            // cacheBlock may be undefined if cache has reserved\n            // more timesteps for certain time range than parser has gotten\n            // for server request. Ignore undefined objects. Notice, that the\n            // correct times from server are still available in timeValuePair\n            // objects. Also, it is better to provide the parsed server data\n            // through API instead of extra undefined objects.\n            if (cacheBlock) {\n              if (!converted.data.info) {\n                // All locations have the same info object.\n                // Therefore, set content if data has not been set before.\n                converted.data.info = cacheBlock.info;\n              }\n              if (!converted.data.properties) {\n                // All locations have the same properties object.\n                // Therefore, set content if data has not been set before.\n                converted.data.properties = cacheBlock.properties;\n              }\n              if (!convertedData.property) {\n                // All the blocks of same location refere to the same property info.\n                // Therefore, set the information to the converted data object\n                // if data has not been set before.\n                convertedData.property = cacheBlock.blockProperty;\n              }\n              if (!convertedLocation.info) {\n                // All the block of same location refere to the same location info.\n                // Therefore, set the information to the converted location object\n                // if data has not been set before.\n                convertedLocation.info = cacheBlock.locationInfo;\n              }\n\n              // Insert datablock time-value-pair into the datablock time-value-pair array.\n              convertedData.timeValuePairs.push(cacheBlock.timeValuePair);\n            }\n          });\n          // Insert converted datablock into the location.\n          convertedLocation.data[requestParameterKey] = convertedData;\n        });\n        // Insert converted location data into converted data locations array.\n        converted.data.locations.push(convertedLocation);\n      });\n    }\n    return converted;\n  }\n\n  /**\r\n   * @private\r\n   *\r\n   * This callback is set for sites cache data fetcher.\r\n   *\r\n   * Parser will provide the fetched and parsed data for this callback.\r\n   * This callback will forward the data in a correct format for the cache.\r\n   *\r\n   * @param {Object} container Object that provides connection instance specific private member variables.\r\n   *                           May not be {undefined} or {null}.\r\n   * @param {Object} taskDef Definition object to describe cache blocks of the operation.\r\n   *                         May not be {undefined} or {null}.\r\n   * @param {function(errors, data)} taskCallback Called with the parsed data and errors array when operation finishes.\r\n   *                                              May not be {undefined} or {null}.\r\n   */\n  function cacheSitesDataFetcherCallback(container, taskDef, taskCallback) {\n    container.parser.getData({\n      url: getUrlString(container.connectionUrl),\n      storedQueryId: container.storedQueryId,\n      requestParameter: taskDef.parameter,\n      begin: taskDef.start,\n      end: taskDef.end,\n      timestep: taskDef.resolution,\n      // If time adjusting is requested, it has been done before giving times to cache.\n      // Therefore, do not let parser do adjusting.\n      denyTimeAdjusting: true,\n      // Notice, instead of using taskDef.location for properties here,\n      // specific location related properties are used.\n      geoid: taskDef.geoid,\n      wmo: taskDef.wmo,\n      fmisid: taskDef.fmisid,\n      sites: taskDef.sites,\n      crs: taskDef.crs,\n      queryExtension: taskDef.queryExtension,\n      callback: function (data, errors) {\n        // Forward callback to the cache.\n        // Cache will forward the callback to callbacks given through the API when the retrieve flow has been started.\n        var converted = convertSitesDataFromParserForCache.call(container, taskDef, data, errors);\n        taskCallback(converted.errors, converted.data);\n      }\n    });\n  }\n\n  /**\r\n   * @private\r\n   *\r\n   * Request cache to retrive sites data.\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * Notice, this flow will also continue\r\n   * to data fetcher callback if parser should be used to retrieve data\r\n   * from the server. The callback function is set for cache when it is\r\n   * initialized. Callbacks given and set in this function are called when\r\n   * the data is gotten either from the server or directly from the cache.\r\n   *\r\n   * See API for function description.\r\n   */\n  var retrieveSitesData = function (options) {\n    var that = this;\n    if (!options.timestep || options.timestep === 1) {\n      // Cache requires that timestep is the actual timestep that is used for data.\n      // But, in speacial cases server may use magic numbers to handle data differently.\n      // Cache can not be used with the given options. Therefore, use parser directly.\n\n      that.parser.getData({\n        url: getUrlString(that.connectionUrl),\n        storedQueryId: that.storedQueryId,\n        requestParameter: options.requestParameter,\n        begin: options.begin,\n        end: options.end,\n        timestep: options.timestep,\n        // When parser is used directly, it can handle time adjusting automatically if requested.\n        denyTimeAdjusting: options.denyTimeAdjusting,\n        geoid: trimProperty(options.geoid),\n        wmo: trimProperty(options.wmo),\n        fmisid: trimProperty(options.fmisid),\n        sites: trimSites(options.sites),\n        crs: options.crs,\n        queryExtension: options.queryExtension,\n        callback: options.callback\n      });\n    } else {\n      // Use cache for sites data.\n      // If time adjusting is requested, it is done before values are given for the cache.\n      var beginDate = options.begin;\n      var endDate = options.end;\n      var resolution = options.timestep;\n      if (!options.denyTimeAdjusting) {\n        beginDate = that.parser.adjustBeginTime(resolution, beginDate);\n        endDate = that.parser.adjustEndTime(resolution, endDate, beginDate);\n      }\n      var taskDef = {\n        service: DATA_FETCHER_NAME_SITES,\n        parameter: _.isString(options.requestParameter) ? options.requestParameter.split(PARAMETER_SEPARATOR) : options.requestParameter,\n        // Make sure parameter(s) are integers instead of Date objects when they are given to cache.\n        start: beginDate instanceof Date ? beginDate.getTime() : beginDate,\n        end: endDate instanceof Date ? endDate.getTime() : endDate,\n        resolution: resolution,\n        crs: options.crs,\n        queryExtension: options.queryExtension\n      };\n      // Because locations can be given in multiple ways, location related properties are\n      // set separately for taskDef to combine all location informations for cache.\n      setTaskDefLocations(taskDef, options);\n      this.cache.fetch(taskDef, function (errors, result) {\n        var converted = convertSitesDataFromCacheForApi(taskDef, result, errors);\n        options.callback(converted.data, converted.errors);\n      }, options.progressCallback);\n    }\n  };\n\n  /**\r\n   * @private\r\n   *\r\n   * Request parser directly to retrive spatial data.\r\n   *\r\n   * Notice, cache is not used for spatial data.\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * Notice, this flow will also continue\r\n   * to data fetcher callback if parser should be used to retrieve data\r\n   * from the server. The callback function is set for cache when it is\r\n   * initialized. Callbacks given and set in this function are called when\r\n   * the data is gotten either from the server or directly from the cache.\r\n   *\r\n   */\n  var retrieveSpatialData = function (options) {\n    var that = this;\n    that.parser.getData({\n      url: getUrlString(that.connectionUrl),\n      storedQueryId: that.storedQueryId,\n      requestParameter: options.requestParameter,\n      begin: options.begin,\n      end: options.end,\n      timestep: options.timestep,\n      // When parser is used directly, it can handle time adjusting automatically if requested.\n      denyTimeAdjusting: options.denyTimeAdjusting,\n      // Include also other sites related options if they are given.\n      // But, bbox is the reason that all data is provided directly for the parser.\n      geoid: trimProperty(options.geoid),\n      wmo: trimProperty(options.wmo),\n      fmisid: trimProperty(options.fmisid),\n      sites: trimSites(options.sites),\n      bbox: options.bbox,\n      crs: options.crs,\n      latlon: options.latlon,\n      queryExtension: options.queryExtension,\n      callback: options.callback\n    });\n  };\n\n  /**\r\n   * @private\r\n   *\r\n   * Wraps the function calls inside try-catch before calling.\r\n   *\r\n   * Instead of using multiple try catches in many functions only one is used here.\r\n   * This style may improve performance.\r\n   *\r\n   * Notice, this function applies this-reference to the function calls.\r\n   *\r\n   * @param {function} func Function that should be called.\r\n   *                        May not be {undefined} or {null}.\r\n   * @param {function} callback Callback function that is called if an exception occurs\r\n   *                            during this synchronous part of the flow. Notice, this\r\n   *                            is a callback that may be provided for asynchronous flow.\r\n   *                            May be {undefined} or {null}.\r\n   * @return {boolean} {true} if operation starts successfully. Else {false}.\r\n   *                          Notice, if {callback} is given, it is also called\r\n   *                          if false is returned for success.\r\n   */\n  var makeSafe = function (func, callback) {\n    var success = true;\n    try {\n      // Call the correct function with the original arguments.\n      // Function reference itself is removed from the arguments.\n      // Also, callback reference provided for synchronous exception\n      // handling is removed from the arguments.\n      var args = Array.prototype.slice.call(arguments);\n      args.shift();\n      args.shift();\n      func.apply(this, args);\n    } catch (e) {\n      var errorStr = \"ERROR: API level error occurred in a synchronous flow!\";\n      if (\"undefined\" !== typeof console && console) {\n        console.error(errorStr);\n        console.error(e);\n      }\n      success = false;\n      if (callback) {\n        // Inform callback about exception in the flow.\n        // Then, caller knows that asynchronous flow has ended.\n        var error = {\n          errorText: errorStr\n        };\n        callback(undefined, error);\n      }\n    }\n    return success;\n  };\n\n  /**\r\n   * @private\r\n   *\r\n   * Get a URL string. If an array of URLs has been set to make use of domain sharding, a random array member is returned.\r\n   *\r\n   */\n  var getUrlString = function (urlOption) {\n    if (_.isArray(urlOption)) {\n      return urlOption[Math.floor(Math.random() * urlOption.length)];\n    } else {\n      return urlOption;\n    }\n  };\n\n  /**\r\n   * @private\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * See API for function description.\r\n   */\n  var getUrl = function () {\n    return this.connectionUrl;\n  };\n\n  /**\r\n   * @private\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * See API for function description.\r\n   */\n  var getStoredQueryId = function () {\n    return this.storedQueryId;\n  };\n\n  /**\r\n   * @private\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * See API for function description.\r\n   */\n  var connect = function (url, storedQueryId) {\n    // Skip if already connected.\n    // Notice, if already connected, this function does not reconnect\n    // even if a new URL would be different than the old one.\n    if (!this.connectionUrl) {\n      if (!_.isString(url) && !_.isArray(url) || !url.length || !url) {\n        var urlErrorStr = \"ERROR: WfsConnection URL must be a string or an array and not empty!\";\n        if (\"undefined\" !== typeof console && console) {\n          console.error(urlErrorStr);\n        }\n        throw urlErrorStr;\n      }\n      if (!_.isString(storedQueryId) || !storedQueryId) {\n        var idErrorStr = \"ERROR: WfsConnection stored query ID must be a string and not empty!\";\n        if (\"undefined\" !== typeof console && console) {\n          console.error(idErrorStr);\n        }\n        throw idErrorStr;\n      }\n      this.connectionUrl = url;\n      this.storedQueryId = storedQueryId;\n    }\n  };\n\n  /**\r\n   * @private\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * See API for function description.\r\n   */\n  var disconnect = function () {\n    this.connectionUrl = undefined;\n    this.storedQueryId = undefined;\n    resetCache.call(this);\n  };\n\n  /**\r\n   * @private\r\n   *\r\n   * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n   *\r\n   * See API for function description.\r\n   */\n  var resetCache = function () {\n    this.cache.clearCache();\n  };\n\n  /**\r\n   * @private\r\n   *\r\n   * See API for function description.\r\n   */\n  var getData = function (options) {\n    if (options) {\n      if (options.bbox || options.latlon) {\n        // BBox nor LatLon are not supported by the cache at the moment.\n        // Therefore, pass the whole query to the parser.\n        retrieveSpatialData.call(this, options);\n      } else if (options.geoid || options.wmo || options.fmisid || options.sites) {\n        retrieveSitesData.call(this, options);\n      } else {\n        var errorStr = \"ERROR: Either geoid, wmo, fmisid, sites, bbox or latlon is mandatory in options!\";\n        if (\"undefined\" !== typeof console && console) {\n          console.error(errorStr);\n        }\n        throw errorStr;\n      }\n    } else {\n      var optionsErrorStr = \"ERROR: Options object is mandatory!\";\n      if (\"undefined\" !== typeof console && console) {\n        console.error(optionsErrorStr);\n      }\n      throw optionsErrorStr;\n    }\n  };\n\n  /**\r\n   * Constructor for the connection instance.\r\n   *\r\n   * Notice, this constructor is returned from {WfsConnection}\r\n   * and can be used for instantiation later.\r\n   */\n  var connectionConstructor = function (splitterCacheConfig) {\n    // Reference to the connection instance object.\n    var that = this;\n\n    // {SplitterCache} configuration\n    splitterCacheConfig = splitterCacheConfig || {\n      sideFetchAfterFactor: 1,\n      sideFetchBeforeFactor: 0.5,\n      maxBlockDataPoints: 200,\n      maxCacheDataSize: 4000\n    };\n\n    // Private object is used for API functions to provide them private member variables.\n    // Instance specific data is available for API functions when reference to this private\n    // object is applied to the function calls by using this private object. Then, these\n    // variables and functions are capsulated and are not available outside of the connection\n    // instance.\n    this._private = {\n      // Reference to the connection instance object.\n      connectionInstance: that,\n      // Member variables that are initialized to undefined.\n      // When connection function is called these are set.\n      connectionUrl: undefined,\n      storedQueryId: undefined,\n      // Member variables that are initialized to values that are used\n      // throughout the lifetime of object instance.\n\n      // Cache for retrieved data.\n      cache: new SplitterCache(splitterCacheConfig),\n      parser: new WfsRequestParser()\n    };\n\n    //=================================================================\n    // Public WfsConnection API is defined here as priviledged functions.\n    //=================================================================\n\n    /**\r\n     * Synchronous.\r\n     *\r\n     * @return {String} URL that is used for the connection and\r\n     *                  has been set when {connect} function is called.\r\n     *                  May be {undefined} if state is not connected.\r\n     */\n    this.getUrl = function () {\n      return getUrl.call(this._private);\n    };\n\n    /**\r\n     * Synchronous.\r\n     *\r\n     * @return {String} Stored query ID that is used for the connection\r\n     *                  and has been set when {connect} function is called.\r\n     *                  May be {undefined} if state is not connected.\r\n     */\n    this.getStoredQueryId = function () {\n      return getStoredQueryId.call(this._private);\n    };\n\n    /**\r\n     * Synchronous.\r\n     *\r\n     * Notice, if already connected, this function does not reconnect\r\n     * even if a new URL would be different than the old one.\r\n     *\r\n     * @param {String} url URL that is used for the connection.\r\n     *                     May not be {undefined}, {null} or empty.\r\n     * @param {String} storedQueryId Stored query ID to identify the data that is requested.\r\n     *                               For example, stored query ID may be used to request\r\n     *                               observed data or forecast data.\r\n     *                               May not be {undefined}, {null} or empty.\r\n     * @return {boolean} {true} if synchronous operation was successfull. Else {false}.\r\n     */\n    this.connect = function (url, storedQueryId) {\n      var that = this;\n      // Set data fetcher that cache uses for the given type of the data.\n      this._private.cache.addDataProvider(DATA_FETCHER_NAME_SITES, function (taskDef, callback) {\n        cacheSitesDataFetcherCallback(that._private, taskDef, callback);\n      });\n      return makeSafe.call(that._private, connect, undefined, url, storedQueryId);\n    };\n\n    /**\r\n     * Synchronous.\r\n     *\r\n     * Releases resources.\r\n     *\r\n     * @return {boolean} {true} if synchronous operation was successfull. Else {false}.\r\n     */\n    this.disconnect = function () {\n      return makeSafe.call(this._private, disconnect, undefined);\n    };\n\n    /**\r\n     * Synchronous.\r\n     *\r\n     * Releases cache resources.\r\n     *\r\n     * @return {boolean} {true} if synchronous operation was successfull. Else {false}.\r\n     */\n    this.resetCache = function () {\n      return makeSafe.call(this._private, resetCache, undefined);\n    };\n\n    /**\r\n     * Request data.\r\n     *\r\n     * Operation is asynchronous.\r\n     *\r\n     * Notice, callback is {function(data, errors){}}.\r\n     *      - data: Data object provides locations data.\r\n     *              May be {undefined} if an error has occurred.\r\n     *              The object is of this structure:\r\n     *          {\r\n     *              // General information received in the server response for the request.\r\n     *              // May not be {undefined} or {null}.\r\n     *              // Content properties are set if given in the server response.\r\n     *              info : {\r\n     *                  begin : {Date|undefined},\r\n     *                  end : {Date|undefined}\r\n     *              },\r\n     *              // Properties provide descriptive property objects that correspond to\r\n     *              // the parameter keys that have been given for the request. Notice,\r\n     *              // property data is also available inside locations data objects.\r\n     *              // This object is provided as a complementary object, if reference to a single\r\n     *              // wrapper object is later needed for general information about properties.\r\n     *              properties : {\r\n     *                  parameterAsKey : { label : \"labelString\",\r\n     *                                     unit : \"measurementUnitString\",\r\n     *                                     phenomenon : \"phenomenonString\",\r\n     *                                     statisticalFunction : \"statisticalFunctionString\",\r\n     *                                     statisticalPeriod : \"statisticalAggregationTimePeriod\" },\r\n     *                  ...\r\n     *              },\r\n     *              // Data of locations. May be empty if sites data is not provided.\r\n     *              // May not be {undefined} or {null}.\r\n     *              locations : [\r\n     *                  {\r\n     *                      info : {\r\n     *                          id : \"location id string\",\r\n     *                          geoid : \"geoid string\",\r\n     *                          wmo : \"wmo string\",\r\n     *                          fmisid : \"fmisid string\",\r\n     *                          name : \"location name string\",\r\n     *                          region : \"region name string\",\r\n     *                          country : \"country name string\",\r\n     *                          timezone : \"timezone name string\",\r\n     *                          position : [ \"positionStringPart1\", \"positionStringPart2\", ... ]\r\n     *                      },\r\n     *                      data : {\r\n     *                          // Data property keys correspond to the parameter keys\r\n     *                          // that have been given for the request.\r\n     *                          parameterAsKey : {\r\n     *                            property : { label : \"labelString\",\r\n     *                                         unit : \"measurementUnitString\",\r\n     *                                         phenomenon : \"phenomenonString\",\r\n     *                                         statisticalFunction : \"statisticalFunctionString\",\r\n     *                                         statisticalPeriod : \"statisticalAggregationTimePeriod\" },\r\n     *                            timeValuePairs : [ { time : intTimeInMsSince01011970,\r\n     *                                                 value : floatMeasurementValue }, ... ]\r\n     *                          },\r\n     *                          ...\r\n     *                      }\r\n     *                  },\r\n     *                  ...\r\n     *              ]\r\n     *          }\r\n     *      - errors: Array that contains possible errors that occurred during the flow. Array is\r\n     *                always provided even if it may be empty. If an error occurs in this parser,\r\n     *                an error string is pushed here. Also, when an HTTP error occurs, error contains\r\n     *                the textual portion of the HTTP status, such as \"Not Found\" or \"Internal Server Error.\"\r\n     *                Errors parameter is of this structure:\r\n     *          [\r\n     *              {\r\n     *                  // None, one, or more of the following error values may exist.\r\n     *                  // Values may also be {undefined} or {null}.\r\n     *                  errorCode : \"errorCodeString\",\r\n     *                  errorText : \"errorTextString\",\r\n     *                  extension : {Object}\r\n     *              },\r\n     *              ...\r\n     *          ]\r\n     *\r\n     * Notice, object properties of the function {options} parameter are URL encoded by this library\r\n     * before they are inserted into the request URL.\r\n     *\r\n     * @param {Object} options Mandatory. May not be {undefined} or {null}. Object structure:\r\n     *     {\r\n     *         requestParameter : {String|Array(String)}\r\n     *                            Mandatory property. May not be {undefined} or {null}. Array may not be empty.\r\n     *                            This is one of the parameter strings that is part of\r\n     *                            URL parameters to define which data is requested from the server.\r\n     *                            Parameter string may contain request for multiple parameters.\r\n     *                            For example, value for dew point temperature may be \"td\".\r\n     *                            If an array is given, strings are given as separate array string items.\r\n     *         begin : {int|Date}\r\n     *                 Mandatory property. May not be {undefined} or {null}.\r\n     *                 The begin time for the data.\r\n     *                 Integer value is number of milliseconds since 01.01.1970 that can be gotten,\r\n     *                 for example, with {Date::getTime()}. Alternatively, {Date} object may be given.\r\n     *         end : {int|Date}\r\n     *               Mandatory property. May not be {undefined} or {null}.\r\n     *               The end time for the data.\r\n     *               Value is number of milliseconds since 01.01.1970 that can be gotten,\r\n     *               for example, with {Date::getTime()}. Alternatively, {Date} object may be given.\r\n     *         timestep : {int}\r\n     *                    May be {undefined} or {null}.\r\n     *                    Timestep in milliseconds.\r\n     *                    If {undefined}, {null} or zero, server returns all data for\r\n     *                    the given time interval. If timestep is 1, server uses the default\r\n     *                    timestep. Notice, even if time is in milliseconds here, it is converted\r\n     *                    and floored to minutes before sending for the server.\r\n     *         denyTimeAdjusting : {boolean}\r\n     *                             May be {undefined} or {null}.\r\n     *                             If {true}, {begin} and {end} times are not adjusted for server but given values\r\n     *                             are used exactly for requests. Otherwise, times are adjusted.\r\n     *         geoid : {Array(String|int)|String|int}\r\n     *                 May be {undefined} or {null} or empty if {wmo}, {fmisid}, {sites} or {bbox} is given.\r\n     *                 Array of Geographical name ID (geonames.org) strings or integers.\r\n     *                 One geoid can be given as a single string or integer.\r\n     *                 Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n     *         wmo : {Array(String|int)|String|int}\r\n     *               May be {undefined} or {null} or empty if {geoid}, {fmisid}, {sites} or {bbox} is given.\r\n     *               Array of World Meteorological Organization (WMO) identifier strings or integers.\r\n     *               One wmo can be given as a single string or integer.\r\n     *               Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n     *         fmisid : {Array(String|int)|String|int}\r\n     *                  May be {undefined} or {null} or empty if {geoid}, {wmo}, {sites} or {bbox} is given.\r\n     *                  Array of FMI observation station identifiers (fmisid) strings or integers.\r\n     *                  One fmisid can be given as a single string or integer.\r\n     *                  Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n     *         sites : {Array(String)|String}\r\n     *                 May be {undefined} or {null} or empty if {geoid}, {wmo}, {fmisid} or {bbox} is given.\r\n     *                 Array of site name strings. One site can be given as a single string.\r\n     *                 Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n     *         bbox : {String}\r\n     *                May be {undefined}, {null} or empty if {geoid}, {wmo}, {fmisid} or {sites} is given.\r\n     *                BBOX string. Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n     *                Notice, cache is not used if spatial data (bbox) is queried.\r\n     *         crs : {String}\r\n     *               May be {undefined}, {null} or empty.\r\n     *               Coordinate Reference System (CRS) string.\r\n     *         queryExtension : {Object}\r\n     *                          Optional. May be {undefined} or {null}.\r\n     *                          Property values may be {undefined}, {null} or {string}.\r\n     *                          This property is not needed in normal use cases of the API.\r\n     *                          But, this property may be used if API does not support field-value-pairs\r\n     *                          that need to be included into request URL query. The key-value-pairs of\r\n     *                          the property are URL encoded and included as URL query field-value-pairs\r\n     *                          in the request. If property value is {undefined} or {null}, it is interpreted\r\n     *                          as an empty string. Notice, other API properties should be used instead of this\r\n     *                          extension if possible.\r\n     *         callback : {function(data, errors)}\r\n     *                    Mandatory property. May not be {undefined} or {null}.\r\n     *                    Callback is called with the parsed data and errors array when operation finishes.\r\n     *                    If an error occurs, data is set {undefined} for the callback. Possible errors are\r\n     *                    given inside the array that is always provided.\r\n     *         progressCallback : {function(err, partStart, partEnd)}\r\n     *                            Not mandatory property.\r\n     *                            Called when part of the flow has finished.\r\n     *                            Function is called with {err}, {partStart} and {partEnd} parameters.\r\n     *     }\r\n     * @return {boolean} {true} if asynchronous operation is successfully started. Else {false}.\r\n     */\n    this.getData = function (options) {\n      return makeSafe.call(this._private, getData, options ? options.callback : undefined, options);\n    };\n  };\n\n  // Constructor function is returned for later instantiation.\n  return connectionConstructor;\n}();\nmodule.exports = WfsConnection;","map":{"version":3,"names":["jQuery","require","_","async","SplitterCache","WfsRequestParser","WfsConnection","DATA_FETCHER_NAME_SITES","PARAMETER_SEPARATOR","LOCATION_NAME_REGION_SEPARATOR","LOCATION_GEOID_PREFIX","LOCATION_WMO_PREFIX","LOCATION_FMISID_PREFIX","LOCATION_SITES_PREFIX","CACHE_ERROR_TEXT","trimSingleSite","site","trim","replace","trimSites","sites","prefix","trimmed","isString","push","isArray","i","length","trimProperty","property","isNumber","tmp","setTaskDefLocations","taskDef","options","location","geoid","wmo","fmisid","apply","checkResolutionSteps","array","resolution","previousTimeValuePair","timeValuePair","isObject","previousTime","time","undefined","splice","value","NaN","contains","list","item","find","currentItem","isEqual","convertCacheErrorsForApi","errors","apiErrors","error","useWrapError","errorCode","errorText","errorArray","j","errorItem","newError","extension","newWrapError","convertSitesDataFromParserForCache","data","converted","each","locations","key","locationName","dataObject","keyRequestParameter","timeValuePairs","cacheBlock","info","properties","locationInfo","blockProperty","convertSitesDataFromCacheForApi","convertedLocation","container","requestParameterKey","convertedData","cacheSitesDataFetcherCallback","taskCallback","parser","getData","url","getUrlString","connectionUrl","storedQueryId","requestParameter","parameter","begin","start","end","timestep","denyTimeAdjusting","crs","queryExtension","callback","call","retrieveSitesData","that","beginDate","endDate","adjustBeginTime","adjustEndTime","service","split","Date","getTime","cache","fetch","result","progressCallback","retrieveSpatialData","bbox","latlon","makeSafe","func","success","args","Array","prototype","slice","arguments","shift","e","errorStr","console","urlOption","Math","floor","random","getUrl","getStoredQueryId","connect","urlErrorStr","idErrorStr","disconnect","resetCache","clearCache","optionsErrorStr","connectionConstructor","splitterCacheConfig","sideFetchAfterFactor","sideFetchBeforeFactor","maxBlockDataPoints","maxCacheDataSize","_private","connectionInstance","addDataProvider","module","exports"],"sources":["C:/Users/Ossi Laurila/Desktop/weatherapp/node_modules/@fmidev/metolib/wfsconnection.js"],"sourcesContent":["/**\r\n * This software may be freely distributed and used under the following MIT license:\r\n *\r\n * Copyright (c) 2017 Finnish Meteorological Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the\r\n * Software without restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n * Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\r\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n// Strict mode for whole file.\r\n\"use strict\";\r\n\r\n// Requires jQuery, lodash, async\r\nvar jQuery = require('jquery');\r\nvar _ = require('lodash');\r\nvar async = require('async');\r\n// import jQuery from 'jquery';\r\n// import _ from 'lodash';\r\n// import async from 'async';\r\n\r\n// Requires SplitterCache, WfsRequestParser\r\nvar SplitterCache = require('./splittercache.js');\r\nvar WfsRequestParser = require('./wfsrequestparser.js');\r\n// import SplitterCache from './splittercache.js';\r\n// import WfsRequestParser from './wfsrequestparser.js';\r\n\r\n/**\r\n * WfsConnection object acts as an interface that provides functions\r\n * to asynchronously request XML data from the server and to get\r\n * the requested data in a parsed structure.\r\n *\r\n * WfsConnection wraps cache, request and parser functionality.\r\n * Notice, if you do not require cache functionality, you may\r\n * want to use parser, {@link WfsRequestParser},\r\n * directly without using this class as an intermediate object.\r\n *\r\n * API functions are defined in the end of the constructor,\r\n * {connectionConstructor}, as priviledged functions.\r\n * See API description there.\r\n *\r\n * Example:\r\n *      var connection = new WfsConnection();\r\n *      if (connection.connect(SERVER_URL, STORED_QUERY_OBSERVATION)) {\r\n *          // Connection was properly initialized. So, get the data.\r\n *          connection.getData({\r\n *              requestParameter : \"td,ws_10min\",\r\n *              // Integer values are used to init dates for older browsers.\r\n *              // (new Date(\"2013-05-10T08:00:00Z\")).getTime()\r\n *              // (new Date(\"2013-05-12T10:00:00Z\")).getTime()\r\n *              begin : new Date(1368172800000),\r\n *              end : new Date(1368352800000),\r\n *              timestep : 60 * 60 * 1000,\r\n *              sites : [\"Kaisaniemi,Helsinki\", \"Turku\"],\r\n *              callback : function(data, errors) {\r\n *                  // Handle the data and errors object in a way you choose.\r\n *                  handleCallback(data, errors);\r\n *                  // If the connection will not be used anymore later,\r\n *                  // the connection may be disconnected because the flow has finished.\r\n *                  connection.disconnect();\r\n *              }\r\n *          });\r\n *      }\r\n */\r\n\r\nvar WfsConnection = (function() {\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Data fetcher name for cache when sites are used for fetching.\r\n     */\r\n    var DATA_FETCHER_NAME_SITES = \"parserSites\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Parameter values are separated by this string.\r\n     */\r\n    var PARAMETER_SEPARATOR = \",\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Location name and region strings may be separated by this string\r\n     * in server responses.\r\n     */\r\n    var LOCATION_NAME_REGION_SEPARATOR = \" \";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Geoid location name prefix for cache.\r\n     */\r\n    var LOCATION_GEOID_PREFIX = \"g_\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * WMO location name prefix for cache.\r\n     */\r\n    var LOCATION_WMO_PREFIX = \"w_\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * FMISID location name prefix for cache.\r\n     */\r\n    var LOCATION_FMISID_PREFIX = \"f_\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Sites location name prefix for cache.\r\n     */\r\n    var LOCATION_SITES_PREFIX = \"s_\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * General text that describes an error that has been found in cache.\r\n     */\r\n    var CACHE_ERROR_TEXT = \"ERROR: Cache found error(s)!\";\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Trim single site string for cache flow.\r\n     *\r\n     * @param {String} May not be {undefined} or {null}.\r\n     */\r\n    function trimSingleSite(site) {\r\n        return jQuery.trim(site).replace(/,\\s+/, PARAMETER_SEPARATOR);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Trim unnecessary white spaces from sites string(s).\r\n     *\r\n     * Notice, new content is returned. Then, original values are not changed if an array is given.\r\n     *\r\n     * @param {Array(String)|String} Site strings in an array or one site may be given as a single string.\r\n     *                               May be {udefined} or {null} but then operation is ignored.\r\n     * @param {String} prefix Prefix string that is used with the value(s).\r\n     *                        This is meant for cache but should not be used for parser.\r\n     *                        May be {udefined} or {null}. Then, empty string is used.\r\n     * @return {Array(String)} Trimmed site(s) in an array. May not be {undefined} or {null}.\r\n     */\r\n    function trimSites(sites, prefix) {\r\n        var trimmed = [];\r\n        if (!_.isString(prefix)) {\r\n            // Make sure prefix is at least an empty string.\r\n            prefix = \"\";\r\n        }\r\n        // Handle sites as string(s).\r\n        if (sites && _.isString(sites)) {\r\n            // Trim possible white spaces.\r\n            // Location and its region may be separated by using comma but there should not be whitespaces after comma.\r\n            // Then, later it is easier to compare server responses with given sites when data is handled for cache.\r\n            trimmed.push(prefix + trimSingleSite(sites));\r\n\r\n        } else if (_.isArray(sites)) {\r\n            for (var i = 0; i < sites.length; ++i) {\r\n                var site = sites[i];\r\n                if (site && _.isString(site)) {\r\n                    trimmed.push(prefix + trimSingleSite(site));\r\n                }\r\n            }\r\n        }\r\n        return trimmed;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Trim unnecessary white spaces from string(s).\r\n     *\r\n     * Notice, new content is returned. Then, original values are not changed if an array is given.\r\n     *\r\n     * @param {Array(String|int)|String|int} property Strings or integers in an array\r\n     *                                                or one item as a single string or integer.\r\n     *                                                May be {udefined} or {null}.\r\n     * @param {String} prefix Prefix string that is used with the value(s).\r\n     *                        This is meant for cache but should not be used for parser.\r\n     *                        May be {udefined} or {null}. Then, empty string is used.\r\n     * @return {Array(String)} Trimmed value(s) in an array. May not be {undefined} or {null}.\r\n     */\r\n    function trimProperty(property, prefix) {\r\n        var trimmed = [];\r\n        if (!_.isString(prefix)) {\r\n            // Make sure prefix is at least an empty string.\r\n            prefix = \"\";\r\n        }\r\n        if (_.isNumber(property) || property && _.isString(property)) {\r\n            trimmed.push(jQuery.trim(prefix + property));\r\n\r\n        } else if (_.isArray(property)) {\r\n            for (var i = 0; i < property.length; ++i) {\r\n                var tmp = property[i];\r\n                // Handle property as string.\r\n                if (_.isNumber(tmp) || tmp && _.isString(tmp)) {\r\n                    trimmed.push(jQuery.trim(prefix + tmp));\r\n                }\r\n            }\r\n        }\r\n        return trimmed;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Cache {taskDef} location should contain all the locations (not just sites names).\r\n     * This function combines all the location information into one array that is\r\n     * set as {location} -property for the cache {taskDef}. Also, other properties that\r\n     * are used for {taskDef} location property are set.\r\n     *\r\n     * @param {Object} taskDef Target for location settings.\r\n     *                         Operation is ignored if {undefined} or {null}.\r\n     * @param {Object} options Options object given through the API.\r\n     *                         Provides location data for {taskDef}.\r\n     *                         Operation is ignored if {undefined} or {null}.\r\n     */\r\n    function setTaskDefLocations(taskDef, options) {\r\n        if (taskDef && options) {\r\n            var location = [];\r\n            taskDef.location = location;\r\n            // Notice, these properties are used to provide additional information\r\n            // that can be given for the parser. The cache uses location property\r\n            // to create the cache hierarchy.\r\n            taskDef.geoid = trimProperty(options.geoid);\r\n            taskDef.wmo = trimProperty(options.wmo);\r\n            taskDef.fmisid = trimProperty(options.fmisid);\r\n            taskDef.sites = trimSites(options.sites);\r\n            // Combine locations information for taskDef location.\r\n            // Notice, prefix is used for cache. Then, it is sure that different location\r\n            // requests do not have same string for key (really rare case).\r\n            location.push.apply(location, trimProperty(options.geoid, LOCATION_GEOID_PREFIX));\r\n            location.push.apply(location, trimProperty(options.wmo, LOCATION_WMO_PREFIX));\r\n            location.push.apply(location, trimProperty(options.fmisid, LOCATION_FMISID_PREFIX));\r\n            location.push.apply(location, trimSites(options.sites, LOCATION_SITES_PREFIX));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Check that time-value-pair objects are not missing from the given array.\r\n     * If an object is missing, time-value-pair of the correct time and NaN value\r\n     * is inserted into the array according to the resolution step.\r\n     *\r\n     * @param {[]} array Array that contains time-value-pair objects.\r\n     *                   Operation is ignored if {undefined} or {null}.\r\n     * @param {Integer} resolution Time in milliseconds to describe timesteps between values.\r\n     *                             Operation is ignored if {undefined}, {null}, zero or negative.\r\n     */\r\n    function checkResolutionSteps(array, resolution) {\r\n        if (_.isArray(array) && resolution && resolution > 0) {\r\n            for (var i = 1; i < array.length; ++i) {\r\n                var previousTimeValuePair = array[i - 1];\r\n                var timeValuePair = array[i];\r\n                if (_.isObject(timeValuePair)) {\r\n                    var previousTime = _.isObject(previousTimeValuePair) ? previousTimeValuePair.time : undefined;\r\n                    var time = timeValuePair.time;\r\n                    if (undefined !== previousTime && null !== previousTime && undefined !== time && null !== time && resolution < time - previousTime) {\r\n                        // Time-value-pair object is missing between two array objects.\r\n                        // Insert a new NaN value pair into array.\r\n                        // Notice, time of this new object is compared in next round to the\r\n                        // same object that is checked already in this round.\r\n                        // Then, missing resolution objects are added properly into too large gaps.\r\n                        time = previousTime + resolution;\r\n                        array.splice(i, 0, {\r\n                            time : time,\r\n                            value : NaN\r\n                        });\r\n                    }\r\n                    previousTime = time;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Check if given {list} contains an equal to the given {item}.\r\n     *\r\n     * Performs an optimized deep comparison between the objects of the {list} and given {item},\r\n     * to determine if they should be considered equal.\r\n     *\r\n     * @param {Array} list List whose items are compared to {item}. May be {undefined} or {null}.\r\n     * @param {Object} item Item that is compared to the list items. May be {undefined} or {null}.\r\n     * @return {Boolean} {true} if {item} equals at least one item in {list}.\r\n     */\r\n    function contains(list, item) {\r\n        return _.find(list, function(currentItem) {\r\n            return _.isEqual(currentItem, item);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Converts errors given by cache to the error objects given through API.\r\n     * Possible duplicates are not included into the returned array.\r\n     *\r\n     * @param {Array} errors Errors array from the cache that is converted to API errors array.\r\n     *                       May be {undefined} or {null}.\r\n     * @return {Array} Converted errors in an array. May not be {undefined} or {null}.\r\n     */\r\n    function convertCacheErrorsForApi(errors) {\r\n        var apiErrors = [];\r\n        if (_.isArray(errors)) {\r\n            for (var i = 0; i < errors.length; ++i) {\r\n                var error = errors[i];\r\n                // Flag to inform if error item should just be wrapped as a general cache error\r\n                // or if error content has been handled separately. Always include wrapped error\r\n                // into array if cache error root level already contains errorCode or errorText information.\r\n                var useWrapError = _.isObject(error) && (error.errorCode || error.errorText);\r\n                // Cache error structure may wrap errors gotten from parser.\r\n                // Check if parser has provided errors. Then, that error information can be included\r\n                // in the root level of the API error.\r\n                if (_.isObject(error) && _.isArray(error.error) && error.error.length > 0) {\r\n                    var errorArray = error.error;\r\n                    for (var j = 0; j < errorArray.length; ++j) {\r\n                        // Error array may contain the actual parse error.\r\n                        // Check if the error code and text are available for API error object.\r\n                        // If multiple error items are in the array. Handle them all as a separate error.\r\n                        var errorItem = errorArray[j];\r\n                        if (_.isObject(errorItem) && (errorItem.errorCode || errorItem.errorText)) {\r\n                            var newError = {\r\n                                errorCode : errorItem.errorCode,\r\n                                errorText : errorItem.errorText,\r\n                                // Reference to the original error structure.\r\n                                // Then, additional information is available also through API if needed.\r\n                                extension : error\r\n                            };\r\n                            // Perform an optimized deep comparison between already included errors and new error,\r\n                            // to determine if the new error should be included or if it is a duplicate.\r\n                            if (!contains(apiErrors, newError)) {\r\n                                apiErrors.push(newError);\r\n                            }\r\n\r\n                        } else {\r\n                            // Wrap the whole error as a cache error\r\n                            // because unknown structure has been given.\r\n                            useWrapError = true;\r\n                        }\r\n                    }\r\n\r\n                } else {\r\n                    // Wrap the whole error as a cache error\r\n                    // because unknown structure has been given.\r\n                    useWrapError = true;\r\n                }\r\n                // Check if the original error should be wrapped as an extension for API error object.\r\n                if (useWrapError) {\r\n                    // Create api error from the cache error.\r\n                    var newWrapError = {\r\n                        errorCode : _.isObject(error) ? error.errorCode : undefined,\r\n                        errorText : _.isObject(error) && _.isString(error.errorText) ? error.errorText : CACHE_ERROR_TEXT,\r\n                        extension : error\r\n                    };\r\n                    // Perform an optimized deep comparison between already included errors and new error,\r\n                    // to determine if the new error should be included or if it is a duplicate.\r\n                    if (!contains(apiErrors, newWrapError)) {\r\n                        apiErrors.push(newWrapError);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return apiErrors;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Convert sites data received from the parser to the structure that cache can handle.\r\n     *\r\n     * Notice, this function is called only if parser was used for the server requests.\r\n     * If data was already in cache, the flow does not come here.\r\n     *\r\n     * Notice, data is provided as structure of the objects.\r\n     * {@link SplitterCache#fillWith} function describes\r\n     * the object structure of the converted data. Cache data blocks are provided\r\n     * as the structure leaf objects. Notice, even if structure is created by using\r\n     * objects, it is better to include all the persisting data in the leaf cache block\r\n     * objects instead in the common parts in the middle of the structure. Then, data will\r\n     * always be available when data is requested from the cache.\r\n     *\r\n     * @param {Object} taskDef Definition object to describe cache blocks of the operation.\r\n     *                         May not be {undefined} or {null}.\r\n     * @param {Object} data Data from the parser. May be {undefined} or {null}.\r\n     * @param {Object} errors Errors that have occurred during loading and parsing data.\r\n     *                        May be {undefined} or {null}.\r\n     * @return {Object} Object that contains converted errors and converted data.\r\n     *                  {@link SplitterCache#fillWith} function describes\r\n     *                  the object structure of the converted data. May not be {undefined} or {null}.\r\n     */\r\n    function convertSitesDataFromParserForCache(taskDef, data, errors) {\r\n        var converted = {\r\n            // Data is converted below into the data object if data is available.\r\n            data : data ? {} : undefined,\r\n            // Cache handles errors according to node.js error convention.\r\n            // Therefore, instead of passing empty array for cache,\r\n            // error object should be set null if there are no errors.\r\n            errors : errors && !errors.length ? null : errors\r\n        };\r\n        if (data) {\r\n            // Convert the given data into the correct structure that is inserted\r\n            // into the convert object. Convert object contains location specific objects,\r\n            // which in turn contain measurement parameter specific objects, which contain arrays for\r\n            // cache data block objects. See SplitterCache#fillWith\r\n            // function for the corresponding structure that cache requires.\r\n            _.each(data.locations, function(location, key) {\r\n                // Location name is used as a key for the location object.\r\n                var locationName = taskDef.location[key];\r\n                if (!converted.data[locationName]) {\r\n                    // Initialize converted data to contain location object identified by the location name.\r\n                    converted.data[locationName] = {};\r\n                }\r\n                // Location contains data array that contains measurement data objects\r\n                // and measurement related information.\r\n                _.each(location.data, function(dataObject, keyRequestParameter) {\r\n                    if (!converted.data[locationName][keyRequestParameter]) {\r\n                        // Initialize converted location object to contain measurement array\r\n                        // identified by request parameter key. Notice, cache will internally loop\r\n                        // through the cache block array by indexing it.\r\n                        converted.data[locationName][keyRequestParameter] = [];\r\n                    }\r\n                    // Loop through the actual measurement time-value-pair data objects.\r\n                    // Also, check timesteps before giving array to cache.\r\n                    // This may fix some indexing problems in cache if server has skipped some values.\r\n                    checkResolutionSteps(dataObject.timeValuePairs, taskDef.resolution);\r\n                    _.each(dataObject.timeValuePairs, function(timeValuePair) {\r\n                        // This object is inserted into the cache as the actual data cache block.\r\n                        // Notice, cache block have references to the same objects which means some redundancy.\r\n                        // But, this way required data is always available when data is requested from the cache.\r\n                        var cacheBlock = {\r\n                            info : data.info,\r\n                            properties : data.properties,\r\n                            locationInfo : location.info,\r\n                            blockProperty : dataObject.property,\r\n                            timeValuePair : timeValuePair\r\n                        };\r\n                        converted.data[locationName][keyRequestParameter].push(cacheBlock);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        return converted;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Convert sites data received from the cache to the structure that is provided through API.\r\n     *\r\n     * This data has been set in {convertSitesDataFromParserForCache} function for the cache.\r\n     *\r\n     * @param {Object} taskDef Definition object to describe cache blocks of the operation.\r\n     *                         May be {undefined} or {null}.\r\n     * @param {Object} data Parsed data from cache. May be {undefined} or {null}.\r\n     * @param {Array} errors Errors that have occurred during loading, parsing and caching data.\r\n     *                       May be {undefined} or {null}.\r\n     * @return {Object} Object that contains converted errors and converted data.\r\n     */\r\n    function convertSitesDataFromCacheForApi(taskDef, data, errors) {\r\n        var converted = {\r\n            // Data is converted below into the data object if data is available.\r\n            data : data ? {\r\n                info : undefined,\r\n                properties : undefined,\r\n                locations : []\r\n            } : undefined,\r\n            errors : convertCacheErrorsForApi(errors)\r\n        };\r\n        if (data) {\r\n            // Data provided before from parser and set by convertSitesDataFromParserForCache\r\n            // function for the cache is in data.data object. Notice, data is provided as\r\n            // data object hierarchy. Time values that cache has set itself are given as array.\r\n            // Notice, data.data object structure also contains the parsed time values from server.\r\n            // Here, data object contains locations that are identified by the location name key.\r\n            _.each(data.data, function(location) {\r\n                var convertedLocation = {\r\n                    info : undefined,\r\n                    data : {}\r\n                };\r\n                // Location object contains objects that are identified by the request parameters.\r\n                _.each(location, function(container, requestParameterKey) {\r\n                    // Container object for the converted cache block data.\r\n                    var convertedData = {\r\n                        property : undefined,\r\n                        timeValuePairs : []\r\n                    };\r\n\r\n                    // Each container identified by request parameter key contains cache data blocks in an array.\r\n                    _.each(container, function(cacheBlock) {\r\n                        // cacheBlock may be undefined if cache has reserved\r\n                        // more timesteps for certain time range than parser has gotten\r\n                        // for server request. Ignore undefined objects. Notice, that the\r\n                        // correct times from server are still available in timeValuePair\r\n                        // objects. Also, it is better to provide the parsed server data\r\n                        // through API instead of extra undefined objects.\r\n                        if (cacheBlock) {\r\n                            if (!converted.data.info) {\r\n                                // All locations have the same info object.\r\n                                // Therefore, set content if data has not been set before.\r\n                                converted.data.info = cacheBlock.info;\r\n                            }\r\n\r\n                            if (!converted.data.properties) {\r\n                                // All locations have the same properties object.\r\n                                // Therefore, set content if data has not been set before.\r\n                                converted.data.properties = cacheBlock.properties;\r\n                            }\r\n\r\n                            if (!convertedData.property) {\r\n                                // All the blocks of same location refere to the same property info.\r\n                                // Therefore, set the information to the converted data object\r\n                                // if data has not been set before.\r\n                                convertedData.property = cacheBlock.blockProperty;\r\n                            }\r\n\r\n                            if (!convertedLocation.info) {\r\n                                // All the block of same location refere to the same location info.\r\n                                // Therefore, set the information to the converted location object\r\n                                // if data has not been set before.\r\n                                convertedLocation.info = cacheBlock.locationInfo;\r\n                            }\r\n\r\n                            // Insert datablock time-value-pair into the datablock time-value-pair array.\r\n                            convertedData.timeValuePairs.push(cacheBlock.timeValuePair);\r\n                        }\r\n                    });\r\n                    // Insert converted datablock into the location.\r\n                    convertedLocation.data[requestParameterKey] = convertedData;\r\n                });\r\n                // Insert converted location data into converted data locations array.\r\n                converted.data.locations.push(convertedLocation);\r\n            });\r\n        }\r\n        return converted;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * This callback is set for sites cache data fetcher.\r\n     *\r\n     * Parser will provide the fetched and parsed data for this callback.\r\n     * This callback will forward the data in a correct format for the cache.\r\n     *\r\n     * @param {Object} container Object that provides connection instance specific private member variables.\r\n     *                           May not be {undefined} or {null}.\r\n     * @param {Object} taskDef Definition object to describe cache blocks of the operation.\r\n     *                         May not be {undefined} or {null}.\r\n     * @param {function(errors, data)} taskCallback Called with the parsed data and errors array when operation finishes.\r\n     *                                              May not be {undefined} or {null}.\r\n     */\r\n    function cacheSitesDataFetcherCallback(container, taskDef, taskCallback) {\r\n        container.parser.getData({\r\n            url : getUrlString(container.connectionUrl),\r\n            storedQueryId : container.storedQueryId,\r\n            requestParameter : taskDef.parameter,\r\n            begin : taskDef.start,\r\n            end : taskDef.end,\r\n            timestep : taskDef.resolution,\r\n            // If time adjusting is requested, it has been done before giving times to cache.\r\n            // Therefore, do not let parser do adjusting.\r\n            denyTimeAdjusting : true,\r\n            // Notice, instead of using taskDef.location for properties here,\r\n            // specific location related properties are used.\r\n            geoid : taskDef.geoid,\r\n            wmo : taskDef.wmo,\r\n            fmisid : taskDef.fmisid,\r\n            sites : taskDef.sites,\r\n            crs : taskDef.crs,\r\n            queryExtension : taskDef.queryExtension,\r\n            callback : function(data, errors) {\r\n                // Forward callback to the cache.\r\n                // Cache will forward the callback to callbacks given through the API when the retrieve flow has been started.\r\n                var converted = convertSitesDataFromParserForCache.call(container, taskDef, data, errors);\r\n                taskCallback(converted.errors, converted.data);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Request cache to retrive sites data.\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * Notice, this flow will also continue\r\n     * to data fetcher callback if parser should be used to retrieve data\r\n     * from the server. The callback function is set for cache when it is\r\n     * initialized. Callbacks given and set in this function are called when\r\n     * the data is gotten either from the server or directly from the cache.\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var retrieveSitesData = function(options) {\r\n\r\n        var that = this;\r\n\r\n        if (!options.timestep || options.timestep === 1) {\r\n            // Cache requires that timestep is the actual timestep that is used for data.\r\n            // But, in speacial cases server may use magic numbers to handle data differently.\r\n            // Cache can not be used with the given options. Therefore, use parser directly.\r\n\r\n            that.parser.getData({\r\n                url : getUrlString(that.connectionUrl),\r\n                storedQueryId : that.storedQueryId,\r\n                requestParameter : options.requestParameter,\r\n                begin : options.begin,\r\n                end : options.end,\r\n                timestep : options.timestep,\r\n                // When parser is used directly, it can handle time adjusting automatically if requested.\r\n                denyTimeAdjusting : options.denyTimeAdjusting,\r\n                geoid : trimProperty(options.geoid),\r\n                wmo : trimProperty(options.wmo),\r\n                fmisid : trimProperty(options.fmisid),\r\n                sites : trimSites(options.sites),\r\n                crs : options.crs,\r\n                queryExtension : options.queryExtension,\r\n                callback : options.callback\r\n            });\r\n\r\n        } else {\r\n            // Use cache for sites data.\r\n            // If time adjusting is requested, it is done before values are given for the cache.\r\n            var beginDate = options.begin;\r\n            var endDate = options.end;\r\n            var resolution = options.timestep;\r\n            if (!options.denyTimeAdjusting) {\r\n                beginDate = that.parser.adjustBeginTime(resolution, beginDate);\r\n                endDate = that.parser.adjustEndTime(resolution, endDate, beginDate);\r\n            }\r\n            var taskDef = {\r\n                service : DATA_FETCHER_NAME_SITES,\r\n                parameter : _.isString(options.requestParameter) ? options.requestParameter.split(PARAMETER_SEPARATOR) : options.requestParameter,\r\n                // Make sure parameter(s) are integers instead of Date objects when they are given to cache.\r\n                start : beginDate instanceof Date ? beginDate.getTime() : beginDate,\r\n                end : endDate instanceof Date ? endDate.getTime() : endDate,\r\n                resolution : resolution,\r\n                crs : options.crs,\r\n                queryExtension : options.queryExtension\r\n            };\r\n            // Because locations can be given in multiple ways, location related properties are\r\n            // set separately for taskDef to combine all location informations for cache.\r\n            setTaskDefLocations(taskDef, options);\r\n            this.cache.fetch(taskDef, function(errors, result) {\r\n                var converted = convertSitesDataFromCacheForApi(taskDef, result, errors);\r\n                options.callback(converted.data, converted.errors);\r\n            }, options.progressCallback);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Request parser directly to retrive spatial data.\r\n     *\r\n     * Notice, cache is not used for spatial data.\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * Notice, this flow will also continue\r\n     * to data fetcher callback if parser should be used to retrieve data\r\n     * from the server. The callback function is set for cache when it is\r\n     * initialized. Callbacks given and set in this function are called when\r\n     * the data is gotten either from the server or directly from the cache.\r\n     *\r\n     */\r\n    var retrieveSpatialData = function(options) {\r\n        var that = this;\r\n        that.parser.getData({\r\n            url : getUrlString(that.connectionUrl),\r\n            storedQueryId : that.storedQueryId,\r\n            requestParameter : options.requestParameter,\r\n            begin : options.begin,\r\n            end : options.end,\r\n            timestep : options.timestep,\r\n            // When parser is used directly, it can handle time adjusting automatically if requested.\r\n            denyTimeAdjusting : options.denyTimeAdjusting,\r\n            // Include also other sites related options if they are given.\r\n            // But, bbox is the reason that all data is provided directly for the parser.\r\n            geoid : trimProperty(options.geoid),\r\n            wmo : trimProperty(options.wmo),\r\n            fmisid : trimProperty(options.fmisid),\r\n            sites : trimSites(options.sites),\r\n            bbox : options.bbox,\r\n            crs : options.crs,\r\n            latlon : options.latlon,\r\n            queryExtension : options.queryExtension,\r\n            callback : options.callback\r\n        });\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Wraps the function calls inside try-catch before calling.\r\n     *\r\n     * Instead of using multiple try catches in many functions only one is used here.\r\n     * This style may improve performance.\r\n     *\r\n     * Notice, this function applies this-reference to the function calls.\r\n     *\r\n     * @param {function} func Function that should be called.\r\n     *                        May not be {undefined} or {null}.\r\n     * @param {function} callback Callback function that is called if an exception occurs\r\n     *                            during this synchronous part of the flow. Notice, this\r\n     *                            is a callback that may be provided for asynchronous flow.\r\n     *                            May be {undefined} or {null}.\r\n     * @return {boolean} {true} if operation starts successfully. Else {false}.\r\n     *                          Notice, if {callback} is given, it is also called\r\n     *                          if false is returned for success.\r\n     */\r\n    var makeSafe = function(func, callback) {\r\n        var success = true;\r\n        try {\r\n            // Call the correct function with the original arguments.\r\n            // Function reference itself is removed from the arguments.\r\n            // Also, callback reference provided for synchronous exception\r\n            // handling is removed from the arguments.\r\n            var args = Array.prototype.slice.call(arguments);\r\n            args.shift();\r\n            args.shift();\r\n            func.apply(this, args);\r\n\r\n        } catch(e) {\r\n            var errorStr = \"ERROR: API level error occurred in a synchronous flow!\";\r\n            if (\"undefined\" !== typeof console && console) {\r\n                console.error(errorStr);console.error(e);\r\n            }\r\n            success = false;\r\n            if (callback) {\r\n                // Inform callback about exception in the flow.\r\n                // Then, caller knows that asynchronous flow has ended.\r\n                var error = {\r\n                    errorText : errorStr\r\n                };\r\n                callback(undefined, error);\r\n            }\r\n        }\r\n        return success;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Get a URL string. If an array of URLs has been set to make use of domain sharding, a random array member is returned.\r\n     *\r\n     */\r\n    var getUrlString = function(urlOption) {\r\n        if(_.isArray(urlOption)){\r\n          return urlOption[ Math.floor( Math.random() * urlOption.length ) ];\r\n        }else{\r\n          return urlOption;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var getUrl = function() {\r\n        return this.connectionUrl;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var getStoredQueryId = function() {\r\n        return this.storedQueryId;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var connect = function(url, storedQueryId) {\r\n        // Skip if already connected.\r\n        // Notice, if already connected, this function does not reconnect\r\n        // even if a new URL would be different than the old one.\r\n        if (!this.connectionUrl) {\r\n            if ((!_.isString(url) && !_.isArray(url)) || !url.length || !url) {\r\n                var urlErrorStr = \"ERROR: WfsConnection URL must be a string or an array and not empty!\";\r\n                if (\"undefined\" !== typeof console && console) {\r\n                    console.error(urlErrorStr);\r\n                }\r\n                throw urlErrorStr;\r\n            }\r\n            if (!_.isString(storedQueryId) || !storedQueryId) {\r\n                var idErrorStr = \"ERROR: WfsConnection stored query ID must be a string and not empty!\";\r\n                if (\"undefined\" !== typeof console && console) {\r\n                    console.error(idErrorStr);\r\n                }\r\n                throw idErrorStr;\r\n            }\r\n            this.connectionUrl = url;\r\n            this.storedQueryId = storedQueryId;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var disconnect = function() {\r\n        this.connectionUrl = undefined;\r\n        this.storedQueryId = undefined;\r\n        resetCache.call(this);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Notice, this function should be called in the context of the private object of the WfsConnection instance.\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var resetCache = function() {\r\n        this.cache.clearCache();\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * See API for function description.\r\n     */\r\n    var getData = function(options) {\r\n        if (options) {\r\n            if (options.bbox || options.latlon) {\r\n                // BBox nor LatLon are not supported by the cache at the moment.\r\n                // Therefore, pass the whole query to the parser.\r\n                retrieveSpatialData.call(this, options);\r\n\r\n            } else if (options.geoid || options.wmo || options.fmisid || options.sites) {\r\n                retrieveSitesData.call(this, options);\r\n\r\n            } else {\r\n                var errorStr = \"ERROR: Either geoid, wmo, fmisid, sites, bbox or latlon is mandatory in options!\";\r\n                if (\"undefined\" !== typeof console && console) {\r\n                    console.error(errorStr);\r\n                }\r\n                throw errorStr;\r\n            }\r\n\r\n        } else {\r\n            var optionsErrorStr = \"ERROR: Options object is mandatory!\";\r\n            if (\"undefined\" !== typeof console && console) {\r\n                console.error(optionsErrorStr);\r\n            }\r\n            throw optionsErrorStr;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Constructor for the connection instance.\r\n     *\r\n     * Notice, this constructor is returned from {WfsConnection}\r\n     * and can be used for instantiation later.\r\n     */\r\n     var connectionConstructor = function(splitterCacheConfig) {\r\n\r\n        // Reference to the connection instance object.\r\n        var that = this;\r\n\r\n        // {SplitterCache} configuration\r\n        splitterCacheConfig = splitterCacheConfig || {\r\n            sideFetchAfterFactor : 1,\r\n            sideFetchBeforeFactor : 0.5,\r\n            maxBlockDataPoints : 200,\r\n            maxCacheDataSize : 4000\r\n        };\r\n\r\n        // Private object is used for API functions to provide them private member variables.\r\n        // Instance specific data is available for API functions when reference to this private\r\n        // object is applied to the function calls by using this private object. Then, these\r\n        // variables and functions are capsulated and are not available outside of the connection\r\n        // instance.\r\n        this._private = {\r\n            // Reference to the connection instance object.\r\n            connectionInstance : that,\r\n\r\n            // Member variables that are initialized to undefined.\r\n            // When connection function is called these are set.\r\n            connectionUrl : undefined,\r\n            storedQueryId : undefined,\r\n\r\n            // Member variables that are initialized to values that are used\r\n            // throughout the lifetime of object instance.\r\n\r\n            // Cache for retrieved data.\r\n            cache : new SplitterCache(splitterCacheConfig),\r\n\r\n            parser : new WfsRequestParser()\r\n        };\r\n\r\n        //=================================================================\r\n        // Public WfsConnection API is defined here as priviledged functions.\r\n        //=================================================================\r\n\r\n        /**\r\n         * Synchronous.\r\n         *\r\n         * @return {String} URL that is used for the connection and\r\n         *                  has been set when {connect} function is called.\r\n         *                  May be {undefined} if state is not connected.\r\n         */\r\n        this.getUrl = function() {\r\n            return getUrl.call(this._private);\r\n        };\r\n\r\n        /**\r\n         * Synchronous.\r\n         *\r\n         * @return {String} Stored query ID that is used for the connection\r\n         *                  and has been set when {connect} function is called.\r\n         *                  May be {undefined} if state is not connected.\r\n         */\r\n        this.getStoredQueryId = function() {\r\n            return getStoredQueryId.call(this._private);\r\n        };\r\n\r\n        /**\r\n         * Synchronous.\r\n         *\r\n         * Notice, if already connected, this function does not reconnect\r\n         * even if a new URL would be different than the old one.\r\n         *\r\n         * @param {String} url URL that is used for the connection.\r\n         *                     May not be {undefined}, {null} or empty.\r\n         * @param {String} storedQueryId Stored query ID to identify the data that is requested.\r\n         *                               For example, stored query ID may be used to request\r\n         *                               observed data or forecast data.\r\n         *                               May not be {undefined}, {null} or empty.\r\n         * @return {boolean} {true} if synchronous operation was successfull. Else {false}.\r\n         */\r\n        this.connect = function(url, storedQueryId) {\r\n\r\n            var that = this;\r\n            // Set data fetcher that cache uses for the given type of the data.\r\n            this._private.cache.addDataProvider(DATA_FETCHER_NAME_SITES, function(taskDef, callback) {\r\n                cacheSitesDataFetcherCallback(that._private, taskDef, callback);\r\n            });\r\n\r\n            return makeSafe.call(that._private, connect, undefined, url, storedQueryId);\r\n        };\r\n\r\n        /**\r\n         * Synchronous.\r\n         *\r\n         * Releases resources.\r\n         *\r\n         * @return {boolean} {true} if synchronous operation was successfull. Else {false}.\r\n         */\r\n        this.disconnect = function() {\r\n            return makeSafe.call(this._private, disconnect, undefined);\r\n        };\r\n\r\n        /**\r\n         * Synchronous.\r\n         *\r\n         * Releases cache resources.\r\n         *\r\n         * @return {boolean} {true} if synchronous operation was successfull. Else {false}.\r\n         */\r\n        this.resetCache = function() {\r\n            return makeSafe.call(this._private, resetCache, undefined);\r\n        };\r\n\r\n        /**\r\n         * Request data.\r\n         *\r\n         * Operation is asynchronous.\r\n         *\r\n         * Notice, callback is {function(data, errors){}}.\r\n         *      - data: Data object provides locations data.\r\n         *              May be {undefined} if an error has occurred.\r\n         *              The object is of this structure:\r\n         *          {\r\n         *              // General information received in the server response for the request.\r\n         *              // May not be {undefined} or {null}.\r\n         *              // Content properties are set if given in the server response.\r\n         *              info : {\r\n         *                  begin : {Date|undefined},\r\n         *                  end : {Date|undefined}\r\n         *              },\r\n         *              // Properties provide descriptive property objects that correspond to\r\n         *              // the parameter keys that have been given for the request. Notice,\r\n         *              // property data is also available inside locations data objects.\r\n         *              // This object is provided as a complementary object, if reference to a single\r\n         *              // wrapper object is later needed for general information about properties.\r\n         *              properties : {\r\n         *                  parameterAsKey : { label : \"labelString\",\r\n         *                                     unit : \"measurementUnitString\",\r\n         *                                     phenomenon : \"phenomenonString\",\r\n         *                                     statisticalFunction : \"statisticalFunctionString\",\r\n         *                                     statisticalPeriod : \"statisticalAggregationTimePeriod\" },\r\n         *                  ...\r\n         *              },\r\n         *              // Data of locations. May be empty if sites data is not provided.\r\n         *              // May not be {undefined} or {null}.\r\n         *              locations : [\r\n         *                  {\r\n         *                      info : {\r\n         *                          id : \"location id string\",\r\n         *                          geoid : \"geoid string\",\r\n         *                          wmo : \"wmo string\",\r\n         *                          fmisid : \"fmisid string\",\r\n         *                          name : \"location name string\",\r\n         *                          region : \"region name string\",\r\n         *                          country : \"country name string\",\r\n         *                          timezone : \"timezone name string\",\r\n         *                          position : [ \"positionStringPart1\", \"positionStringPart2\", ... ]\r\n         *                      },\r\n         *                      data : {\r\n         *                          // Data property keys correspond to the parameter keys\r\n         *                          // that have been given for the request.\r\n         *                          parameterAsKey : {\r\n         *                            property : { label : \"labelString\",\r\n         *                                         unit : \"measurementUnitString\",\r\n         *                                         phenomenon : \"phenomenonString\",\r\n         *                                         statisticalFunction : \"statisticalFunctionString\",\r\n         *                                         statisticalPeriod : \"statisticalAggregationTimePeriod\" },\r\n         *                            timeValuePairs : [ { time : intTimeInMsSince01011970,\r\n         *                                                 value : floatMeasurementValue }, ... ]\r\n         *                          },\r\n         *                          ...\r\n         *                      }\r\n         *                  },\r\n         *                  ...\r\n         *              ]\r\n         *          }\r\n         *      - errors: Array that contains possible errors that occurred during the flow. Array is\r\n         *                always provided even if it may be empty. If an error occurs in this parser,\r\n         *                an error string is pushed here. Also, when an HTTP error occurs, error contains\r\n         *                the textual portion of the HTTP status, such as \"Not Found\" or \"Internal Server Error.\"\r\n         *                Errors parameter is of this structure:\r\n         *          [\r\n         *              {\r\n         *                  // None, one, or more of the following error values may exist.\r\n         *                  // Values may also be {undefined} or {null}.\r\n         *                  errorCode : \"errorCodeString\",\r\n         *                  errorText : \"errorTextString\",\r\n         *                  extension : {Object}\r\n         *              },\r\n         *              ...\r\n         *          ]\r\n         *\r\n         * Notice, object properties of the function {options} parameter are URL encoded by this library\r\n         * before they are inserted into the request URL.\r\n         *\r\n         * @param {Object} options Mandatory. May not be {undefined} or {null}. Object structure:\r\n         *     {\r\n         *         requestParameter : {String|Array(String)}\r\n         *                            Mandatory property. May not be {undefined} or {null}. Array may not be empty.\r\n         *                            This is one of the parameter strings that is part of\r\n         *                            URL parameters to define which data is requested from the server.\r\n         *                            Parameter string may contain request for multiple parameters.\r\n         *                            For example, value for dew point temperature may be \"td\".\r\n         *                            If an array is given, strings are given as separate array string items.\r\n         *         begin : {int|Date}\r\n         *                 Mandatory property. May not be {undefined} or {null}.\r\n         *                 The begin time for the data.\r\n         *                 Integer value is number of milliseconds since 01.01.1970 that can be gotten,\r\n         *                 for example, with {Date::getTime()}. Alternatively, {Date} object may be given.\r\n         *         end : {int|Date}\r\n         *               Mandatory property. May not be {undefined} or {null}.\r\n         *               The end time for the data.\r\n         *               Value is number of milliseconds since 01.01.1970 that can be gotten,\r\n         *               for example, with {Date::getTime()}. Alternatively, {Date} object may be given.\r\n         *         timestep : {int}\r\n         *                    May be {undefined} or {null}.\r\n         *                    Timestep in milliseconds.\r\n         *                    If {undefined}, {null} or zero, server returns all data for\r\n         *                    the given time interval. If timestep is 1, server uses the default\r\n         *                    timestep. Notice, even if time is in milliseconds here, it is converted\r\n         *                    and floored to minutes before sending for the server.\r\n         *         denyTimeAdjusting : {boolean}\r\n         *                             May be {undefined} or {null}.\r\n         *                             If {true}, {begin} and {end} times are not adjusted for server but given values\r\n         *                             are used exactly for requests. Otherwise, times are adjusted.\r\n         *         geoid : {Array(String|int)|String|int}\r\n         *                 May be {undefined} or {null} or empty if {wmo}, {fmisid}, {sites} or {bbox} is given.\r\n         *                 Array of Geographical name ID (geonames.org) strings or integers.\r\n         *                 One geoid can be given as a single string or integer.\r\n         *                 Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n         *         wmo : {Array(String|int)|String|int}\r\n         *               May be {undefined} or {null} or empty if {geoid}, {fmisid}, {sites} or {bbox} is given.\r\n         *               Array of World Meteorological Organization (WMO) identifier strings or integers.\r\n         *               One wmo can be given as a single string or integer.\r\n         *               Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n         *         fmisid : {Array(String|int)|String|int}\r\n         *                  May be {undefined} or {null} or empty if {geoid}, {wmo}, {sites} or {bbox} is given.\r\n         *                  Array of FMI observation station identifiers (fmisid) strings or integers.\r\n         *                  One fmisid can be given as a single string or integer.\r\n         *                  Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n         *         sites : {Array(String)|String}\r\n         *                 May be {undefined} or {null} or empty if {geoid}, {wmo}, {fmisid} or {bbox} is given.\r\n         *                 Array of site name strings. One site can be given as a single string.\r\n         *                 Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n         *         bbox : {String}\r\n         *                May be {undefined}, {null} or empty if {geoid}, {wmo}, {fmisid} or {sites} is given.\r\n         *                BBOX string. Notice, either {geoid}, {wmo}, {fmisid}, {sites} or {bbox} is required.\r\n         *                Notice, cache is not used if spatial data (bbox) is queried.\r\n         *         crs : {String}\r\n         *               May be {undefined}, {null} or empty.\r\n         *               Coordinate Reference System (CRS) string.\r\n         *         queryExtension : {Object}\r\n         *                          Optional. May be {undefined} or {null}.\r\n         *                          Property values may be {undefined}, {null} or {string}.\r\n         *                          This property is not needed in normal use cases of the API.\r\n         *                          But, this property may be used if API does not support field-value-pairs\r\n         *                          that need to be included into request URL query. The key-value-pairs of\r\n         *                          the property are URL encoded and included as URL query field-value-pairs\r\n         *                          in the request. If property value is {undefined} or {null}, it is interpreted\r\n         *                          as an empty string. Notice, other API properties should be used instead of this\r\n         *                          extension if possible.\r\n         *         callback : {function(data, errors)}\r\n         *                    Mandatory property. May not be {undefined} or {null}.\r\n         *                    Callback is called with the parsed data and errors array when operation finishes.\r\n         *                    If an error occurs, data is set {undefined} for the callback. Possible errors are\r\n         *                    given inside the array that is always provided.\r\n         *         progressCallback : {function(err, partStart, partEnd)}\r\n         *                            Not mandatory property.\r\n         *                            Called when part of the flow has finished.\r\n         *                            Function is called with {err}, {partStart} and {partEnd} parameters.\r\n         *     }\r\n         * @return {boolean} {true} if asynchronous operation is successfully started. Else {false}.\r\n         */\r\n        this.getData = function(options) {\r\n            return makeSafe.call(this._private, getData, options ? options.callback : undefined, options);\r\n        };\r\n    };\r\n\r\n    // Constructor function is returned for later instantiation.\r\n    return connectionConstructor;\r\n\r\n})();\r\n\r\nmodule.exports = WfsConnection;\r\n"],"mappings":"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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAAC8C,OAAO,GAAG,UAAS5D,OAAO,EAAE;MAC7B,OAAO6F,QAAQ,CAAClB,IAAI,CAAC,IAAI,CAACiD,QAAQ,EAAEhE,OAAO,EAAE5D,OAAO,GAAGA,OAAO,CAAC0E,QAAQ,GAAG5D,SAAS,EAAEd,OAAO,CAAC;IACjG,CAAC;EACL,CAAC;;EAED;EACA,OAAOsH,qBAAqB;AAEhC,CAAC,CAAE,CAAC;AAEJS,MAAM,CAACC,OAAO,GAAG5J,aAAa","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}