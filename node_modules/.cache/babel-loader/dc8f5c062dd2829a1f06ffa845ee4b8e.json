{"ast":null,"code":"/**\n * Metolib.SplitterCache\n * =======================================\n *\n * See https://github.com/fmidev/metolib/wiki/SplitterCache for documentation.\n *\n * Requires:\n * - async.js (https://github.com/caolan/async)\n * - lodash.underscore.js (http://lodash.com/)\n *\n * Original author: Ilkka Rinne / Spatineo Inc. for the Finnish Meteorological Institute\n *\n *\n * This software may be freely distributed and used under the following MIT license:\n *\n * Copyright (c) 2017 Finnish Meteorological Institute\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the\n * Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\n// Strict mode for whole file.\n\"use strict\"; // Requires lodash, async\n\nvar _ = require('lodash');\n\nvar async = require('async'); // import _ from 'lodash';\n// import async from 'async';\n\n\nvar SplitterCache = function () {\n  //Functions and variables shared with all instances:\n  var checkTaskDef = function (taskDef) {\n    var placeholder;\n    var startNudge = 0;\n    var endNudge = 0;\n\n    if (!_.isObject(taskDef)) {\n      throw 'taskdef must be an object';\n    }\n\n    if (!_.isString(taskDef.service)) {\n      throw 'taskDef must contain a \\'service\\' property of string type';\n    }\n\n    if (!_.isArray(taskDef.location)) {\n      if (!_.isString(taskDef.location)) {\n        throw 'taskDef must contain a \\'location\\' property of either an array or a string type';\n      } else {\n        placeholder = taskDef.location;\n        taskDef.location = [];\n        taskDef.location.push(placeholder);\n      }\n    }\n\n    if (!_.isArray(taskDef.parameter)) {\n      if (!_.isString(taskDef.parameter)) {\n        throw 'taskDef must contain a \\'parameter\\' property of either an array or a string type';\n      } else {\n        placeholder = taskDef.parameter;\n        taskDef.parameter = [];\n        taskDef.parameter.push(placeholder);\n      }\n    }\n\n    if (!_.isNumber(taskDef.resolution)) {\n      throw 'taskDef must contain a \\'resolution\\' property of numeric type';\n    } else if (taskDef.resolution > 0.5) {\n      taskDef.resolution = Math.round(taskDef.resolution);\n    } else {\n      throw 'taskDef.resolution must be a positive integer';\n    }\n\n    if (!_.isNumber(taskDef.start)) {\n      throw 'taskDef must contain a \\'start\\' property of numeric type';\n    }\n\n    if (_.isNumber(taskDef.pointCount)) {\n      if (taskDef.pointCount > 0) {\n        taskDef.end = taskDef.start + (taskDef.pointCount - 1) * taskDef.resolution;\n      } else {\n        throw 'taskDef.pointCount must be greater than zero';\n      }\n    } else if (_.isNumber(taskDef.end)) {\n      if (taskDef.end < taskDef.start) {\n        throw '\\'end\\' must be greater than or equal to \\'start\\'';\n      }\n\n      endNudge = (taskDef.end - taskDef.start) % taskDef.resolution;\n\n      if (endNudge !== 0) {\n        taskDef.end = taskDef.end + (taskDef.resolution - endNudge);\n      }\n\n      taskDef.pointCount = (taskDef.end - taskDef.start) / taskDef.resolution + 1;\n    } else {\n      throw 'taskDef must contain either \\'end\\' or \\'pointCount\\' property of numeric type';\n    }\n  };\n\n  var arrayEqualsAnyOrder = function (arr1, arr2) {\n    var i = 0;\n\n    if (_.isArray(arr1) && _.isArray(arr2)) {\n      if (arr1.length === arr2.length) {\n        for (i = 0; i < arr1.length; i++) {\n          if (_.indexOf(arr2, arr1[i]) === -1) {\n            return false;\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    } else if (arr1 === undefined || arr1 === null || arr2 === undefined || arr2 === null) {\n      return false;\n    } else {\n      return arr1 === arr2;\n    }\n  };\n  /**\n   * DataBlock constructor\n   *\n   * DataBlock is provided as an internal class.\n   * DataBlock instances are created internally by the cache object.\n   */\n\n\n  var DataBlock = function () {\n    var blockCounter = 0;\n\n    var _constructor = function DataBlock(evtDispatcher) {\n      var id = null;\n      var fetchError = null;\n      var fetcher = null;\n      var data = null;\n      var taskDef = null;\n      var age = 0;\n      var fetching = false;\n      var fetched = false;\n      var pinCount = 0;\n      var waitingRecycling = false;\n      var waitingMerging = false;\n      var ready = false;\n      var callbacks = [];\n      var requestId = 0;\n      var dispatcher = evtDispatcher;\n      var thisBlock = this; //Private functions:\n\n      function reset() {\n        fetchError = null;\n        fetcher = null;\n        data = null;\n        taskDef = null;\n        age = 0;\n        fetching = false;\n        fetched = false;\n        pinCount = 0;\n        waitingRecycling = false;\n        waitingMerging = false;\n        ready = false;\n        callbacks = [];\n      } //Privileged functions:\n\n\n      this.getId = function () {\n        return id;\n      };\n\n      this.getTaskDef = function () {\n        return taskDef;\n      };\n\n      this.getStart = function () {\n        return taskDef !== null ? taskDef.start : undefined;\n      };\n\n      this.getEnd = function () {\n        return taskDef !== null ? taskDef.end : undefined;\n      };\n\n      this.getPointCount = function () {\n        return taskDef !== null ? taskDef.pointCount : undefined;\n      };\n\n      this.getResolution = function () {\n        return taskDef !== null ? taskDef.resolution : undefined;\n      };\n\n      this.getService = function () {\n        return taskDef !== null ? taskDef.service : undefined;\n      };\n\n      this.getLocation = function () {\n        return taskDef !== null ? taskDef.location : undefined;\n      };\n\n      this.getParameter = function () {\n        return taskDef !== null ? taskDef.parameter : undefined;\n      };\n\n      this.getDataSize = function () {\n        return taskDef !== null ? taskDef.pointCount * taskDef.parameter.length * taskDef.location.length : 0;\n      };\n\n      this.pin = function () {\n        if (!waitingRecycling) {\n          pinCount++;\n\n          if (dispatcher) {\n            dispatcher('blockPinned', thisBlock);\n          }\n\n          return pinCount;\n        } else {\n          return null;\n        }\n      };\n\n      this.unpin = function () {\n        if (pinCount > 0) {\n          pinCount--;\n\n          if (dispatcher) {\n            dispatcher('blockUnpinned', thisBlock);\n          }\n        }\n\n        return pinCount;\n      };\n\n      this.isPinned = function () {\n        return pinCount > 0;\n      };\n\n      this.getPinCount = function () {\n        return pinCount;\n      };\n\n      this.getRequestId = function () {\n        return requestId;\n      };\n\n      this.isWaitingRecycling = function () {\n        return waitingRecycling;\n      };\n\n      this.isWaitingMerging = function () {\n        return waitingMerging;\n      };\n\n      this.isFetched = function () {\n        return fetched;\n      };\n\n      this.setFetched = function (f) {\n        if (f === true) {\n          fetched = true;\n        } else {\n          fetched = false;\n        }\n      };\n\n      this.isFetching = function () {\n        return fetching;\n      };\n\n      this.setFetching = function (f) {\n        if (f === true) {\n          fetching = true;\n        } else {\n          fetching = false;\n        }\n      };\n\n      this.increaseNotUsed = function () {\n        age++;\n\n        if (dispatcher) {\n          dispatcher('blockAged', thisBlock);\n        }\n      };\n\n      this.getNotUsedSince = function () {\n        return age;\n      };\n\n      this.fetchFailed = function () {\n        return fetchError !== null;\n      };\n\n      this.markForRecycling = function () {\n        waitingRecycling = true;\n\n        if (dispatcher) {\n          dispatcher('blockEvicted', thisBlock);\n        }\n      };\n\n      this.markForMerging = function (merge) {\n        if (merge === true) {\n          waitingMerging = true;\n\n          if (dispatcher) {\n            dispatcher('blockMarkedForMerge', thisBlock);\n          }\n        } else {\n          waitingMerging = false;\n\n          if (dispatcher) {\n            dispatcher('blockMergeCancelled', thisBlock);\n          }\n        }\n      };\n\n      this.setData = function (d) {\n        data = d;\n      };\n\n      this.getFetcher = function () {\n        return fetcher;\n      };\n\n      this.recycle = function () {\n        reset();\n\n        if (dispatcher) {\n          dispatcher('blockRecycled', thisBlock);\n        }\n      };\n      /**\n       * TaskDef: {\n       *          service,\n       *          parameter,\n       *          location,\n       *          start,\n       *          resolution,\n       *          pointCount\n       * }\n       */\n\n\n      this.prepare = function (taskDefinition, dataFetcher) {\n        if (!_.isFunction(dataFetcher)) {\n          throw 'fetcher must be a function';\n        }\n\n        checkTaskDef(taskDefinition);\n        reset();\n        taskDef = taskDefinition;\n        fetcher = dataFetcher;\n        ready = true;\n        requestId++;\n\n        if (dispatcher) {\n          dispatcher('blockPrepared', thisBlock);\n        }\n      };\n      /**\n       * @param callback {function(err,data)}\n       */\n\n\n      this.getDataAsync = function (callback) {\n        var that = this;\n\n        if (!ready) {\n          throw 'Cannot getData in unprepared state, call prepare first';\n        }\n\n        age = 0;\n\n        if (!fetched) {\n          if (callback !== undefined && _.isFunction(callback)) {\n            callbacks.push(callback);\n          }\n\n          if (!fetching) {\n            fetching = true;\n            fetcher(taskDef, function (err, result) {\n              var reqId = that.getRequestId();\n\n              if (err) {\n                fetchError = err;\n              }\n\n              data = result;\n              fetched = true;\n\n              if (callbacks.length === 0) {\n                fetching = false;\n              } else {\n                async.whilst(function () {\n                  var myReqId = that.getRequestId(); //We may still be looping here when this block has been recycled, re-prepared and fetching for the next request.\n                  //So need to check if the request has not changed and we still have callbacks.\n                  //The callbacks for the next request will still be looped through when the time is right.\n\n                  return reqId === myReqId && callbacks.length > 0;\n                }, function (notify) {\n                  try {\n                    var cb = callbacks.pop();\n                    cb.call(that, fetchError, data);\n                  } catch (ex) {\n                    if (\"undefined\" !== typeof console && console) {\n                      console.error('Error in block finished callback:' + ex.message);\n                    }\n                  } finally {\n                    notify();\n                    fetching = false;\n                  }\n                }, function (err) {//NOOP\n                });\n              }\n\n              if (dispatcher) {\n                dispatcher('blockProviderFetchFinished', thisBlock);\n              }\n            });\n\n            if (dispatcher) {\n              dispatcher('blockProviderFetchStarted', thisBlock);\n            }\n          }\n        } else {\n          if (_.isFunction(callback)) {\n            _.defer(function (err, d) {\n              if (dispatcher) {\n                dispatcher('blockCacheFetchFinished', thisBlock);\n              }\n\n              callback(err, d);\n            }, fetchError, data);\n\n            if (dispatcher) {\n              dispatcher('blockCacheFetchStarted', thisBlock);\n            }\n          } else {}\n        }\n      }; //Instance initialization:\n\n\n      id = 'id#' + blockCounter++;\n\n      if (dispatcher) {\n        dispatcher('blockCreated', thisBlock);\n      }\n    };\n\n    return _constructor;\n  }();\n\n  var eventListenerIdCounter = 0;\n  var fetcherIdCounter = 0;\n  /**\n   * SplitterCache constructor\n   *\n   * Constructor contains priviledged methods that are provided as API functions\n   * for the instantiated cache object.\n   */\n\n  var _constructor = function SplitterCache(properties) {\n    var emptyBlockPool = [];\n    var cachedBlocks = [];\n    var mergedBlocks = [];\n    var stepResolutions = [];\n    var sideFetchBeforeFactor = 0.5;\n    var sideFetchAfterFactor = 1;\n    var maxBlockDataPoints = 500;\n    var minBlockDataPoints = 20;\n    var maxCacheDataSize = 50000;\n    var strictErrorHandling = true;\n    var errorFillValue = NaN;\n    var fetchers = {};\n    var cachedDataSize = 0;\n    var cacheHits = 0;\n    var cacheMisses = 0;\n    var thisCache = this;\n    var eventListeners = {\n      blockCreated: {},\n      blockPrepared: {},\n      blockProviderFetchStarted: {},\n      blockProviderFetchFinished: {},\n      blockCacheFetchStarted: {},\n      blockCacheFetchFinished: {},\n      blockPinned: {},\n      blockUnpinned: {},\n      blockEvicted: {},\n      blockRecycled: {},\n      blockAged: {},\n      blockMarkedForMerge: {},\n      blockMergeCancelled: {},\n      evictStarted: {},\n      evictFinished: {},\n      fetchStarted: {},\n      fetchFinished: {},\n      cacheCleared: {},\n      dataProviderAdded: {},\n      dataProviderRemoved: {}\n    }; //Private functions:\n    //Event handling:\n\n    function fireEvent(eventName, eventData) {\n      if (eventListeners[eventName] !== undefined) {\n        _.each(eventListeners[eventName], function (cb) {\n          try {\n            cb.call(thisCache, eventData);\n          } catch (ex) {}\n        });\n      }\n    }\n\n    function addEventListener(eventName, cb) {\n      var listenerId = null;\n\n      if (eventListeners[eventName] !== undefined) {\n        if (_.isFunction(cb)) {\n          listenerId = 'id' + eventListenerIdCounter++;\n          eventListeners[eventName][listenerId] = cb;\n        } else {\n          throw 'Event listener callback is not a function';\n        }\n      } else {\n        throw 'Unknown event \\'' + eventName + '\\', use one of ' + _.reduce(_.keys(eventListeners), function (memo, name, ind) {\n          if (ind > 0) {\n            memo = memo + ', ';\n          }\n\n          memo = memo + name;\n          return memo;\n        });\n      }\n\n      return listenerId;\n    }\n\n    function removeEventListener(eventName, listenerId) {\n      if (eventListeners[eventName] !== undefined) {\n        if (eventListeners[eventName][listenerId] !== undefined) {\n          delete eventListeners[eventName][listenerId];\n        }\n      } else {\n        throw 'Unknown event \\'' + eventName + '\\', use one of ' + _.reduce(_.keys(eventListeners), function (memo, name, ind) {\n          if (ind > 0) {\n            memo = memo + ', ';\n          }\n\n          memo = memo + name;\n        });\n      }\n    }\n\n    function evict(evictList) {\n      async.each(evictList, function (toEvict, notify) {\n        toEvict.markForRecycling();\n        notify();\n      }, function (err) {\n        if (err && \"undefined\" !== typeof console && console) {\n          console.error(err);\n        }\n      });\n    }\n\n    function mergeBlocks(block1, block2, callback) {\n      var newBlock = null;\n      var taskDef = {};\n      var combinedData = [];\n\n      if (block1.pin() > 0 && block2.pin() > 0) {\n        block1.markForMerging(true);\n        block2.markForMerging(true);\n        newBlock = getDataBlock();\n        taskDef = _.clone(block1.getTaskDef());\n        taskDef.end = block2.getEnd();\n        taskDef.pointCount = block1.getPointCount() + block2.getPointCount();\n        newBlock.prepare(taskDef, block1.getFetcher());\n        newBlock.setFetching(true);\n        fireEvent('blockCacheFetchStarted', newBlock);\n        async.parallel({\n          data1: function (cb) {\n            block1.getDataAsync(function (err, data) {\n              if (err) {\n                if (\"undefined\" !== typeof console && console) {\n                  console.log('Warning: getDataAsync from merged block1 returned error:\\'' + err + '\\'');\n                }\n\n                cb(err);\n              } else {\n                fillWith(combinedData, data, taskDef.location, taskDef.parameter, 0, 0, block1.getPointCount(), cb);\n              }\n            });\n          },\n          data2: function (cb) {\n            block2.getDataAsync(function (err, data) {\n              if (err) {\n                if (\"undefined\" !== typeof console && console) {\n                  console.log('Warning: getDataAsync from merged block2 returned error:\\'' + err + '\\'');\n                }\n\n                cb(err);\n              } else {\n                fillWith(combinedData, data, taskDef.location, taskDef.parameter, block1.getPointCount(), 0, block2.getPointCount(), cb);\n              }\n            });\n          }\n        }, function (err, results) {\n          block1.unpin();\n          block2.unpin();\n\n          if (!err) {\n            block1.markForRecycling();\n            block2.markForRecycling();\n            newBlock.setData(combinedData);\n            newBlock.setFetching(false);\n            newBlock.setFetched(true);\n            callback(null, newBlock);\n            fireEvent('blockCacheFetchFinished', newBlock);\n          } else {\n            newBlock.reset();\n            block1.markForMerging(false);\n            block2.markForMerging(false);\n            callback(err);\n            fireEvent('blockCacheFetchFinished', null);\n          }\n        });\n      } else {\n        _.defer(function () {\n          callback(new Error('One or both blocks already marked for recycling'));\n        });\n      }\n    }\n\n    function blocksAreContinuous(block1, block2) {\n      if (block1.getResolution() === block2.getResolution() && block2.getStart() === block1.getEnd() + block1.getResolution()) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function shouldBlocksBeMerged(block1, block2) {\n      //It's assumed that service, location and parameter equality has already been checked:\n      if (!block1.fetchFailed() && !block2.fetchFailed() && !block1.isWaitingMerging() && !block2.isWaitingMerging() && (block1.getPointCount() < minBlockDataPoints || block2.getPointCount() < minBlockDataPoints) && blocksAreContinuous(block1, block2) && block1.getPointCount() + block2.getPointCount() < maxBlockDataPoints) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function getDataBlock() {\n      var dataBlock;\n\n      if (emptyBlockPool.length > 0) {\n        dataBlock = emptyBlockPool.pop();\n      } else {\n        dataBlock = new DataBlock(fireEvent);\n      }\n\n      return dataBlock;\n    }\n\n    function blockOverlaps(blockStart, blockEnd, start, end) {\n      var retval = false; //exactly matching steps:\n\n      if (blockStart === start && blockEnd === end) {\n        retval = true;\n      } //overlapping steps:\n      else if (blockStart <= end && blockEnd > start) {\n          retval = true;\n        }\n\n      return retval;\n    }\n\n    function createMissingBlocksBefore(prevBlockEnd, blockStart, fetchStart, fetchEnd, taskDef) {\n      var retval = null; //if at first block or we've just crossed a gap in steps between cached data blocks:\n\n      if (prevBlockEnd === null || prevBlockEnd < blockStart - taskDef.resolution) {\n        //The current block starts after our interesting step sequence starts:\n        if (blockStart > fetchStart) {\n          //the current block starts after or at the same step as our interesting step sequence ends:\n          if (blockStart >= fetchEnd) {\n            //create new blocks until the end of our interesting step sequence:\n            if (prevBlockEnd === null) {\n              retval = allocateAndPrepareContinuousBlocks(taskDef, fetchStart, fetchEnd);\n            } else {\n              retval = allocateAndPrepareContinuousBlocks(taskDef, Math.max(prevBlockEnd, fetchStart), fetchEnd);\n            }\n          } //current block starts before our interesting step sequence ends:\n          else {\n              //create new blocks until one step before the start of the current block:\n              if (prevBlockEnd === null) {\n                retval = allocateAndPrepareContinuousBlocks(taskDef, fetchStart, blockStart - taskDef.resolution);\n              } else {\n                retval = allocateAndPrepareContinuousBlocks(taskDef, Math.max(prevBlockEnd + taskDef.resolution, fetchStart), blockStart - taskDef.resolution);\n              }\n            }\n        }\n      }\n\n      return retval;\n    }\n\n    function recycleBlock(block) {\n      if (block.isPinned()) {\n        async.whilst(function () {\n          return block.isPinned();\n        }, function (notify) {\n          setTimeout(notify, 500);\n        }, function (err) {\n          block.recycle();\n          emptyBlockPool.push(block);\n        });\n      } else {\n        block.recycle();\n        emptyBlockPool.push(block);\n      }\n    } //A single-line queue for running iterateCache: if more than one\n    //iteration is requested simultaneously, others have to queue for\n    //execution, because iterateCache changes the internal cache state asynchronously.\n\n\n    var iterateCacheQueue = async.queue(function (taskDef, callback) {\n      callback(null, iterateCache(taskDef));\n    }, 1);\n\n    function iterateCache(taskDef) {\n      var retval = [];\n      var requestedStart = taskDef.start;\n      var requestedEnd = taskDef.end;\n      var sideFetchBeforeItemCount = Math.ceil(sideFetchBeforeFactor * taskDef.pointCount);\n      var sideFetchAfterItemCount = Math.ceil(sideFetchAfterFactor * taskDef.pointCount);\n      var fetchStart = requestedStart - sideFetchBeforeItemCount * taskDef.resolution;\n      var fetchEnd = requestedEnd + sideFetchAfterItemCount * taskDef.resolution;\n      var blockAgeOrder = [];\n      var newCachedBlocks = [];\n      var mergeInd = -1;\n      var blockToMerge = null;\n      var prevMatchingBlock = null;\n\n      var sortIterator = function (bl) {\n        return bl.getStart();\n      };\n\n      cachedDataSize = 0; //add all merged blocks that are ready:\n\n      while (mergedBlocks.length > 0) {\n        blockToMerge = mergedBlocks.shift();\n        mergeInd = _.sortedIndex(cachedBlocks, blockToMerge, sortIterator);\n        cachedBlocks.splice(mergeInd, 0, blockToMerge);\n      }\n\n      if (cachedBlocks.length > 0) {\n        _.each(cachedBlocks, function (block, index) {\n          var selectThisBlock = false;\n          var newBlocksBefore = null;\n          var newBlocksAfter = null;\n          var prevBlockEnd = null;\n          var blStart = block.getStart();\n          var blEnd = block.getEnd();\n\n          if (block.isWaitingRecycling()) {\n            recycleBlock(block);\n            return; //=continue each loop;\n          } //This block contains data for the relevant service, with the same locations and parameters:\n\n\n          if (taskDef.service === block.getService() && arrayEqualsAnyOrder(taskDef.location, block.getLocation()) && arrayEqualsAnyOrder(taskDef.parameter, block.getParameter())) {\n            if (prevMatchingBlock !== null) {\n              prevBlockEnd = prevMatchingBlock.getEnd();\n            } //check if we should create new data blocks before the current block:\n\n\n            newBlocksBefore = createMissingBlocksBefore(prevBlockEnd, blStart, fetchStart, fetchEnd, taskDef);\n\n            if (newBlocksBefore !== null && newBlocksBefore.length > 0) {\n              Array.prototype.push.apply(newCachedBlocks, newBlocksBefore);\n              async.reduce(newBlocksBefore, cacheMisses, function (memo, block, callback) {\n                callback(null, memo + block.getDataSize());\n              }, function (err, result) {\n                cacheMisses = result;\n              });\n              Array.prototype.push.apply(retval, newBlocksBefore);\n            }\n\n            selectThisBlock = blockOverlaps(blStart, blEnd, fetchStart, fetchEnd);\n\n            if (selectThisBlock) {\n              if (block.pin() > 0) {\n                retval.push(block);\n                cacheHits += block.getDataSize();\n              } else {\n                if (\"undefined\" !== typeof console && console) {\n                  console.log('Unable to pin a block, it\\'s already marked for recycling (this should not happen)');\n                }\n              }\n            } else {\n              block.increaseNotUsed();\n            }\n\n            newCachedBlocks.push(block); //check if we should merge this block with the previous one:\n\n            if (prevMatchingBlock !== null && shouldBlocksBeMerged(prevMatchingBlock, block)) {\n              mergeBlocks(prevMatchingBlock, block, function (err, merged) {\n                if (err) {\n                  //Merge failed. This should only happen if the data for either block\n                  //could not be fetched.\n                  if (\"undefined\" !== typeof console && console) {\n                    console.error(err);\n                  }\n                } else {\n                  //Both merged old blocks have already been marked for recycling at this point.\n                  //Postpone adding the new block until the beginning of the next fetch cycle:\n                  mergedBlocks.push(merged);\n                }\n              });\n            }\n\n            prevMatchingBlock = block;\n          } else {\n            block.increaseNotUsed(); //not matched in this cycle, keep in cache still:\n\n            newCachedBlocks.push(block);\n          } //If we are at the last cached block, check if we should additionally\n          //create new data blocks after the last matching found block.\n\n\n          if (index === cachedBlocks.length - 1) {\n            //we've found at least one matching block in cache:\n            if (prevMatchingBlock !== null) {\n              //If our interesting step sequence ends after the last matching found block ends:\n              if (prevMatchingBlock.getEnd() + taskDef.resolution < fetchEnd) {\n                newBlocksAfter = allocateAndPrepareContinuousBlocks(taskDef, Math.max(blEnd + taskDef.resolution, fetchStart), fetchEnd);\n                Array.prototype.push.apply(newCachedBlocks, newBlocksAfter);\n                async.reduce(newBlocksAfter, cacheMisses, function (memo, block, callback) {\n                  callback(null, memo + block.getDataSize());\n                }, function (err, result) {\n                  cacheMisses = result;\n                });\n                Array.prototype.push.apply(retval, newBlocksAfter);\n              }\n            }\n          } //Place the current block at the evictOrder list at the current place based on it's age:\n\n\n          var ageInd = _.sortedIndex(blockAgeOrder, block, function (bl) {\n            return bl.getNotUsedSince();\n          });\n\n          blockAgeOrder.splice(ageInd, 0, block);\n          cachedDataSize += block.getDataSize();\n        });\n      } //no blocks in cache or none available for use right now, allocate new ones for the whole step sequence:\n\n\n      if (retval.length === 0) {\n        retval = allocateAndPrepareContinuousBlocks(taskDef, fetchStart, fetchEnd);\n        Array.prototype.push.apply(newCachedBlocks, retval);\n        async.reduce(retval, cacheMisses, function (memo, block, callback) {\n          callback(null, memo + block.getDataSize());\n        }, function (err, result) {\n          cacheMisses = result;\n        });\n      }\n\n      cachedBlocks = [];\n      cachedBlocks = newCachedBlocks;\n      newCachedBlocks = [];\n      async.whilst(function () {\n        return cachedDataSize * 1.01 > maxCacheDataSize;\n      }, function () {\n        var dataToEvict = cachedDataSize * 1.01 - maxCacheDataSize;\n        fireEvent('evictStarted', {\n          'inCache': cachedDataSize,\n          'toEvict': dataToEvict\n        });\n        var evictList = [];\n        var toEvict = null;\n        var evictListDataSize = 0;\n\n        while (evictListDataSize < dataToEvict && blockAgeOrder.length > 0) {\n          toEvict = blockAgeOrder.pop();\n\n          if (toEvict !== undefined) {\n            evictListDataSize += toEvict.getDataSize();\n            evictList.push(toEvict);\n          }\n        }\n\n        if (evictList.length > 0) {\n          evict(evictList);\n          cachedDataSize = cachedDataSize - evictListDataSize;\n          fireEvent('evictFinished', {\n            'inCache': cachedDataSize,\n            'evicted': evictListDataSize\n          });\n        }\n      }, function () {//NOOP\n      });\n      return retval;\n    }\n\n    function allocateAndPrepareContinuousBlocks(parentTaskDef, start, end) {\n      var blocks = [];\n      var totalPointCount = Math.round((end - start) / parentTaskDef.resolution) + 1;\n      var blocksNeeded = Math.ceil(totalPointCount / maxBlockDataPoints);\n      var i = 0;\n      var taskDef;\n      var block = null;\n\n      for (i = 0; i < blocksNeeded; i++) {\n        block = getDataBlock();\n        taskDef = _.clone(parentTaskDef);\n        taskDef.start = start + i * (parentTaskDef.resolution * maxBlockDataPoints);\n        taskDef.pointCount = Math.min(maxBlockDataPoints, totalPointCount - i * maxBlockDataPoints);\n        taskDef.end = taskDef.start + (taskDef.pointCount - 1) * parentTaskDef.resolution;\n        block.prepare(taskDef, getFetcher(parentTaskDef.service));\n\n        if (block.pin() > 0) {\n          blocks.push(block);\n        } else {\n          if (\"undefined\" !== typeof console && console) {\n            console.error('Strange, unable to pin block!');\n          }\n        }\n      }\n\n      return blocks;\n    }\n    /**\n     * @param source If source is an object, it should provide source[loc][param][index] structure that is used\n     *                           to get the data value for the target[loc][param][index] object. If source is not an object,\n     *                           the source itself is set directly into the target[loc][param][index].\n     */\n\n\n    function fillWith(target, source, locations, parameters, targetIndex, sourceIndex, count, callback) {\n      var copyFromArray = _.isObject(source);\n\n      var ti = 0;\n      var si = 0;\n      var end = 0;\n      async.each(locations, function (loc, locNotify) {\n        if (target[loc] === undefined) {\n          target[loc] = {};\n        }\n\n        async.each(parameters, function (param, paramNotify) {\n          var useErrorValues = false;\n\n          if (target[loc][param] === undefined) {\n            target[loc][param] = [];\n          }\n\n          if (copyFromArray) {\n            if (!_.isObject(source[loc]) || !_.isArray(source[loc][param])) {\n              useErrorValues = true;\n            } else if (source[loc][param].length < sourceIndex + count) {\n              useErrorValues = true;\n\n              if (\"undefined\" !== typeof console && console) {\n                console.error('Trying to fill segment with only ' + source[loc][param].length + ' values for location ' + loc + ' and parameter ' + param + ' when ' + (sourceIndex + count) + ' would be needed. Filling the whole segment with \\'' + errorFillValue + '\\'');\n              }\n            }\n          }\n\n          if (useErrorValues) {\n            ti = targetIndex;\n            end = targetIndex + count;\n\n            while (ti < end) {\n              target[loc][param][ti++] = errorFillValue;\n            }\n          } else if (copyFromArray) {\n            ti = targetIndex;\n            si = sourceIndex;\n            end = targetIndex + count;\n\n            while (ti < end) {\n              target[loc][param][ti++] = source[loc][param][si++];\n            }\n          } else {\n            ti = targetIndex;\n            end = targetIndex + count;\n\n            while (ti < end) {\n              target[loc][param][ti++] = source;\n            }\n          }\n\n          paramNotify();\n        }, function (err) {\n          //one location completed\n          locNotify();\n        });\n      }, function (err) {\n        //all done:\n        callback(err, target);\n      });\n    }\n\n    function retrieveDataAsync(origTaskDef, finishCallback, progressCallback) {\n      var taskDef = _.clone(origTaskDef);\n\n      if (!_.isFunction(finishCallback)) {\n        throw 'finishCallback must be a function';\n      }\n\n      if (getFetcher(taskDef.service) === null) {\n        throw 'No data fetcher set for service \\'' + taskDef.service + '\\', unable to provide data';\n      } //If the new request does not have the same resolution or the start difference is not a multiple of resolution\n      //then clear all cached results for this service:\n\n\n      if (stepResolutions[taskDef.service] !== undefined) {\n        if (stepResolutions[taskDef.service].resolution !== taskDef.resolution || Math.abs(stepResolutions[taskDef.service].start - taskDef.start) % taskDef.resolution !== 0) {\n          clear(taskDef.service);\n        }\n      }\n\n      stepResolutions[taskDef.service] = {\n        start: taskDef.start,\n        resolution: taskDef.resolution\n      };\n      iterateCacheQueue.push(taskDef, function (err, dataBlocks) {\n        fetchDataForBlocks(dataBlocks, taskDef, finishCallback, progressCallback);\n      });\n    }\n\n    function fetchDataForBlocks(dataBlocks, taskDef, finishCallback, progressCallback) {\n      var errors = null;\n      var notifyProgress = false;\n      var result = {};\n\n      if (_.isFunction(progressCallback)) {\n        notifyProgress = true;\n      }\n\n      fireEvent('fetchStarted', taskDef);\n      result.steps = _.range(taskDef.start, taskDef.end + taskDef.resolution, taskDef.resolution);\n      result.data = {};\n      async.each(dataBlocks, function (dataBlock, notify) {\n        var td = dataBlock.getTaskDef();\n        var includeStart = NaN;\n        var includeEnd = NaN;\n        var targetStartIndex = NaN;\n        var targetEndIndex = NaN;\n        var sourceStartIndex = NaN;\n        var valueCount = NaN;\n\n        if (!blockOverlaps(td.start, td.end, taskDef.start, taskDef.end)) {\n          //For completely out-of-range blocks:\n          //we fetch them just to cache them, but otherwise\n          //ignore the results completely:\n          dataBlock.getDataAsync(function () {\n            dataBlock.unpin();\n          }); //and continue the loop:\n\n          notify();\n          return;\n        }\n\n        if (td.start < taskDef.start) {\n          includeStart = taskDef.start;\n          sourceStartIndex = Math.round((taskDef.start - td.start) / taskDef.resolution);\n        } else {\n          includeStart = td.start;\n          sourceStartIndex = 0;\n        }\n\n        targetStartIndex = _.indexOf(result.steps, includeStart);\n\n        if (targetStartIndex === -1) {\n          throw dataBlock.getId() + ':something wrong with indexing, start index for cache block not found in the combined results!';\n        }\n\n        if (td.end > taskDef.end) {\n          includeEnd = taskDef.end;\n          targetEndIndex = result.steps.length - 1;\n        } else {\n          includeEnd = td.end;\n          targetEndIndex = _.indexOf(result.steps, td.end, true);\n        }\n\n        valueCount = targetEndIndex - targetStartIndex + 1; // See fillWith function description about the structure that data object should have.\n\n        dataBlock.getDataAsync(function (err, data) {\n          var fillValue = data;\n\n          if (err) {\n            if (errors === null) {\n              errors = [];\n            }\n\n            errors.push({\n              start: td.start,\n              end: td.end,\n              error: err\n            }); // error in fetching data, fill result with 'errorFillValue' for this step sequence if data is undefined itself.\n            // Notice, errors may have occurred but data is still given because it should be good enough.\n            // Therefore, do not ignore given data if it is available. It is up to the data provider to make\n            // sure that data is undefined if it should not be handled in cache.\n            //Ilkka Rinne/2013-09-02: This is inconsistent with the node.js callback error conventions:\n            //You should always get either an error or result, never both.\n            //http://nodemanual.org/latest/nodejs_dev_guide/working_with_callbacks.html\n            //When would you want to return errors but also useable data?\n\n            if (strictErrorHandling || !data) {\n              fillValue = errorFillValue;\n            } //do not keep this block in cache:\n\n\n            dataBlock.markForRecycling();\n          }\n\n          fillWith(result.data, fillValue, td.location, td.parameter, targetStartIndex, sourceStartIndex, valueCount, function () {\n            if (notifyProgress) {\n              progressCallback(err, includeStart, includeEnd);\n            }\n\n            dataBlock.unpin(); //always succeed, even with fetch error: we want to return the rest of the data anyway\n\n            notify();\n          });\n        });\n      }, function (err) {\n        finishCallback(errors, result);\n        fireEvent('fetchFinished', taskDef);\n      });\n    }\n\n    function getFetcher(service) {\n      if (fetchers[service] !== undefined) {\n        fetchers[service].nextIndex = (fetchers[service].nextIndex + 1) % fetchers[service].providers.length;\n        return fetchers[service].providers[fetchers[service].nextIndex].cb;\n      } else {\n        return null;\n      }\n    }\n\n    function clear(service) {\n      _.each(cachedBlocks, function (block) {\n        if (service === undefined || block.getService() === service) {\n          block.markForRecycling();\n        }\n      });\n\n      _.each(mergedBlocks, function (block) {\n        if (service === undefined || block.getService() === service) {\n          block.markForRecycling();\n        }\n      });\n\n      fireEvent('cacheCleared', service);\n    } //Privileged functions:\n\n    /**\n     * @param {String} service Describes the service name that identifies the data.\n     *                                               May not be {undefined}, {null} or empty. More than one fetcher\n     *                                               may be added for the same service to enable a round-robin task\n     *                                               distribution between them.\n     * @param {function(taskDef, callback)} fetcher The callback parameter of fetcher callback function is of\n     *                                              the type {function(err, data)}. See {fillWith()} function\n     *                                              for the description for the source data object structure\n     *                                              that should be provided by the fetcher callback function for\n     *                                              its parameter callback function.\n     */\n\n\n    this.addDataProvider = function (service, fetcher) {\n      var provider = {};\n\n      if (_.isFunction(fetcher)) {\n        if (fetchers[service] === undefined) {\n          fetchers[service] = {\n            nextIndex: 0,\n            providers: []\n          };\n        }\n\n        provider.id = 'id#' + fetcherIdCounter++;\n        provider.cb = fetcher;\n        fetchers[service].providers.push(provider);\n        fireEvent('dataProviderAdded', {\n          'service': service,\n          'providerId': provider.id\n        });\n      } else {\n        throw 'Fetcher must be a function';\n      }\n\n      return provider.id;\n    };\n\n    this.removeDataProvider = function (service, providerId) {\n      var oldLength = 0;\n      var actuallyRemoved = false;\n\n      if (fetchers[service] !== undefined) {\n        oldLength = fetchers[service].providers.length;\n        fetchers[service].providers = _.reject(fetchers[service].providers, function (provider) {\n          return provider.id === providerId;\n        });\n\n        if (fetchers[service].providers.length === 0) {\n          delete fetchers.service;\n          actuallyRemoved = true;\n        } else if (oldLength !== fetchers[service].providers.length) {\n          actuallyRemoved = true;\n        }\n\n        if (actuallyRemoved) {\n          fireEvent('dataProviderRemoved', {\n            'service': service,\n            'providerId': providerId\n          });\n        }\n      }\n    };\n    /**\n     * Removes all content from the cache and resets the hits & misses counters.\n     *\n     */\n\n\n    this.clearCache = function () {\n      clear();\n      stepResolutions = [];\n      cacheHits = 0;\n      cacheMisses = 0;\n    };\n\n    this.fetch = function (taskDef, finalCallback, progressCallback) {\n      checkTaskDef(taskDef);\n      retrieveDataAsync(taskDef, finalCallback, progressCallback);\n    };\n\n    this.getCachedItemCount = function () {\n      return cachedDataSize;\n    };\n\n    this.getFillingDegree = function () {\n      return cachedDataSize / maxCacheDataSize;\n    };\n\n    this.getHitRatio = function () {\n      return cacheHits / (cacheHits + cacheMisses);\n    };\n\n    this.addListener = function (eventName, callback) {\n      return addEventListener(eventName, callback);\n    };\n\n    this.removeListener = function (eventName, providerId) {\n      return removeEventListener(eventName, providerId);\n    }; //Instance initialization:\n\n\n    if (properties.sideFetchBeforeFactor !== undefined) {\n      if (_.isNumber(properties.sideFetchBeforeFactor)) {\n        if (properties.sideFetchBeforeFactor >= 0) {\n          sideFetchBeforeFactor = properties.sideFetchBeforeFactor;\n        }\n      }\n    }\n\n    if (properties.sideFetchAfterFactor !== undefined) {\n      if (_.isNumber(properties.sideFetchAfterFactor)) {\n        if (properties.sideFetchAfterFactor >= 0) {\n          sideFetchAfterFactor = properties.sideFetchAfterFactor;\n        }\n      }\n    }\n\n    if (properties.maxBlockDataPoints !== undefined) {\n      if (_.isNumber(properties.maxBlockDataPoints)) {\n        if (properties.maxBlockDataPoints > 0) {\n          maxBlockDataPoints = properties.maxBlockDataPoints;\n        }\n      }\n    }\n\n    if (properties.minBlockDataPoints !== undefined) {\n      if (_.isNumber(properties.minBlockDataPoints)) {\n        if (properties.minBlockDataPoints > 0 && properties.minBlockDataPoints < maxBlockDataPoints) {\n          minBlockDataPoints = properties.minBlockDataPoints;\n        } else {\n          minBlockDataPoints = 0;\n        }\n      }\n    }\n\n    if (minBlockDataPoints > maxBlockDataPoints) {\n      minBlockDataPoints = maxBlockDataPoints;\n    }\n\n    if (properties.maxCacheDataSize !== undefined) {\n      if (_.isNumber(properties.maxCacheDataSize)) {\n        if (properties.maxCacheDataSize > 0) {\n          maxCacheDataSize = properties.maxCacheDataSize;\n        }\n      }\n    }\n\n    if (properties.strictErrorHandling !== undefined) {\n      if (properties.strictErrorHandling === false) {\n        strictErrorHandling = false;\n      }\n    }\n\n    if (properties.errorFillValue !== undefined) {\n      errorFillValue = properties.errorFillValue;\n    }\n  };\n  /**\n   * SplitterCache constructor is returned for later instantiation.\n   */\n\n\n  return _constructor;\n}();\n\nmodule.exports = SplitterCache;","map":{"version":3,"sources":["C:/Users/Ossi Laurila/Desktop/weatherapp/node_modules/@fmidev/metolib/splittercache.js"],"names":["_","require","async","SplitterCache","checkTaskDef","taskDef","placeholder","startNudge","endNudge","isObject","isString","service","isArray","location","push","parameter","isNumber","resolution","Math","round","start","pointCount","end","arrayEqualsAnyOrder","arr1","arr2","i","length","indexOf","undefined","DataBlock","blockCounter","_constructor","evtDispatcher","id","fetchError","fetcher","data","age","fetching","fetched","pinCount","waitingRecycling","waitingMerging","ready","callbacks","requestId","dispatcher","thisBlock","reset","getId","getTaskDef","getStart","getEnd","getPointCount","getResolution","getService","getLocation","getParameter","getDataSize","pin","unpin","isPinned","getPinCount","getRequestId","isWaitingRecycling","isWaitingMerging","isFetched","setFetched","f","isFetching","setFetching","increaseNotUsed","getNotUsedSince","fetchFailed","markForRecycling","markForMerging","merge","setData","d","getFetcher","recycle","prepare","taskDefinition","dataFetcher","isFunction","getDataAsync","callback","that","err","result","reqId","whilst","myReqId","notify","cb","pop","call","ex","console","error","message","defer","eventListenerIdCounter","fetcherIdCounter","properties","emptyBlockPool","cachedBlocks","mergedBlocks","stepResolutions","sideFetchBeforeFactor","sideFetchAfterFactor","maxBlockDataPoints","minBlockDataPoints","maxCacheDataSize","strictErrorHandling","errorFillValue","NaN","fetchers","cachedDataSize","cacheHits","cacheMisses","thisCache","eventListeners","blockCreated","blockPrepared","blockProviderFetchStarted","blockProviderFetchFinished","blockCacheFetchStarted","blockCacheFetchFinished","blockPinned","blockUnpinned","blockEvicted","blockRecycled","blockAged","blockMarkedForMerge","blockMergeCancelled","evictStarted","evictFinished","fetchStarted","fetchFinished","cacheCleared","dataProviderAdded","dataProviderRemoved","fireEvent","eventName","eventData","each","addEventListener","listenerId","reduce","keys","memo","name","ind","removeEventListener","evict","evictList","toEvict","mergeBlocks","block1","block2","newBlock","combinedData","getDataBlock","clone","parallel","data1","log","fillWith","data2","results","Error","blocksAreContinuous","shouldBlocksBeMerged","dataBlock","blockOverlaps","blockStart","blockEnd","retval","createMissingBlocksBefore","prevBlockEnd","fetchStart","fetchEnd","allocateAndPrepareContinuousBlocks","max","recycleBlock","block","setTimeout","iterateCacheQueue","queue","iterateCache","requestedStart","requestedEnd","sideFetchBeforeItemCount","ceil","sideFetchAfterItemCount","blockAgeOrder","newCachedBlocks","mergeInd","blockToMerge","prevMatchingBlock","sortIterator","bl","shift","sortedIndex","splice","index","selectThisBlock","newBlocksBefore","newBlocksAfter","blStart","blEnd","Array","prototype","apply","merged","ageInd","dataToEvict","evictListDataSize","parentTaskDef","blocks","totalPointCount","blocksNeeded","min","target","source","locations","parameters","targetIndex","sourceIndex","count","copyFromArray","ti","si","loc","locNotify","param","paramNotify","useErrorValues","retrieveDataAsync","origTaskDef","finishCallback","progressCallback","abs","clear","dataBlocks","fetchDataForBlocks","errors","notifyProgress","steps","range","td","includeStart","includeEnd","targetStartIndex","targetEndIndex","sourceStartIndex","valueCount","fillValue","nextIndex","providers","addDataProvider","provider","removeDataProvider","providerId","oldLength","actuallyRemoved","reject","clearCache","fetch","finalCallback","getCachedItemCount","getFillingDegree","getHitRatio","addListener","removeListener","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;AACA,a,CAEA;;AACA,IAAIA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAf;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAAnB,C,CACA;AACA;;;AAEA,IAAIE,aAAa,GAAI,YAAU;AAE3B;AACA,MAAIC,YAAY,GAAG,UAASC,OAAT,EAAkB;AACjC,QAAIC,WAAJ;AACA,QAAIC,UAAU,GAAG,CAAjB;AACA,QAAIC,QAAQ,GAAG,CAAf;;AACA,QAAI,CAACR,CAAC,CAACS,QAAF,CAAWJ,OAAX,CAAL,EAA0B;AACtB,YAAM,2BAAN;AACH;;AAED,QAAI,CAACL,CAAC,CAACU,QAAF,CAAWL,OAAO,CAACM,OAAnB,CAAL,EAAkC;AAC9B,YAAM,4DAAN;AACH;;AAED,QAAI,CAACX,CAAC,CAACY,OAAF,CAAUP,OAAO,CAACQ,QAAlB,CAAL,EAAkC;AAC9B,UAAI,CAACb,CAAC,CAACU,QAAF,CAAWL,OAAO,CAACQ,QAAnB,CAAL,EAAmC;AAC/B,cAAM,kFAAN;AACH,OAFD,MAEO;AACHP,QAAAA,WAAW,GAAGD,OAAO,CAACQ,QAAtB;AACAR,QAAAA,OAAO,CAACQ,QAAR,GAAmB,EAAnB;AACAR,QAAAA,OAAO,CAACQ,QAAR,CAAiBC,IAAjB,CAAsBR,WAAtB;AACH;AACJ;;AAED,QAAI,CAACN,CAAC,CAACY,OAAF,CAAUP,OAAO,CAACU,SAAlB,CAAL,EAAmC;AAC/B,UAAI,CAACf,CAAC,CAACU,QAAF,CAAWL,OAAO,CAACU,SAAnB,CAAL,EAAoC;AAChC,cAAM,mFAAN;AACH,OAFD,MAEO;AACHT,QAAAA,WAAW,GAAGD,OAAO,CAACU,SAAtB;AACAV,QAAAA,OAAO,CAACU,SAAR,GAAoB,EAApB;AACAV,QAAAA,OAAO,CAACU,SAAR,CAAkBD,IAAlB,CAAuBR,WAAvB;AACH;AACJ;;AAED,QAAI,CAACN,CAAC,CAACgB,QAAF,CAAWX,OAAO,CAACY,UAAnB,CAAL,EAAqC;AACjC,YAAM,gEAAN;AACH,KAFD,MAEO,IAAIZ,OAAO,CAACY,UAAR,GAAqB,GAAzB,EAA8B;AACjCZ,MAAAA,OAAO,CAACY,UAAR,GAAqBC,IAAI,CAACC,KAAL,CAAWd,OAAO,CAACY,UAAnB,CAArB;AACH,KAFM,MAEA;AACH,YAAM,+CAAN;AACH;;AAED,QAAI,CAACjB,CAAC,CAACgB,QAAF,CAAWX,OAAO,CAACe,KAAnB,CAAL,EAAgC;AAC5B,YAAM,2DAAN;AACH;;AAED,QAAIpB,CAAC,CAACgB,QAAF,CAAWX,OAAO,CAACgB,UAAnB,CAAJ,EAAoC;AAChC,UAAIhB,OAAO,CAACgB,UAAR,GAAqB,CAAzB,EAA4B;AACxBhB,QAAAA,OAAO,CAACiB,GAAR,GAAcjB,OAAO,CAACe,KAAR,GAAgB,CAACf,OAAO,CAACgB,UAAR,GAAqB,CAAtB,IAA2BhB,OAAO,CAACY,UAAjE;AACH,OAFD,MAEO;AACH,cAAM,8CAAN;AACH;AACJ,KAND,MAMO,IAAIjB,CAAC,CAACgB,QAAF,CAAWX,OAAO,CAACiB,GAAnB,CAAJ,EAA6B;AAChC,UAAIjB,OAAO,CAACiB,GAAR,GAAcjB,OAAO,CAACe,KAA1B,EAAiC;AAC7B,cAAM,oDAAN;AACH;;AACDZ,MAAAA,QAAQ,GAAG,CAACH,OAAO,CAACiB,GAAR,GAAcjB,OAAO,CAACe,KAAvB,IAAgCf,OAAO,CAACY,UAAnD;;AACA,UAAIT,QAAQ,KAAK,CAAjB,EAAoB;AAChBH,QAAAA,OAAO,CAACiB,GAAR,GAAcjB,OAAO,CAACiB,GAAR,IAAejB,OAAO,CAACY,UAAR,GAAqBT,QAApC,CAAd;AACH;;AACDH,MAAAA,OAAO,CAACgB,UAAR,GAAqB,CAAChB,OAAO,CAACiB,GAAR,GAAcjB,OAAO,CAACe,KAAvB,IAAgCf,OAAO,CAACY,UAAxC,GAAqD,CAA1E;AACH,KATM,MASA;AACH,YAAM,gFAAN;AACH;AACJ,GA9DD;;AAgEA,MAAIM,mBAAmB,GAAG,UAASC,IAAT,EAAeC,IAAf,EAAqB;AAC3C,QAAIC,CAAC,GAAG,CAAR;;AACA,QAAI1B,CAAC,CAACY,OAAF,CAAUY,IAAV,KAAmBxB,CAAC,CAACY,OAAF,CAAUa,IAAV,CAAvB,EAAwC;AACpC,UAAID,IAAI,CAACG,MAAL,KAAgBF,IAAI,CAACE,MAAzB,EAAiC;AAC7B,aAAMD,CAAC,GAAG,CAAV,EAAaA,CAAC,GAAGF,IAAI,CAACG,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;AAC/B,cAAI1B,CAAC,CAAC4B,OAAF,CAAUH,IAAV,EAAgBD,IAAI,CAACE,CAAD,CAApB,MAA6B,CAAC,CAAlC,EAAqC;AACjC,mBAAO,KAAP;AACH;AACJ;;AACD,eAAO,IAAP;AACH,OAPD,MAOO;AACH,eAAO,KAAP;AACH;AACJ,KAXD,MAWO,IAAKF,IAAI,KAAKK,SAAV,IAAyBL,IAAI,KAAK,IAAlC,IAA4CC,IAAI,KAAKI,SAArD,IAAoEJ,IAAI,KAAK,IAAjF,EAAwF;AAC3F,aAAO,KAAP;AACH,KAFM,MAEA;AACH,aAAQD,IAAI,KAAKC,IAAjB;AACH;AACJ,GAlBD;AAoBA;;;;;;;;AAMA,MAAIK,SAAS,GAAI,YAAW;AACxB,QAAIC,YAAY,GAAG,CAAnB;;AAEA,QAAIC,YAAY,GAAG,SAASF,SAAT,CAAmBG,aAAnB,EAAkC;AACjD,UAAIC,EAAE,GAAG,IAAT;AACA,UAAIC,UAAU,GAAG,IAAjB;AACA,UAAIC,OAAO,GAAG,IAAd;AACA,UAAIC,IAAI,GAAG,IAAX;AACA,UAAIhC,OAAO,GAAG,IAAd;AACA,UAAIiC,GAAG,GAAG,CAAV;AACA,UAAIC,QAAQ,GAAG,KAAf;AACA,UAAIC,OAAO,GAAG,KAAd;AACA,UAAIC,QAAQ,GAAG,CAAf;AACA,UAAIC,gBAAgB,GAAG,KAAvB;AACA,UAAIC,cAAc,GAAG,KAArB;AACA,UAAIC,KAAK,GAAG,KAAZ;AACA,UAAIC,SAAS,GAAG,EAAhB;AACA,UAAIC,SAAS,GAAG,CAAhB;AACA,UAAIC,UAAU,GAAGd,aAAjB;AACA,UAAIe,SAAS,GAAG,IAAhB,CAhBiD,CAkBjD;;AAEA,eAASC,KAAT,GAAiB;AACbd,QAAAA,UAAU,GAAG,IAAb;AACAC,QAAAA,OAAO,GAAG,IAAV;AACAC,QAAAA,IAAI,GAAG,IAAP;AACAhC,QAAAA,OAAO,GAAG,IAAV;AACAiC,QAAAA,GAAG,GAAG,CAAN;AACAC,QAAAA,QAAQ,GAAG,KAAX;AACAC,QAAAA,OAAO,GAAG,KAAV;AACAC,QAAAA,QAAQ,GAAG,CAAX;AACAC,QAAAA,gBAAgB,GAAG,KAAnB;AACAC,QAAAA,cAAc,GAAG,KAAjB;AACAC,QAAAA,KAAK,GAAG,KAAR;AACAC,QAAAA,SAAS,GAAG,EAAZ;AAEH,OAlCgD,CAoCjD;;;AACA,WAAKK,KAAL,GAAa,YAAW;AACpB,eAAOhB,EAAP;AACH,OAFD;;AAIA,WAAKiB,UAAL,GAAkB,YAAW;AACzB,eAAO9C,OAAP;AACH,OAFD;;AAIA,WAAK+C,QAAL,GAAgB,YAAW;AACvB,eAAQ/C,OAAO,KAAK,IAAb,GAAqBA,OAAO,CAACe,KAA7B,GAAqCS,SAA5C;AACH,OAFD;;AAIA,WAAKwB,MAAL,GAAc,YAAW;AACrB,eAAQhD,OAAO,KAAK,IAAb,GAAqBA,OAAO,CAACiB,GAA7B,GAAmCO,SAA1C;AACH,OAFD;;AAIA,WAAKyB,aAAL,GAAqB,YAAW;AAC5B,eAAQjD,OAAO,KAAK,IAAb,GAAqBA,OAAO,CAACgB,UAA7B,GAA0CQ,SAAjD;AACH,OAFD;;AAIA,WAAK0B,aAAL,GAAqB,YAAW;AAC5B,eAAQlD,OAAO,KAAK,IAAb,GAAqBA,OAAO,CAACY,UAA7B,GAA0CY,SAAjD;AACH,OAFD;;AAIA,WAAK2B,UAAL,GAAkB,YAAW;AACzB,eAAQnD,OAAO,KAAK,IAAb,GAAqBA,OAAO,CAACM,OAA7B,GAAuCkB,SAA9C;AACH,OAFD;;AAIA,WAAK4B,WAAL,GAAmB,YAAW;AAC1B,eAAQpD,OAAO,KAAK,IAAb,GAAqBA,OAAO,CAACQ,QAA7B,GAAwCgB,SAA/C;AACH,OAFD;;AAIA,WAAK6B,YAAL,GAAoB,YAAW;AAC3B,eAAQrD,OAAO,KAAK,IAAb,GAAqBA,OAAO,CAACU,SAA7B,GAAyCc,SAAhD;AACH,OAFD;;AAIA,WAAK8B,WAAL,GAAmB,YAAW;AAC1B,eAAQtD,OAAO,KAAK,IAAb,GAAsBA,OAAO,CAACgB,UAAR,GAAqBhB,OAAO,CAACU,SAAR,CAAkBY,MAAvC,GAAgDtB,OAAO,CAACQ,QAAR,CAAiBc,MAAvF,GAAiG,CAAxG;AACH,OAFD;;AAIA,WAAKiC,GAAL,GAAW,YAAW;AAClB,YAAI,CAAClB,gBAAL,EAAuB;AACnBD,UAAAA,QAAQ;;AACR,cAAIM,UAAJ,EAAgB;AACZA,YAAAA,UAAU,CAAC,aAAD,EAAgBC,SAAhB,CAAV;AACH;;AACD,iBAAOP,QAAP;AACH,SAND,MAMO;AACH,iBAAO,IAAP;AACH;AACJ,OAVD;;AAYA,WAAKoB,KAAL,GAAa,YAAW;AACpB,YAAIpB,QAAQ,GAAG,CAAf,EAAkB;AACdA,UAAAA,QAAQ;;AACR,cAAIM,UAAJ,EAAgB;AACZA,YAAAA,UAAU,CAAC,eAAD,EAAkBC,SAAlB,CAAV;AACH;AACJ;;AACD,eAAOP,QAAP;AACH,OARD;;AAUA,WAAKqB,QAAL,GAAgB,YAAW;AACvB,eAAQrB,QAAQ,GAAG,CAAnB;AACH,OAFD;;AAIA,WAAKsB,WAAL,GAAmB,YAAW;AAC1B,eAAOtB,QAAP;AACH,OAFD;;AAIA,WAAKuB,YAAL,GAAoB,YAAW;AAC3B,eAAOlB,SAAP;AACH,OAFD;;AAIA,WAAKmB,kBAAL,GAA0B,YAAW;AACjC,eAAOvB,gBAAP;AACH,OAFD;;AAIA,WAAKwB,gBAAL,GAAwB,YAAW;AAC/B,eAAOvB,cAAP;AACH,OAFD;;AAIA,WAAKwB,SAAL,GAAiB,YAAW;AACxB,eAAO3B,OAAP;AACH,OAFD;;AAIA,WAAK4B,UAAL,GAAkB,UAASC,CAAT,EAAY;AAC1B,YAAIA,CAAC,KAAK,IAAV,EAAgB;AACZ7B,UAAAA,OAAO,GAAG,IAAV;AACH,SAFD,MAEO;AACHA,UAAAA,OAAO,GAAG,KAAV;AACH;AACJ,OAND;;AAQA,WAAK8B,UAAL,GAAkB,YAAW;AACzB,eAAO/B,QAAP;AACH,OAFD;;AAIA,WAAKgC,WAAL,GAAmB,UAASF,CAAT,EAAY;AAC3B,YAAIA,CAAC,KAAK,IAAV,EAAgB;AACZ9B,UAAAA,QAAQ,GAAG,IAAX;AACH,SAFD,MAEO;AACHA,UAAAA,QAAQ,GAAG,KAAX;AACH;AACJ,OAND;;AAQA,WAAKiC,eAAL,GAAuB,YAAW;AAC9BlC,QAAAA,GAAG;;AACH,YAAIS,UAAJ,EAAgB;AACZA,UAAAA,UAAU,CAAC,WAAD,EAAcC,SAAd,CAAV;AACH;AACJ,OALD;;AAOA,WAAKyB,eAAL,GAAuB,YAAW;AAC9B,eAAOnC,GAAP;AACH,OAFD;;AAIA,WAAKoC,WAAL,GAAmB,YAAW;AAC5B,eAAOvC,UAAU,KAAK,IAAtB;AACD,OAFD;;AAIA,WAAKwC,gBAAL,GAAwB,YAAW;AAC/BjC,QAAAA,gBAAgB,GAAG,IAAnB;;AACA,YAAIK,UAAJ,EAAgB;AACZA,UAAAA,UAAU,CAAC,cAAD,EAAiBC,SAAjB,CAAV;AACH;AACJ,OALD;;AAOA,WAAK4B,cAAL,GAAsB,UAASC,KAAT,EAAgB;AAClC,YAAIA,KAAK,KAAK,IAAd,EAAmB;AACflC,UAAAA,cAAc,GAAG,IAAjB;;AACA,cAAII,UAAJ,EAAgB;AACZA,YAAAA,UAAU,CAAC,qBAAD,EAAwBC,SAAxB,CAAV;AACH;AACJ,SALD,MAMK;AACDL,UAAAA,cAAc,GAAG,KAAjB;;AACA,cAAII,UAAJ,EAAgB;AACZA,YAAAA,UAAU,CAAC,qBAAD,EAAwBC,SAAxB,CAAV;AACH;AACJ;AACJ,OAbD;;AAeA,WAAK8B,OAAL,GAAe,UAASC,CAAT,EAAY;AACvB1C,QAAAA,IAAI,GAAG0C,CAAP;AACH,OAFD;;AAIA,WAAKC,UAAL,GAAkB,YAAW;AACzB,eAAO5C,OAAP;AACH,OAFD;;AAIA,WAAK6C,OAAL,GAAe,YAAW;AACtBhC,QAAAA,KAAK;;AACL,YAAIF,UAAJ,EAAgB;AACZA,UAAAA,UAAU,CAAC,eAAD,EAAkBC,SAAlB,CAAV;AACH;AACJ,OALD;AAOA;;;;;;;;;;;;AAUA,WAAKkC,OAAL,GAAe,UAASC,cAAT,EAAyBC,WAAzB,EAAsC;AACjD,YAAI,CAACpF,CAAC,CAACqF,UAAF,CAAaD,WAAb,CAAL,EAAgC;AAC5B,gBAAM,4BAAN;AACH;;AACDhF,QAAAA,YAAY,CAAC+E,cAAD,CAAZ;AACAlC,QAAAA,KAAK;AACL5C,QAAAA,OAAO,GAAG8E,cAAV;AACA/C,QAAAA,OAAO,GAAGgD,WAAV;AACAxC,QAAAA,KAAK,GAAG,IAAR;AACAE,QAAAA,SAAS;;AACT,YAAIC,UAAJ,EAAgB;AACZA,UAAAA,UAAU,CAAC,eAAD,EAAkBC,SAAlB,CAAV;AACH;AACJ,OAbD;AAeA;;;;;AAGA,WAAKsC,YAAL,GAAoB,UAASC,QAAT,EAAmB;AACnC,YAAIC,IAAI,GAAG,IAAX;;AACA,YAAI,CAAC5C,KAAL,EAAY;AACR,gBAAM,wDAAN;AACH;;AACDN,QAAAA,GAAG,GAAG,CAAN;;AACA,YAAI,CAACE,OAAL,EAAc;AACV,cAAK+C,QAAQ,KAAK1D,SAAd,IAA4B7B,CAAC,CAACqF,UAAF,CAAaE,QAAb,CAAhC,EAAwD;AACpD1C,YAAAA,SAAS,CAAC/B,IAAV,CAAeyE,QAAf;AACH;;AACD,cAAI,CAAChD,QAAL,EAAe;AACXA,YAAAA,QAAQ,GAAG,IAAX;AACAH,YAAAA,OAAO,CAAC/B,OAAD,EAAU,UAASoF,GAAT,EAAcC,MAAd,EAAsB;AACnC,kBAAIC,KAAK,GAAGH,IAAI,CAACxB,YAAL,EAAZ;;AACA,kBAAIyB,GAAJ,EAAS;AACLtD,gBAAAA,UAAU,GAAGsD,GAAb;AACH;;AACDpD,cAAAA,IAAI,GAAGqD,MAAP;AACAlD,cAAAA,OAAO,GAAG,IAAV;;AACA,kBAAIK,SAAS,CAAClB,MAAV,KAAqB,CAAzB,EAA4B;AACxBY,gBAAAA,QAAQ,GAAG,KAAX;AACH,eAFD,MAEO;AACHrC,gBAAAA,KAAK,CAAC0F,MAAN,CAAa,YAAW;AACpB,sBAAIC,OAAO,GAAGL,IAAI,CAACxB,YAAL,EAAd,CADoB,CAEpB;AACA;AACA;;AACA,yBAAS2B,KAAK,KAAKE,OAAX,IAAwBhD,SAAS,CAAClB,MAAV,GAAmB,CAAnD;AACH,iBAND,EAMG,UAASmE,MAAT,EAAiB;AAChB,sBAAI;AACA,wBAAIC,EAAE,GAAGlD,SAAS,CAACmD,GAAV,EAAT;AACAD,oBAAAA,EAAE,CAACE,IAAH,CAAQT,IAAR,EAAcrD,UAAd,EAA0BE,IAA1B;AACH,mBAHD,CAGE,OAAO6D,EAAP,EAAW;AACT,wBAAI,gBAAgB,OAAOC,OAAvB,IAAkCA,OAAtC,EAA+C;AAC3CA,sBAAAA,OAAO,CAACC,KAAR,CAAc,sCAAsCF,EAAE,CAACG,OAAvD;AACH;AACJ,mBAPD,SAOU;AACNP,oBAAAA,MAAM;AACNvD,oBAAAA,QAAQ,GAAG,KAAX;AACH;AACJ,iBAlBD,EAkBG,UAASkD,GAAT,EAAc,CACb;AACH,iBApBD;AAqBH;;AACD,kBAAI1C,UAAJ,EAAgB;AACZA,gBAAAA,UAAU,CAAC,4BAAD,EAA+BC,SAA/B,CAAV;AACH;AACJ,aAnCM,CAAP;;AAoCA,gBAAID,UAAJ,EAAgB;AACZA,cAAAA,UAAU,CAAC,2BAAD,EAA8BC,SAA9B,CAAV;AACH;AACJ;AAEJ,SA/CD,MA+CO;AACH,cAAIhD,CAAC,CAACqF,UAAF,CAAaE,QAAb,CAAJ,EAA4B;AACxBvF,YAAAA,CAAC,CAACsG,KAAF,CAAQ,UAASb,GAAT,EAAcV,CAAd,EAAiB;AACrB,kBAAIhC,UAAJ,EAAgB;AACZA,gBAAAA,UAAU,CAAC,yBAAD,EAA4BC,SAA5B,CAAV;AACH;;AACDuC,cAAAA,QAAQ,CAACE,GAAD,EAAMV,CAAN,CAAR;AACH,aALD,EAKG5C,UALH,EAKeE,IALf;;AAMA,gBAAIU,UAAJ,EAAgB;AACZA,cAAAA,UAAU,CAAC,wBAAD,EAA2BC,SAA3B,CAAV;AACH;AACJ,WAVD,MAUO,CAEN;AACJ;AACJ,OApED,CA/NiD,CAqSjD;;;AACAd,MAAAA,EAAE,GAAG,QAAQH,YAAY,EAAzB;;AAEA,UAAIgB,UAAJ,EAAgB;AACZA,QAAAA,UAAU,CAAC,cAAD,EAAiBC,SAAjB,CAAV;AACH;AACJ,KA3SD;;AA6SA,WAAOhB,YAAP;AACH,GAjTe,EAAhB;;AAmTA,MAAIuE,sBAAsB,GAAG,CAA7B;AACA,MAAIC,gBAAgB,GAAG,CAAvB;AAEA;;;;;;;AAMA,MAAIxE,YAAY,GAAG,SAAS7B,aAAT,CAAuBsG,UAAvB,EAAmC;AAClD,QAAIC,cAAc,GAAG,EAArB;AACA,QAAIC,YAAY,GAAG,EAAnB;AACA,QAAIC,YAAY,GAAG,EAAnB;AACA,QAAIC,eAAe,GAAG,EAAtB;AACA,QAAIC,qBAAqB,GAAG,GAA5B;AACA,QAAIC,oBAAoB,GAAG,CAA3B;AACA,QAAIC,kBAAkB,GAAG,GAAzB;AACA,QAAIC,kBAAkB,GAAG,EAAzB;AACA,QAAIC,gBAAgB,GAAG,KAAvB;AACA,QAAIC,mBAAmB,GAAG,IAA1B;AACA,QAAIC,cAAc,GAAGC,GAArB;AAEA,QAAIC,QAAQ,GAAG,EAAf;AACA,QAAIC,cAAc,GAAG,CAArB;AACA,QAAIC,SAAS,GAAG,CAAhB;AACA,QAAIC,WAAW,GAAG,CAAlB;AACA,QAAIC,SAAS,GAAG,IAAhB;AAEA,QAAIC,cAAc,GAAG;AACjBC,MAAAA,YAAY,EAAG,EADE;AAEjBC,MAAAA,aAAa,EAAG,EAFC;AAGjBC,MAAAA,yBAAyB,EAAG,EAHX;AAIjBC,MAAAA,0BAA0B,EAAG,EAJZ;AAKjBC,MAAAA,sBAAsB,EAAG,EALR;AAMjBC,MAAAA,uBAAuB,EAAG,EANT;AAOjBC,MAAAA,WAAW,EAAG,EAPG;AAQjBC,MAAAA,aAAa,EAAG,EARC;AASjBC,MAAAA,YAAY,EAAG,EATE;AAUjBC,MAAAA,aAAa,EAAG,EAVC;AAWjBC,MAAAA,SAAS,EAAG,EAXK;AAYjBC,MAAAA,mBAAmB,EAAG,EAZL;AAajBC,MAAAA,mBAAmB,EAAG,EAbL;AAcjBC,MAAAA,YAAY,EAAG,EAdE;AAejBC,MAAAA,aAAa,EAAG,EAfC;AAgBjBC,MAAAA,YAAY,EAAG,EAhBE;AAiBjBC,MAAAA,aAAa,EAAG,EAjBC;AAkBjBC,MAAAA,YAAY,EAAG,EAlBE;AAmBjBC,MAAAA,iBAAiB,EAAG,EAnBH;AAoBjBC,MAAAA,mBAAmB,EAAG;AApBL,KAArB,CAnBkD,CA0ClD;AACA;;AAEA,aAASC,SAAT,CAAmBC,SAAnB,EAA8BC,SAA9B,EAAyC;AACrC,UAAIvB,cAAc,CAACsB,SAAD,CAAd,KAA8BpH,SAAlC,EAA6C;AACzC7B,QAAAA,CAAC,CAACmJ,IAAF,CAAOxB,cAAc,CAACsB,SAAD,CAArB,EAAkC,UAASlD,EAAT,EAAa;AAC3C,cAAI;AACAA,YAAAA,EAAE,CAACE,IAAH,CAAQyB,SAAR,EAAmBwB,SAAnB;AACH,WAFD,CAEE,OAAOhD,EAAP,EAAW,CACZ;AACJ,SALD;AAMH;AACJ;;AAED,aAASkD,gBAAT,CAA0BH,SAA1B,EAAqClD,EAArC,EAAyC;AACrC,UAAIsD,UAAU,GAAG,IAAjB;;AACA,UAAI1B,cAAc,CAACsB,SAAD,CAAd,KAA8BpH,SAAlC,EAA6C;AACzC,YAAI7B,CAAC,CAACqF,UAAF,CAAaU,EAAb,CAAJ,EAAsB;AAClBsD,UAAAA,UAAU,GAAG,OAAQ9C,sBAAsB,EAA3C;AACAoB,UAAAA,cAAc,CAACsB,SAAD,CAAd,CAA0BI,UAA1B,IAAwCtD,EAAxC;AACH,SAHD,MAGO;AACH,gBAAM,2CAAN;AACH;AACJ,OAPD,MAOO;AACH,cAAM,qBAAqBkD,SAArB,GAAiC,iBAAjC,GAAqDjJ,CAAC,CAACsJ,MAAF,CAAStJ,CAAC,CAACuJ,IAAF,CAAO5B,cAAP,CAAT,EAAiC,UAAS6B,IAAT,EAAeC,IAAf,EAAqBC,GAArB,EAA0B;AAClH,cAAIA,GAAG,GAAG,CAAV,EAAa;AACTF,YAAAA,IAAI,GAAGA,IAAI,GAAG,IAAd;AACH;;AACDA,UAAAA,IAAI,GAAGA,IAAI,GAAGC,IAAd;AACA,iBAAOD,IAAP;AACH,SAN0D,CAA3D;AAOH;;AACD,aAAOH,UAAP;AACH;;AAED,aAASM,mBAAT,CAA6BV,SAA7B,EAAwCI,UAAxC,EAAoD;AAChD,UAAI1B,cAAc,CAACsB,SAAD,CAAd,KAA8BpH,SAAlC,EAA6C;AACzC,YAAI8F,cAAc,CAACsB,SAAD,CAAd,CAA0BI,UAA1B,MAA0CxH,SAA9C,EAAyD;AACrD,iBAAO8F,cAAc,CAACsB,SAAD,CAAd,CAA0BI,UAA1B,CAAP;AACH;AACJ,OAJD,MAIO;AACH,cAAM,qBAAqBJ,SAArB,GAAiC,iBAAjC,GAAqDjJ,CAAC,CAACsJ,MAAF,CAAStJ,CAAC,CAACuJ,IAAF,CAAO5B,cAAP,CAAT,EAAiC,UAAS6B,IAAT,EAAeC,IAAf,EAAqBC,GAArB,EAA0B;AAClH,cAAIA,GAAG,GAAG,CAAV,EAAa;AACTF,YAAAA,IAAI,GAAGA,IAAI,GAAG,IAAd;AACH;;AACDA,UAAAA,IAAI,GAAGA,IAAI,GAAGC,IAAd;AACH,SAL0D,CAA3D;AAMH;AACJ;;AAED,aAASG,KAAT,CAAeC,SAAf,EAA0B;AACtB3J,MAAAA,KAAK,CAACiJ,IAAN,CAAWU,SAAX,EAAsB,UAASC,OAAT,EAAkBhE,MAAlB,EAA0B;AAC5CgE,QAAAA,OAAO,CAACnF,gBAAR;AACAmB,QAAAA,MAAM;AACT,OAHD,EAGG,UAASL,GAAT,EAAc;AACb,YAAIA,GAAG,IAAI,gBAAgB,OAAOU,OAA9B,IAAyCA,OAA7C,EAAsD;AAClDA,UAAAA,OAAO,CAACC,KAAR,CAAcX,GAAd;AACH;AACJ,OAPD;AAQH;;AAED,aAASsE,WAAT,CAAqBC,MAArB,EAA6BC,MAA7B,EAAqC1E,QAArC,EAA+C;AAC3C,UAAI2E,QAAQ,GAAG,IAAf;AACA,UAAI7J,OAAO,GAAG,EAAd;AACA,UAAI8J,YAAY,GAAG,EAAnB;;AACA,UAAKH,MAAM,CAACpG,GAAP,KAAe,CAAhB,IAAuBqG,MAAM,CAACrG,GAAP,KAAe,CAA1C,EAA8C;AAC1CoG,QAAAA,MAAM,CAACpF,cAAP,CAAsB,IAAtB;AACAqF,QAAAA,MAAM,CAACrF,cAAP,CAAsB,IAAtB;AACAsF,QAAAA,QAAQ,GAAGE,YAAY,EAAvB;AACA/J,QAAAA,OAAO,GAAGL,CAAC,CAACqK,KAAF,CAAQL,MAAM,CAAC7G,UAAP,EAAR,CAAV;AACA9C,QAAAA,OAAO,CAACiB,GAAR,GAAc2I,MAAM,CAAC5G,MAAP,EAAd;AACAhD,QAAAA,OAAO,CAACgB,UAAR,GAAqB2I,MAAM,CAAC1G,aAAP,KAAyB2G,MAAM,CAAC3G,aAAP,EAA9C;AACA4G,QAAAA,QAAQ,CAAChF,OAAT,CAAiB7E,OAAjB,EAA0B2J,MAAM,CAAChF,UAAP,EAA1B;AACAkF,QAAAA,QAAQ,CAAC3F,WAAT,CAAqB,IAArB;AACAyE,QAAAA,SAAS,CAAC,wBAAD,EAA2BkB,QAA3B,CAAT;AACAhK,QAAAA,KAAK,CAACoK,QAAN,CAAe;AACXC,UAAAA,KAAK,EAAG,UAASxE,EAAT,EAAa;AACjBiE,YAAAA,MAAM,CAAC1E,YAAP,CAAoB,UAASG,GAAT,EAAcpD,IAAd,EAAoB;AACpC,kBAAIoD,GAAJ,EAAS;AACL,oBAAI,gBAAgB,OAAOU,OAAvB,IAAkCA,OAAtC,EAA+C;AAC3CA,kBAAAA,OAAO,CAACqE,GAAR,CAAY,+DAA+D/E,GAA/D,GAAqE,IAAjF;AACH;;AACDM,gBAAAA,EAAE,CAACN,GAAD,CAAF;AACH,eALD,MAMK;AACDgF,gBAAAA,QAAQ,CAACN,YAAD,EAAe9H,IAAf,EAAqBhC,OAAO,CAACQ,QAA7B,EAAuCR,OAAO,CAACU,SAA/C,EAA0D,CAA1D,EAA6D,CAA7D,EAAgEiJ,MAAM,CAAC1G,aAAP,EAAhE,EAAwFyC,EAAxF,CAAR;AACH;AACJ,aAVD;AAWH,WAbU;AAcX2E,UAAAA,KAAK,EAAG,UAAS3E,EAAT,EAAa;AACjBkE,YAAAA,MAAM,CAAC3E,YAAP,CAAoB,UAASG,GAAT,EAAcpD,IAAd,EAAoB;AACpC,kBAAIoD,GAAJ,EAAS;AACL,oBAAI,gBAAgB,OAAOU,OAAvB,IAAkCA,OAAtC,EAA+C;AAC3CA,kBAAAA,OAAO,CAACqE,GAAR,CAAY,+DAA+D/E,GAA/D,GAAqE,IAAjF;AACH;;AACDM,gBAAAA,EAAE,CAACN,GAAD,CAAF;AACH,eALD,MAMK;AACDgF,gBAAAA,QAAQ,CAACN,YAAD,EAAe9H,IAAf,EAAqBhC,OAAO,CAACQ,QAA7B,EAAuCR,OAAO,CAACU,SAA/C,EAA0DiJ,MAAM,CAAC1G,aAAP,EAA1D,EAAkF,CAAlF,EAAqF2G,MAAM,CAAC3G,aAAP,EAArF,EAA6GyC,EAA7G,CAAR;AACH;AACJ,aAVD;AAWH;AA1BU,SAAf,EA2BG,UAASN,GAAT,EAAckF,OAAd,EAAuB;AACtBX,UAAAA,MAAM,CAACnG,KAAP;AACAoG,UAAAA,MAAM,CAACpG,KAAP;;AACA,cAAI,CAAC4B,GAAL,EAAS;AACLuE,YAAAA,MAAM,CAACrF,gBAAP;AACAsF,YAAAA,MAAM,CAACtF,gBAAP;AACAuF,YAAAA,QAAQ,CAACpF,OAAT,CAAiBqF,YAAjB;AACAD,YAAAA,QAAQ,CAAC3F,WAAT,CAAqB,KAArB;AACA2F,YAAAA,QAAQ,CAAC9F,UAAT,CAAoB,IAApB;AACAmB,YAAAA,QAAQ,CAAC,IAAD,EAAO2E,QAAP,CAAR;AACAlB,YAAAA,SAAS,CAAC,yBAAD,EAA4BkB,QAA5B,CAAT;AACH,WARD,MAQO;AACHA,YAAAA,QAAQ,CAACjH,KAAT;AACA+G,YAAAA,MAAM,CAACpF,cAAP,CAAsB,KAAtB;AACAqF,YAAAA,MAAM,CAACrF,cAAP,CAAsB,KAAtB;AACAW,YAAAA,QAAQ,CAACE,GAAD,CAAR;AACAuD,YAAAA,SAAS,CAAC,yBAAD,EAA4B,IAA5B,CAAT;AACH;AACJ,SA7CD;AA8CH,OAxDD,MAwDO;AACHhJ,QAAAA,CAAC,CAACsG,KAAF,CAAQ,YAAW;AACff,UAAAA,QAAQ,CAAC,IAAIqF,KAAJ,CAAU,iDAAV,CAAD,CAAR;AACH,SAFD;AAGH;AACJ;;AAED,aAASC,mBAAT,CAA6Bb,MAA7B,EAAqCC,MAArC,EAA6C;AACzC,UAAID,MAAM,CAACzG,aAAP,OAA2B0G,MAAM,CAAC1G,aAAP,EAA3B,IAAsD0G,MAAM,CAAC7G,QAAP,OAAsB4G,MAAM,CAAC3G,MAAP,KAAkB2G,MAAM,CAACzG,aAAP,EAAlG,EAA2H;AACvH,eAAO,IAAP;AACH,OAFD,MAEO;AACH,eAAO,KAAP;AACH;AACJ;;AAED,aAASuH,oBAAT,CAA8Bd,MAA9B,EAAsCC,MAAtC,EAA8C;AAC1C;AACA,UAAI,CAACD,MAAM,CAACtF,WAAP,EAAD,IAAyB,CAACuF,MAAM,CAACvF,WAAP,EAA1B,IAAkD,CAACsF,MAAM,CAAC9F,gBAAP,EAAnD,IAAgF,CAAC+F,MAAM,CAAC/F,gBAAP,EAAjF,KAAgH8F,MAAM,CAAC1G,aAAP,KAAyB2D,kBAA1B,IAAkDgD,MAAM,CAAC3G,aAAP,KAAyB2D,kBAA1L,KAAkN4D,mBAAmB,CAACb,MAAD,EAASC,MAAT,CAArO,IAA0PD,MAAM,CAAC1G,aAAP,KAAyB2G,MAAM,CAAC3G,aAAP,EAAzB,GAAkD0D,kBAAhT,EAAqU;AACjU,eAAO,IAAP;AACH,OAFD,MAEO;AACH,eAAO,KAAP;AACH;AACJ;;AAED,aAASoD,YAAT,GAAwB;AACpB,UAAIW,SAAJ;;AACA,UAAIrE,cAAc,CAAC/E,MAAf,GAAwB,CAA5B,EAA+B;AAC3BoJ,QAAAA,SAAS,GAAGrE,cAAc,CAACV,GAAf,EAAZ;AACH,OAFD,MAEO;AACH+E,QAAAA,SAAS,GAAG,IAAIjJ,SAAJ,CAAckH,SAAd,CAAZ;AACH;;AACD,aAAO+B,SAAP;AACH;;AAED,aAASC,aAAT,CAAuBC,UAAvB,EAAmCC,QAAnC,EAA6C9J,KAA7C,EAAoDE,GAApD,EAAyD;AACrD,UAAI6J,MAAM,GAAG,KAAb,CADqD,CAErD;;AACA,UAAKF,UAAU,KAAK7J,KAAhB,IAA2B8J,QAAQ,KAAK5J,GAA5C,EAAkD;AAC9C6J,QAAAA,MAAM,GAAG,IAAT;AACH,OAFD,CAGA;AAHA,WAIK,IAAKF,UAAU,IAAI3J,GAAf,IAAwB4J,QAAQ,GAAG9J,KAAvC,EAA+C;AAChD+J,UAAAA,MAAM,GAAG,IAAT;AACH;;AACD,aAAOA,MAAP;AACH;;AAED,aAASC,yBAAT,CAAmCC,YAAnC,EAAiDJ,UAAjD,EAA6DK,UAA7D,EAAyEC,QAAzE,EAAmFlL,OAAnF,EAA4F;AACxF,UAAI8K,MAAM,GAAG,IAAb,CADwF,CAExF;;AACA,UAAKE,YAAY,KAAK,IAAlB,IAA4BA,YAAY,GAAIJ,UAAU,GAAG5K,OAAO,CAACY,UAArE,EAAmF;AAC/E;AACA,YAAIgK,UAAU,GAAGK,UAAjB,EAA6B;AACzB;AACA,cAAIL,UAAU,IAAIM,QAAlB,EAA4B;AACxB;AACA,gBAAIF,YAAY,KAAK,IAArB,EAA2B;AACvBF,cAAAA,MAAM,GAAGK,kCAAkC,CAACnL,OAAD,EAAUiL,UAAV,EAAsBC,QAAtB,CAA3C;AACH,aAFD,MAEO;AACHJ,cAAAA,MAAM,GAAGK,kCAAkC,CAACnL,OAAD,EAAUa,IAAI,CAACuK,GAAL,CAASJ,YAAT,EAAuBC,UAAvB,CAAV,EAA8CC,QAA9C,CAA3C;AACH;AACJ,WAPD,CAQA;AARA,eASK;AACD;AACA,kBAAIF,YAAY,KAAK,IAArB,EAA2B;AACvBF,gBAAAA,MAAM,GAAGK,kCAAkC,CAACnL,OAAD,EAAUiL,UAAV,EAAuBL,UAAU,GAAG5K,OAAO,CAACY,UAA5C,CAA3C;AACH,eAFD,MAEO;AACHkK,gBAAAA,MAAM,GAAGK,kCAAkC,CAACnL,OAAD,EAAUa,IAAI,CAACuK,GAAL,CAAUJ,YAAY,GAAGhL,OAAO,CAACY,UAAjC,EAA8CqK,UAA9C,CAAV,EAAsEL,UAAU,GAAG5K,OAAO,CAACY,UAA3F,CAA3C;AACH;AACJ;AACJ;AACJ;;AACD,aAAOkK,MAAP;AACH;;AAED,aAASO,YAAT,CAAsBC,KAAtB,EAA6B;AACzB,UAAIA,KAAK,CAAC7H,QAAN,EAAJ,EAAsB;AAClB5D,QAAAA,KAAK,CAAC0F,MAAN,CAAa,YAAW;AACpB,iBAAO+F,KAAK,CAAC7H,QAAN,EAAP;AACH,SAFD,EAEG,UAASgC,MAAT,EAAiB;AAChB8F,UAAAA,UAAU,CAAC9F,MAAD,EAAS,GAAT,CAAV;AACH,SAJD,EAIG,UAASL,GAAT,EAAc;AACbkG,UAAAA,KAAK,CAAC1G,OAAN;AACAyB,UAAAA,cAAc,CAAC5F,IAAf,CAAoB6K,KAApB;AACH,SAPD;AAQH,OATD,MASO;AACHA,QAAAA,KAAK,CAAC1G,OAAN;AACAyB,QAAAA,cAAc,CAAC5F,IAAf,CAAoB6K,KAApB;AACH;AACJ,KA7PiD,CA+PlD;AACA;AACA;;;AACA,QAAIE,iBAAiB,GAAG3L,KAAK,CAAC4L,KAAN,CAAY,UAASzL,OAAT,EAAkBkF,QAAlB,EAA4B;AAC5DA,MAAAA,QAAQ,CAAC,IAAD,EAAOwG,YAAY,CAAC1L,OAAD,CAAnB,CAAR;AACH,KAFuB,EAErB,CAFqB,CAAxB;;AAIA,aAAS0L,YAAT,CAAsB1L,OAAtB,EAA+B;AAC3B,UAAI8K,MAAM,GAAG,EAAb;AACA,UAAIa,cAAc,GAAG3L,OAAO,CAACe,KAA7B;AACA,UAAI6K,YAAY,GAAG5L,OAAO,CAACiB,GAA3B;AACA,UAAI4K,wBAAwB,GAAGhL,IAAI,CAACiL,IAAL,CAAUrF,qBAAqB,GAAGzG,OAAO,CAACgB,UAA1C,CAA/B;AACA,UAAI+K,uBAAuB,GAAGlL,IAAI,CAACiL,IAAL,CAAUpF,oBAAoB,GAAG1G,OAAO,CAACgB,UAAzC,CAA9B;AACA,UAAIiK,UAAU,GAAGU,cAAc,GAAGE,wBAAwB,GAAG7L,OAAO,CAACY,UAArE;AACA,UAAIsK,QAAQ,GAAGU,YAAY,GAAGG,uBAAuB,GAAG/L,OAAO,CAACY,UAAhE;AACA,UAAIoL,aAAa,GAAG,EAApB;AACA,UAAIC,eAAe,GAAG,EAAtB;AACA,UAAIC,QAAQ,GAAG,CAAC,CAAhB;AACA,UAAIC,YAAY,GAAG,IAAnB;AACA,UAAIC,iBAAiB,GAAG,IAAxB;;AAEA,UAAIC,YAAY,GAAG,UAASC,EAAT,EAAa;AAC5B,eAAOA,EAAE,CAACvJ,QAAH,EAAP;AACH,OAFD;;AAIAmE,MAAAA,cAAc,GAAG,CAAjB,CAlB2B,CAmB3B;;AACA,aAAOX,YAAY,CAACjF,MAAb,GAAsB,CAA7B,EAAgC;AAC5B6K,QAAAA,YAAY,GAAG5F,YAAY,CAACgG,KAAb,EAAf;AACAL,QAAAA,QAAQ,GAAGvM,CAAC,CAAC6M,WAAF,CAAclG,YAAd,EAA4B6F,YAA5B,EAA0CE,YAA1C,CAAX;AACA/F,QAAAA,YAAY,CAACmG,MAAb,CAAoBP,QAApB,EAA8B,CAA9B,EAAiCC,YAAjC;AACH;;AAED,UAAI7F,YAAY,CAAChF,MAAb,GAAsB,CAA1B,EAA6B;AACzB3B,QAAAA,CAAC,CAACmJ,IAAF,CAAOxC,YAAP,EAAqB,UAASgF,KAAT,EAAgBoB,KAAhB,EAAuB;AACxC,cAAIC,eAAe,GAAG,KAAtB;AACA,cAAIC,eAAe,GAAG,IAAtB;AACA,cAAIC,cAAc,GAAG,IAArB;AACA,cAAI7B,YAAY,GAAG,IAAnB;AACA,cAAI8B,OAAO,GAAGxB,KAAK,CAACvI,QAAN,EAAd;AACA,cAAIgK,KAAK,GAAGzB,KAAK,CAACtI,MAAN,EAAZ;;AAEA,cAAIsI,KAAK,CAAC1H,kBAAN,EAAJ,EAAgC;AAC5ByH,YAAAA,YAAY,CAACC,KAAD,CAAZ;AACA,mBAF4B,CAG5B;AACH,WAZuC,CAcxC;;;AACA,cAAKtL,OAAO,CAACM,OAAR,KAAoBgL,KAAK,CAACnI,UAAN,EAArB,IAA4CjC,mBAAmB,CAAClB,OAAO,CAACQ,QAAT,EAAmB8K,KAAK,CAAClI,WAAN,EAAnB,CAA/D,IAA0GlC,mBAAmB,CAAClB,OAAO,CAACU,SAAT,EAAoB4K,KAAK,CAACjI,YAAN,EAApB,CAAjI,EAA4K;AACxK,gBAAI+I,iBAAiB,KAAK,IAA1B,EAAgC;AAC5BpB,cAAAA,YAAY,GAAGoB,iBAAiB,CAACpJ,MAAlB,EAAf;AACH,aAHuK,CAKxK;;;AACA4J,YAAAA,eAAe,GAAG7B,yBAAyB,CAACC,YAAD,EAAe8B,OAAf,EAAwB7B,UAAxB,EAAoCC,QAApC,EAA8ClL,OAA9C,CAA3C;;AACA,gBAAK4M,eAAe,KAAK,IAArB,IAA+BA,eAAe,CAACtL,MAAhB,GAAyB,CAA5D,EAAgE;AAC5D0L,cAAAA,KAAK,CAACC,SAAN,CAAgBxM,IAAhB,CAAqByM,KAArB,CAA2BjB,eAA3B,EAA4CW,eAA5C;AACA/M,cAAAA,KAAK,CAACoJ,MAAN,CAAa2D,eAAb,EAA8BxF,WAA9B,EAA2C,UAAS+B,IAAT,EAAemC,KAAf,EAAsBpG,QAAtB,EAAgC;AACvEA,gBAAAA,QAAQ,CAAC,IAAD,EAAOiE,IAAI,GAAGmC,KAAK,CAAChI,WAAN,EAAd,CAAR;AACH,eAFD,EAEG,UAAS8B,GAAT,EAAcC,MAAd,EAAsB;AACrB+B,gBAAAA,WAAW,GAAG/B,MAAd;AACH,eAJD;AAKA2H,cAAAA,KAAK,CAACC,SAAN,CAAgBxM,IAAhB,CAAqByM,KAArB,CAA2BpC,MAA3B,EAAmC8B,eAAnC;AACH;;AAEDD,YAAAA,eAAe,GAAGhC,aAAa,CAACmC,OAAD,EAAUC,KAAV,EAAiB9B,UAAjB,EAA6BC,QAA7B,CAA/B;;AACA,gBAAIyB,eAAJ,EAAqB;AACjB,kBAAIrB,KAAK,CAAC/H,GAAN,KAAc,CAAlB,EAAqB;AACjBuH,gBAAAA,MAAM,CAACrK,IAAP,CAAY6K,KAAZ;AACAnE,gBAAAA,SAAS,IAAImE,KAAK,CAAChI,WAAN,EAAb;AACH,eAHD,MAGO;AACH,oBAAI,gBAAgB,OAAOwC,OAAvB,IAAkCA,OAAtC,EAA+C;AAC3CA,kBAAAA,OAAO,CAACqE,GAAR,CAAY,oFAAZ;AACH;AACJ;AACJ,aATD,MASO;AACHmB,cAAAA,KAAK,CAACnH,eAAN;AACH;;AACD8H,YAAAA,eAAe,CAACxL,IAAhB,CAAqB6K,KAArB,EA9BwK,CAgCxK;;AACA,gBAAKc,iBAAiB,KAAK,IAAvB,IAAgC3B,oBAAoB,CAAC2B,iBAAD,EAAoBd,KAApB,CAAxD,EAAoF;AAChF5B,cAAAA,WAAW,CAAC0C,iBAAD,EAAoBd,KAApB,EAA2B,UAASlG,GAAT,EAAc+H,MAAd,EAAsB;AACxD,oBAAI/H,GAAJ,EAAS;AACL;AACA;AACA,sBAAI,gBAAgB,OAAOU,OAAvB,IAAkCA,OAAtC,EAA+C;AAC3CA,oBAAAA,OAAO,CAACC,KAAR,CAAcX,GAAd;AACH;AACJ,iBAND,MAMO;AACH;AACA;AACAmB,kBAAAA,YAAY,CAAC9F,IAAb,CAAkB0M,MAAlB;AACH;AACJ,eAZU,CAAX;AAaH;;AACDf,YAAAA,iBAAiB,GAAGd,KAApB;AACH,WAjDD,MAiDO;AACHA,YAAAA,KAAK,CAACnH,eAAN,GADG,CAEH;;AACA8H,YAAAA,eAAe,CAACxL,IAAhB,CAAqB6K,KAArB;AACH,WApEuC,CAsExC;AACA;;;AACA,cAAIoB,KAAK,KAAMpG,YAAY,CAAChF,MAAb,GAAsB,CAArC,EAAyC;AACrC;AACA,gBAAI8K,iBAAiB,KAAK,IAA1B,EAAgC;AAC5B;AACA,kBAAKA,iBAAiB,CAACpJ,MAAlB,KAA6BhD,OAAO,CAACY,UAAtC,GAAoDsK,QAAxD,EAAkE;AAC9D2B,gBAAAA,cAAc,GAAG1B,kCAAkC,CAACnL,OAAD,EAAUa,IAAI,CAACuK,GAAL,CAAS2B,KAAK,GAAG/M,OAAO,CAACY,UAAzB,EAAqCqK,UAArC,CAAV,EAA4DC,QAA5D,CAAnD;AACA8B,gBAAAA,KAAK,CAACC,SAAN,CAAgBxM,IAAhB,CAAqByM,KAArB,CAA2BjB,eAA3B,EAA4CY,cAA5C;AACAhN,gBAAAA,KAAK,CAACoJ,MAAN,CAAa4D,cAAb,EAA6BzF,WAA7B,EAA0C,UAAS+B,IAAT,EAAemC,KAAf,EAAsBpG,QAAtB,EAAgC;AACtEA,kBAAAA,QAAQ,CAAC,IAAD,EAAOiE,IAAI,GAAGmC,KAAK,CAAChI,WAAN,EAAd,CAAR;AACH,iBAFD,EAEG,UAAS8B,GAAT,EAAcC,MAAd,EAAsB;AACrB+B,kBAAAA,WAAW,GAAG/B,MAAd;AACH,iBAJD;AAKA2H,gBAAAA,KAAK,CAACC,SAAN,CAAgBxM,IAAhB,CAAqByM,KAArB,CAA2BpC,MAA3B,EAAmC+B,cAAnC;AACH;AACJ;AACJ,WAvFuC,CAyFxC;;;AACA,cAAIO,MAAM,GAAGzN,CAAC,CAAC6M,WAAF,CAAcR,aAAd,EAA6BV,KAA7B,EAAoC,UAASgB,EAAT,EAAa;AAC1D,mBAAOA,EAAE,CAAClI,eAAH,EAAP;AACH,WAFY,CAAb;;AAGA4H,UAAAA,aAAa,CAACS,MAAd,CAAqBW,MAArB,EAA6B,CAA7B,EAAgC9B,KAAhC;AACApE,UAAAA,cAAc,IAAIoE,KAAK,CAAChI,WAAN,EAAlB;AACH,SA/FD;AAgGH,OA3H0B,CA6H3B;;;AACA,UAAIwH,MAAM,CAACxJ,MAAP,KAAkB,CAAtB,EAAyB;AACrBwJ,QAAAA,MAAM,GAAGK,kCAAkC,CAACnL,OAAD,EAAUiL,UAAV,EAAsBC,QAAtB,CAA3C;AACA8B,QAAAA,KAAK,CAACC,SAAN,CAAgBxM,IAAhB,CAAqByM,KAArB,CAA2BjB,eAA3B,EAA4CnB,MAA5C;AACAjL,QAAAA,KAAK,CAACoJ,MAAN,CAAa6B,MAAb,EAAqB1D,WAArB,EAAkC,UAAS+B,IAAT,EAAemC,KAAf,EAAsBpG,QAAtB,EAAgC;AAC9DA,UAAAA,QAAQ,CAAC,IAAD,EAAOiE,IAAI,GAAGmC,KAAK,CAAChI,WAAN,EAAd,CAAR;AACH,SAFD,EAEG,UAAS8B,GAAT,EAAcC,MAAd,EAAsB;AACrB+B,UAAAA,WAAW,GAAG/B,MAAd;AACH,SAJD;AAKH;;AACDiB,MAAAA,YAAY,GAAG,EAAf;AACAA,MAAAA,YAAY,GAAG2F,eAAf;AACAA,MAAAA,eAAe,GAAG,EAAlB;AAEApM,MAAAA,KAAK,CAAC0F,MAAN,CAAa,YAAW;AACpB,eAAO2B,cAAc,GAAG,IAAjB,GAAwBL,gBAA/B;AACH,OAFD,EAEG,YAAW;AACV,YAAIwG,WAAW,GAAGnG,cAAc,GAAG,IAAjB,GAAwBL,gBAA1C;AACA8B,QAAAA,SAAS,CAAC,cAAD,EAAiB;AACtB,qBAAYzB,cADU;AAEtB,qBAAYmG;AAFU,SAAjB,CAAT;AAIA,YAAI7D,SAAS,GAAG,EAAhB;AACA,YAAIC,OAAO,GAAG,IAAd;AACA,YAAI6D,iBAAiB,GAAG,CAAxB;;AACA,eAAQA,iBAAiB,GAAGD,WAArB,IAAsCrB,aAAa,CAAC1K,MAAd,GAAuB,CAApE,EAAwE;AACpEmI,UAAAA,OAAO,GAAGuC,aAAa,CAACrG,GAAd,EAAV;;AACA,cAAI8D,OAAO,KAAKjI,SAAhB,EAA2B;AACvB8L,YAAAA,iBAAiB,IAAI7D,OAAO,CAACnG,WAAR,EAArB;AACAkG,YAAAA,SAAS,CAAC/I,IAAV,CAAegJ,OAAf;AACH;AACJ;;AACD,YAAID,SAAS,CAAClI,MAAV,GAAmB,CAAvB,EAA0B;AACtBiI,UAAAA,KAAK,CAACC,SAAD,CAAL;AACAtC,UAAAA,cAAc,GAAGA,cAAc,GAAGoG,iBAAlC;AACA3E,UAAAA,SAAS,CAAC,eAAD,EAAkB;AACvB,uBAAYzB,cADW;AAEvB,uBAAYoG;AAFW,WAAlB,CAAT;AAIH;AACJ,OA1BD,EA0BG,YAAW,CACV;AACH,OA5BD;AA6BA,aAAOxC,MAAP;AACH;;AAED,aAASK,kCAAT,CAA4CoC,aAA5C,EAA2DxM,KAA3D,EAAkEE,GAAlE,EAAuE;AACnE,UAAIuM,MAAM,GAAG,EAAb;AACA,UAAIC,eAAe,GAAG5M,IAAI,CAACC,KAAL,CAAW,CAACG,GAAG,GAAGF,KAAP,IAAgBwM,aAAa,CAAC3M,UAAzC,IAAuD,CAA7E;AACA,UAAI8M,YAAY,GAAG7M,IAAI,CAACiL,IAAL,CAAU2B,eAAe,GAAG9G,kBAA5B,CAAnB;AACA,UAAItF,CAAC,GAAG,CAAR;AACA,UAAIrB,OAAJ;AACA,UAAIsL,KAAK,GAAG,IAAZ;;AACA,WAAMjK,CAAC,GAAG,CAAV,EAAaA,CAAC,GAAGqM,YAAjB,EAA+BrM,CAAC,EAAhC,EAAoC;AAChCiK,QAAAA,KAAK,GAAGvB,YAAY,EAApB;AACA/J,QAAAA,OAAO,GAAGL,CAAC,CAACqK,KAAF,CAAQuD,aAAR,CAAV;AACAvN,QAAAA,OAAO,CAACe,KAAR,GAAgBA,KAAK,GAAGM,CAAC,IAAIkM,aAAa,CAAC3M,UAAd,GAA2B+F,kBAA/B,CAAzB;AACA3G,QAAAA,OAAO,CAACgB,UAAR,GAAqBH,IAAI,CAAC8M,GAAL,CAAShH,kBAAT,EAA6B8G,eAAe,GAAIpM,CAAC,GAAGsF,kBAApD,CAArB;AACA3G,QAAAA,OAAO,CAACiB,GAAR,GAAcjB,OAAO,CAACe,KAAR,GAAgB,CAACf,OAAO,CAACgB,UAAR,GAAqB,CAAtB,IAA2BuM,aAAa,CAAC3M,UAAvE;AACA0K,QAAAA,KAAK,CAACzG,OAAN,CAAc7E,OAAd,EAAuB2E,UAAU,CAAC4I,aAAa,CAACjN,OAAf,CAAjC;;AACA,YAAIgL,KAAK,CAAC/H,GAAN,KAAc,CAAlB,EAAqB;AACjBiK,UAAAA,MAAM,CAAC/M,IAAP,CAAY6K,KAAZ;AACH,SAFD,MAEO;AACH,cAAI,gBAAgB,OAAOxF,OAAvB,IAAkCA,OAAtC,EAA+C;AAC3CA,YAAAA,OAAO,CAACC,KAAR,CAAc,+BAAd;AACH;AACJ;AACJ;;AACD,aAAOyH,MAAP;AACH;AAED;;;;;;;AAMA,aAASpD,QAAT,CAAkBwD,MAAlB,EAA0BC,MAA1B,EAAkCC,SAAlC,EAA6CC,UAA7C,EAAyDC,WAAzD,EAAsEC,WAAtE,EAAmFC,KAAnF,EAA0FhJ,QAA1F,EAAoG;AAChG,UAAIiJ,aAAa,GAAGxO,CAAC,CAACS,QAAF,CAAWyN,MAAX,CAApB;;AACA,UAAIO,EAAE,GAAG,CAAT;AACA,UAAIC,EAAE,GAAG,CAAT;AACA,UAAIpN,GAAG,GAAG,CAAV;AACApB,MAAAA,KAAK,CAACiJ,IAAN,CAAWgF,SAAX,EAAsB,UAASQ,GAAT,EAAcC,SAAd,EAAyB;AAC3C,YAAIX,MAAM,CAACU,GAAD,CAAN,KAAgB9M,SAApB,EAA+B;AAC3BoM,UAAAA,MAAM,CAACU,GAAD,CAAN,GAAc,EAAd;AACH;;AACDzO,QAAAA,KAAK,CAACiJ,IAAN,CAAWiF,UAAX,EAAuB,UAASS,KAAT,EAAgBC,WAAhB,EAA6B;AAChD,cAAIC,cAAc,GAAG,KAArB;;AACA,cAAId,MAAM,CAACU,GAAD,CAAN,CAAYE,KAAZ,MAAuBhN,SAA3B,EAAsC;AAClCoM,YAAAA,MAAM,CAACU,GAAD,CAAN,CAAYE,KAAZ,IAAqB,EAArB;AACH;;AACD,cAAIL,aAAJ,EAAmB;AACf,gBAAI,CAACxO,CAAC,CAACS,QAAF,CAAWyN,MAAM,CAACS,GAAD,CAAjB,CAAD,IAA4B,CAAC3O,CAAC,CAACY,OAAF,CAAUsN,MAAM,CAACS,GAAD,CAAN,CAAYE,KAAZ,CAAV,CAAjC,EAAgE;AAC5DE,cAAAA,cAAc,GAAG,IAAjB;AAEH,aAHD,MAGO,IAAIb,MAAM,CAACS,GAAD,CAAN,CAAYE,KAAZ,EAAmBlN,MAAnB,GAA6B2M,WAAW,GAAGC,KAA/C,EAAuD;AAC1DQ,cAAAA,cAAc,GAAG,IAAjB;;AACA,kBAAI,gBAAgB,OAAO5I,OAAvB,IAAkCA,OAAtC,EAA+C;AAC3CA,gBAAAA,OAAO,CAACC,KAAR,CAAc,sCAAsC8H,MAAM,CAACS,GAAD,CAAN,CAAYE,KAAZ,EAAmBlN,MAAzD,GAAkE,uBAAlE,GAA4FgN,GAA5F,GAAkG,iBAAlG,GAAsHE,KAAtH,GAA8H,QAA9H,IAA0IP,WAAW,GAAGC,KAAxJ,IAAiK,qDAAjK,GAAuNnH,cAAvN,GAAsO,IAApP;AACH;AACJ;AACJ;;AACD,cAAI2H,cAAJ,EAAoB;AAChBN,YAAAA,EAAE,GAAGJ,WAAL;AACA/M,YAAAA,GAAG,GAAG+M,WAAW,GAAGE,KAApB;;AACA,mBAAOE,EAAE,GAAGnN,GAAZ,EAAiB;AACb2M,cAAAA,MAAM,CAACU,GAAD,CAAN,CAAYE,KAAZ,EAAmBJ,EAAE,EAArB,IAA2BrH,cAA3B;AACH;AACJ,WAND,MAMO,IAAIoH,aAAJ,EAAmB;AACtBC,YAAAA,EAAE,GAAGJ,WAAL;AACAK,YAAAA,EAAE,GAAGJ,WAAL;AACAhN,YAAAA,GAAG,GAAG+M,WAAW,GAAGE,KAApB;;AACA,mBAAOE,EAAE,GAAGnN,GAAZ,EAAiB;AACb2M,cAAAA,MAAM,CAACU,GAAD,CAAN,CAAYE,KAAZ,EAAmBJ,EAAE,EAArB,IAA2BP,MAAM,CAACS,GAAD,CAAN,CAAYE,KAAZ,EAAmBH,EAAE,EAArB,CAA3B;AACH;AACJ,WAPM,MAOA;AACHD,YAAAA,EAAE,GAAGJ,WAAL;AACA/M,YAAAA,GAAG,GAAG+M,WAAW,GAAGE,KAApB;;AACA,mBAAOE,EAAE,GAAGnN,GAAZ,EAAiB;AACb2M,cAAAA,MAAM,CAACU,GAAD,CAAN,CAAYE,KAAZ,EAAmBJ,EAAE,EAArB,IAA2BP,MAA3B;AACH;AACJ;;AACDY,UAAAA,WAAW;AACd,SArCD,EAqCG,UAASrJ,GAAT,EAAc;AACb;AACAmJ,UAAAA,SAAS;AACZ,SAxCD;AAyCH,OA7CD,EA6CG,UAASnJ,GAAT,EAAc;AACb;AACAF,QAAAA,QAAQ,CAACE,GAAD,EAAMwI,MAAN,CAAR;AACH,OAhDD;AAiDH;;AAED,aAASe,iBAAT,CAA2BC,WAA3B,EAAwCC,cAAxC,EAAwDC,gBAAxD,EAA0E;AACtE,UAAI9O,OAAO,GAAGL,CAAC,CAACqK,KAAF,CAAQ4E,WAAR,CAAd;;AAEA,UAAI,CAACjP,CAAC,CAACqF,UAAF,CAAa6J,cAAb,CAAL,EAAmC;AAC/B,cAAM,mCAAN;AACH;;AAED,UAAIlK,UAAU,CAAC3E,OAAO,CAACM,OAAT,CAAV,KAAgC,IAApC,EAA0C;AACtC,cAAM,uCAAuCN,OAAO,CAACM,OAA/C,GAAyD,4BAA/D;AACH,OATqE,CAWtE;AACA;;;AACA,UAAIkG,eAAe,CAACxG,OAAO,CAACM,OAAT,CAAf,KAAqCkB,SAAzC,EAAoD;AAChD,YAAKgF,eAAe,CAACxG,OAAO,CAACM,OAAT,CAAf,CAAiCM,UAAjC,KAAgDZ,OAAO,CAACY,UAAzD,IAAyEC,IAAI,CAACkO,GAAL,CAASvI,eAAe,CAACxG,OAAO,CAACM,OAAT,CAAf,CAAiCS,KAAjC,GAAyCf,OAAO,CAACe,KAA1D,IAAmEf,OAAO,CAACY,UAA3E,KAA0F,CAAvK,EAA2K;AACvKoO,UAAAA,KAAK,CAAChP,OAAO,CAACM,OAAT,CAAL;AACH;AACJ;;AACDkG,MAAAA,eAAe,CAACxG,OAAO,CAACM,OAAT,CAAf,GAAmC;AAC/BS,QAAAA,KAAK,EAAGf,OAAO,CAACe,KADe;AAE/BH,QAAAA,UAAU,EAAGZ,OAAO,CAACY;AAFU,OAAnC;AAKA4K,MAAAA,iBAAiB,CAAC/K,IAAlB,CAAuBT,OAAvB,EAAgC,UAASoF,GAAT,EAAc6J,UAAd,EAA0B;AACtDC,QAAAA,kBAAkB,CAACD,UAAD,EAAajP,OAAb,EAAsB6O,cAAtB,EAAsCC,gBAAtC,CAAlB;AACH,OAFD;AAIH;;AAED,aAASI,kBAAT,CAA4BD,UAA5B,EAAwCjP,OAAxC,EAAiD6O,cAAjD,EAAiEC,gBAAjE,EAAmF;AAC/E,UAAIK,MAAM,GAAG,IAAb;AACA,UAAIC,cAAc,GAAG,KAArB;AACA,UAAI/J,MAAM,GAAG,EAAb;;AAEA,UAAI1F,CAAC,CAACqF,UAAF,CAAa8J,gBAAb,CAAJ,EAAoC;AAChCM,QAAAA,cAAc,GAAG,IAAjB;AACH;;AACDzG,MAAAA,SAAS,CAAC,cAAD,EAAiB3I,OAAjB,CAAT;AACAqF,MAAAA,MAAM,CAACgK,KAAP,GAAe1P,CAAC,CAAC2P,KAAF,CAAQtP,OAAO,CAACe,KAAhB,EAAuBf,OAAO,CAACiB,GAAR,GAAcjB,OAAO,CAACY,UAA7C,EAAyDZ,OAAO,CAACY,UAAjE,CAAf;AACAyE,MAAAA,MAAM,CAACrD,IAAP,GAAc,EAAd;AAEAnC,MAAAA,KAAK,CAACiJ,IAAN,CAAWmG,UAAX,EAAuB,UAASvE,SAAT,EAAoBjF,MAApB,EAA4B;AAC/C,YAAI8J,EAAE,GAAG7E,SAAS,CAAC5H,UAAV,EAAT;AAEA,YAAI0M,YAAY,GAAGxI,GAAnB;AACA,YAAIyI,UAAU,GAAGzI,GAAjB;AACA,YAAI0I,gBAAgB,GAAG1I,GAAvB;AACA,YAAI2I,cAAc,GAAG3I,GAArB;AACA,YAAI4I,gBAAgB,GAAG5I,GAAvB;AACA,YAAI6I,UAAU,GAAG7I,GAAjB;;AAEA,YAAI,CAAC2D,aAAa,CAAC4E,EAAE,CAACxO,KAAJ,EAAWwO,EAAE,CAACtO,GAAd,EAAmBjB,OAAO,CAACe,KAA3B,EAAkCf,OAAO,CAACiB,GAA1C,CAAlB,EAAkE;AAC9D;AACA;AACA;AACAyJ,UAAAA,SAAS,CAACzF,YAAV,CAAuB,YAAU;AAC7ByF,YAAAA,SAAS,CAAClH,KAAV;AACH,WAFD,EAJ8D,CAQ9D;;AACAiC,UAAAA,MAAM;AACN;AACH;;AAED,YAAI8J,EAAE,CAACxO,KAAH,GAAWf,OAAO,CAACe,KAAvB,EAA8B;AAC1ByO,UAAAA,YAAY,GAAGxP,OAAO,CAACe,KAAvB;AACA6O,UAAAA,gBAAgB,GAAG/O,IAAI,CAACC,KAAL,CAAW,CAACd,OAAO,CAACe,KAAR,GAAgBwO,EAAE,CAACxO,KAApB,IAA6Bf,OAAO,CAACY,UAAhD,CAAnB;AACH,SAHD,MAGO;AACH4O,UAAAA,YAAY,GAAGD,EAAE,CAACxO,KAAlB;AACA6O,UAAAA,gBAAgB,GAAG,CAAnB;AACH;;AACDF,QAAAA,gBAAgB,GAAG/P,CAAC,CAAC4B,OAAF,CAAU8D,MAAM,CAACgK,KAAjB,EAAwBG,YAAxB,CAAnB;;AACA,YAAIE,gBAAgB,KAAK,CAAC,CAA1B,EAA6B;AACzB,gBAAMhF,SAAS,CAAC7H,KAAV,KAAoB,gGAA1B;AACH;;AAED,YAAI0M,EAAE,CAACtO,GAAH,GAASjB,OAAO,CAACiB,GAArB,EAA0B;AACtBwO,UAAAA,UAAU,GAAGzP,OAAO,CAACiB,GAArB;AACA0O,UAAAA,cAAc,GAAGtK,MAAM,CAACgK,KAAP,CAAa/N,MAAb,GAAsB,CAAvC;AACH,SAHD,MAGO;AACHmO,UAAAA,UAAU,GAAGF,EAAE,CAACtO,GAAhB;AACA0O,UAAAA,cAAc,GAAGhQ,CAAC,CAAC4B,OAAF,CAAU8D,MAAM,CAACgK,KAAjB,EAAwBE,EAAE,CAACtO,GAA3B,EAAgC,IAAhC,CAAjB;AACH;;AACD4O,QAAAA,UAAU,GAAGF,cAAc,GAAGD,gBAAjB,GAAoC,CAAjD,CA1C+C,CA4C/C;;AACAhF,QAAAA,SAAS,CAACzF,YAAV,CAAuB,UAASG,GAAT,EAAcpD,IAAd,EAAoB;AACvC,cAAI8N,SAAS,GAAG9N,IAAhB;;AAEA,cAAIoD,GAAJ,EAAS;AACL,gBAAI+J,MAAM,KAAK,IAAf,EAAqB;AACjBA,cAAAA,MAAM,GAAG,EAAT;AACH;;AACDA,YAAAA,MAAM,CAAC1O,IAAP,CAAY;AACRM,cAAAA,KAAK,EAAGwO,EAAE,CAACxO,KADH;AAERE,cAAAA,GAAG,EAAGsO,EAAE,CAACtO,GAFD;AAGR8E,cAAAA,KAAK,EAAGX;AAHA,aAAZ,EAJK,CAUL;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA,gBAAI0B,mBAAmB,IAAI,CAAC9E,IAA5B,EAAkC;AAC9B8N,cAAAA,SAAS,GAAG/I,cAAZ;AACH,aAtBI,CAuBL;;;AACA2D,YAAAA,SAAS,CAACpG,gBAAV;AACH;;AACD8F,UAAAA,QAAQ,CAAC/E,MAAM,CAACrD,IAAR,EAAc8N,SAAd,EAAyBP,EAAE,CAAC/O,QAA5B,EAAsC+O,EAAE,CAAC7O,SAAzC,EAAoDgP,gBAApD,EAAsEE,gBAAtE,EAAwFC,UAAxF,EAAoG,YAAW;AACnH,gBAAIT,cAAJ,EAAoB;AAChBN,cAAAA,gBAAgB,CAAC1J,GAAD,EAAMoK,YAAN,EAAoBC,UAApB,CAAhB;AACH;;AACD/E,YAAAA,SAAS,CAAClH,KAAV,GAJmH,CAMnH;;AACAiC,YAAAA,MAAM;AACT,WARO,CAAR;AASH,SAtCD;AAwCH,OArFD,EAqFG,UAASL,GAAT,EAAc;AACbyJ,QAAAA,cAAc,CAACM,MAAD,EAAS9J,MAAT,CAAd;AACAsD,QAAAA,SAAS,CAAC,eAAD,EAAkB3I,OAAlB,CAAT;AACH,OAxFD;AAyFH;;AAED,aAAS2E,UAAT,CAAoBrE,OAApB,EAA6B;AACzB,UAAI2G,QAAQ,CAAC3G,OAAD,CAAR,KAAsBkB,SAA1B,EAAqC;AACjCyF,QAAAA,QAAQ,CAAC3G,OAAD,CAAR,CAAkByP,SAAlB,GAA8B,CAAC9I,QAAQ,CAAC3G,OAAD,CAAR,CAAkByP,SAAlB,GAA8B,CAA/B,IAAoC9I,QAAQ,CAAC3G,OAAD,CAAR,CAAkB0P,SAAlB,CAA4B1O,MAA9F;AACA,eAAO2F,QAAQ,CAAC3G,OAAD,CAAR,CAAkB0P,SAAlB,CAA4B/I,QAAQ,CAAC3G,OAAD,CAAR,CAAkByP,SAA9C,EAAyDrK,EAAhE;AACH,OAHD,MAGO;AACH,eAAO,IAAP;AACH;AACJ;;AAED,aAASsJ,KAAT,CAAe1O,OAAf,EAAwB;AACpBX,MAAAA,CAAC,CAACmJ,IAAF,CAAOxC,YAAP,EAAqB,UAASgF,KAAT,EAAgB;AACjC,YAAKhL,OAAO,KAAKkB,SAAb,IAA4B8J,KAAK,CAACnI,UAAN,OAAuB7C,OAAvD,EAAiE;AAC7DgL,UAAAA,KAAK,CAAChH,gBAAN;AACH;AACJ,OAJD;;AAKA3E,MAAAA,CAAC,CAACmJ,IAAF,CAAOvC,YAAP,EAAqB,UAAS+E,KAAT,EAAgB;AACjC,YAAKhL,OAAO,KAAKkB,SAAb,IAA4B8J,KAAK,CAACnI,UAAN,OAAuB7C,OAAvD,EAAiE;AAC7DgL,UAAAA,KAAK,CAAChH,gBAAN;AACH;AACJ,OAJD;;AAKAqE,MAAAA,SAAS,CAAC,cAAD,EAAiBrI,OAAjB,CAAT;AACH,KAjqBiD,CAmqBlD;;AACA;;;;;;;;;;;;;AAWA,SAAK2P,eAAL,GAAuB,UAAS3P,OAAT,EAAkByB,OAAlB,EAA2B;AAC9C,UAAImO,QAAQ,GAAG,EAAf;;AACA,UAAIvQ,CAAC,CAACqF,UAAF,CAAajD,OAAb,CAAJ,EAA2B;AACvB,YAAIkF,QAAQ,CAAC3G,OAAD,CAAR,KAAsBkB,SAA1B,EAAqC;AACjCyF,UAAAA,QAAQ,CAAC3G,OAAD,CAAR,GAAoB;AAChByP,YAAAA,SAAS,EAAG,CADI;AAEhBC,YAAAA,SAAS,EAAG;AAFI,WAApB;AAIH;;AACDE,QAAAA,QAAQ,CAACrO,EAAT,GAAc,QAAQsE,gBAAgB,EAAtC;AACA+J,QAAAA,QAAQ,CAACxK,EAAT,GAAc3D,OAAd;AACAkF,QAAAA,QAAQ,CAAC3G,OAAD,CAAR,CAAkB0P,SAAlB,CAA4BvP,IAA5B,CAAiCyP,QAAjC;AACAvH,QAAAA,SAAS,CAAC,mBAAD,EAAsB;AAC3B,qBAAYrI,OADe;AAE3B,wBAAe4P,QAAQ,CAACrO;AAFG,SAAtB,CAAT;AAIH,OAdD,MAcO;AACH,cAAM,4BAAN;AACH;;AACD,aAAOqO,QAAQ,CAACrO,EAAhB;AACH,KApBD;;AAsBA,SAAKsO,kBAAL,GAA0B,UAAS7P,OAAT,EAAkB8P,UAAlB,EAA8B;AACpD,UAAIC,SAAS,GAAG,CAAhB;AACA,UAAIC,eAAe,GAAG,KAAtB;;AACA,UAAIrJ,QAAQ,CAAC3G,OAAD,CAAR,KAAsBkB,SAA1B,EAAqC;AACjC6O,QAAAA,SAAS,GAAGpJ,QAAQ,CAAC3G,OAAD,CAAR,CAAkB0P,SAAlB,CAA4B1O,MAAxC;AACA2F,QAAAA,QAAQ,CAAC3G,OAAD,CAAR,CAAkB0P,SAAlB,GAA8BrQ,CAAC,CAAC4Q,MAAF,CAAStJ,QAAQ,CAAC3G,OAAD,CAAR,CAAkB0P,SAA3B,EAAsC,UAASE,QAAT,EAAmB;AACnF,iBAAOA,QAAQ,CAACrO,EAAT,KAAgBuO,UAAvB;AACH,SAF6B,CAA9B;;AAGA,YAAInJ,QAAQ,CAAC3G,OAAD,CAAR,CAAkB0P,SAAlB,CAA4B1O,MAA5B,KAAuC,CAA3C,EAA8C;AAC1C,iBAAO2F,QAAQ,CAAC3G,OAAhB;AACAgQ,UAAAA,eAAe,GAAG,IAAlB;AACH,SAHD,MAGO,IAAID,SAAS,KAAKpJ,QAAQ,CAAC3G,OAAD,CAAR,CAAkB0P,SAAlB,CAA4B1O,MAA9C,EAAsD;AACzDgP,UAAAA,eAAe,GAAG,IAAlB;AACH;;AACD,YAAIA,eAAJ,EAAqB;AACjB3H,UAAAA,SAAS,CAAC,qBAAD,EAAwB;AAC7B,uBAAYrI,OADiB;AAE7B,0BAAe8P;AAFc,WAAxB,CAAT;AAIH;AACJ;AACJ,KArBD;AAuBA;;;;;;AAIA,SAAKI,UAAL,GAAkB,YAAW;AACzBxB,MAAAA,KAAK;AACLxI,MAAAA,eAAe,GAAG,EAAlB;AACAW,MAAAA,SAAS,GAAG,CAAZ;AACAC,MAAAA,WAAW,GAAG,CAAd;AACH,KALD;;AAOA,SAAKqJ,KAAL,GAAa,UAASzQ,OAAT,EAAkB0Q,aAAlB,EAAiC5B,gBAAjC,EAAmD;AAC5D/O,MAAAA,YAAY,CAACC,OAAD,CAAZ;AACA2O,MAAAA,iBAAiB,CAAC3O,OAAD,EAAU0Q,aAAV,EAAyB5B,gBAAzB,CAAjB;AACH,KAHD;;AAKA,SAAK6B,kBAAL,GAA0B,YAAW;AACjC,aAAOzJ,cAAP;AACH,KAFD;;AAIA,SAAK0J,gBAAL,GAAwB,YAAW;AAC/B,aAAO1J,cAAc,GAAGL,gBAAxB;AACH,KAFD;;AAIA,SAAKgK,WAAL,GAAmB,YAAW;AAC1B,aAAQ1J,SAAS,IAAIA,SAAS,GAAGC,WAAhB,CAAjB;AACH,KAFD;;AAIA,SAAK0J,WAAL,GAAmB,UAASlI,SAAT,EAAoB1D,QAApB,EAA8B;AAC7C,aAAO6D,gBAAgB,CAACH,SAAD,EAAY1D,QAAZ,CAAvB;AACH,KAFD;;AAIA,SAAK6L,cAAL,GAAsB,UAASnI,SAAT,EAAoBwH,UAApB,EAAgC;AAClD,aAAO9G,mBAAmB,CAACV,SAAD,EAAYwH,UAAZ,CAA1B;AACH,KAFD,CA5vBkD,CAgwBlD;;;AACA,QAAIhK,UAAU,CAACK,qBAAX,KAAqCjF,SAAzC,EAAoD;AAChD,UAAI7B,CAAC,CAACgB,QAAF,CAAWyF,UAAU,CAACK,qBAAtB,CAAJ,EAAkD;AAC9C,YAAIL,UAAU,CAACK,qBAAX,IAAoC,CAAxC,EAA2C;AACvCA,UAAAA,qBAAqB,GAAGL,UAAU,CAACK,qBAAnC;AACH;AACJ;AACJ;;AACD,QAAIL,UAAU,CAACM,oBAAX,KAAoClF,SAAxC,EAAmD;AAC/C,UAAI7B,CAAC,CAACgB,QAAF,CAAWyF,UAAU,CAACM,oBAAtB,CAAJ,EAAiD;AAC7C,YAAIN,UAAU,CAACM,oBAAX,IAAmC,CAAvC,EAA0C;AACtCA,UAAAA,oBAAoB,GAAGN,UAAU,CAACM,oBAAlC;AACH;AACJ;AACJ;;AACD,QAAIN,UAAU,CAACO,kBAAX,KAAkCnF,SAAtC,EAAiD;AAC7C,UAAI7B,CAAC,CAACgB,QAAF,CAAWyF,UAAU,CAACO,kBAAtB,CAAJ,EAA+C;AAC3C,YAAIP,UAAU,CAACO,kBAAX,GAAgC,CAApC,EAAuC;AACnCA,UAAAA,kBAAkB,GAAGP,UAAU,CAACO,kBAAhC;AACH;AACJ;AACJ;;AACD,QAAIP,UAAU,CAACQ,kBAAX,KAAkCpF,SAAtC,EAAiD;AAC7C,UAAI7B,CAAC,CAACgB,QAAF,CAAWyF,UAAU,CAACQ,kBAAtB,CAAJ,EAA+C;AAC3C,YAAKR,UAAU,CAACQ,kBAAX,GAAgC,CAAjC,IAAwCR,UAAU,CAACQ,kBAAX,GAAgCD,kBAA5E,EAAiG;AAC7FC,UAAAA,kBAAkB,GAAGR,UAAU,CAACQ,kBAAhC;AACH,SAFD,MAEO;AACHA,UAAAA,kBAAkB,GAAG,CAArB;AACH;AACJ;AACJ;;AACD,QAAIA,kBAAkB,GAAGD,kBAAzB,EAA6C;AACzCC,MAAAA,kBAAkB,GAAGD,kBAArB;AACH;;AACD,QAAIP,UAAU,CAACS,gBAAX,KAAgCrF,SAApC,EAA+C;AAC3C,UAAI7B,CAAC,CAACgB,QAAF,CAAWyF,UAAU,CAACS,gBAAtB,CAAJ,EAA6C;AACzC,YAAIT,UAAU,CAACS,gBAAX,GAA8B,CAAlC,EAAqC;AACjCA,UAAAA,gBAAgB,GAAGT,UAAU,CAACS,gBAA9B;AACH;AACJ;AACJ;;AACD,QAAIT,UAAU,CAACU,mBAAX,KAAmCtF,SAAvC,EAAkD;AAC9C,UAAI4E,UAAU,CAACU,mBAAX,KAAmC,KAAvC,EAA8C;AAC1CA,QAAAA,mBAAmB,GAAG,KAAtB;AACH;AACJ;;AAED,QAAIV,UAAU,CAACW,cAAX,KAA8BvF,SAAlC,EAA6C;AACzCuF,MAAAA,cAAc,GAAGX,UAAU,CAACW,cAA5B;AACH;AACJ,GAlzBD;AAozBA;;;;;AAGA,SAAOpF,YAAP;AACH,CAjtCmB,EAApB;;AAmtCAqP,MAAM,CAACC,OAAP,GAAiBnR,aAAjB","sourcesContent":["/**\n * Metolib.SplitterCache\n * =======================================\n *\n * See https://github.com/fmidev/metolib/wiki/SplitterCache for documentation.\n *\n * Requires:\n * - async.js (https://github.com/caolan/async)\n * - lodash.underscore.js (http://lodash.com/)\n *\n * Original author: Ilkka Rinne / Spatineo Inc. for the Finnish Meteorological Institute\n *\n *\n * This software may be freely distributed and used under the following MIT license:\n *\n * Copyright (c) 2017 Finnish Meteorological Institute\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the\n * Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\n\n// Strict mode for whole file.\n\"use strict\";\n\n// Requires lodash, async\nvar _ = require('lodash');\nvar async = require('async');\n// import _ from 'lodash';\n// import async from 'async';\n\nvar SplitterCache = (function(){\n\n    //Functions and variables shared with all instances:\n    var checkTaskDef = function(taskDef) {\n        var placeholder;\n        var startNudge = 0;\n        var endNudge = 0;\n        if (!_.isObject(taskDef)) {\n            throw 'taskdef must be an object';\n        }\n\n        if (!_.isString(taskDef.service)) {\n            throw 'taskDef must contain a \\'service\\' property of string type';\n        }\n\n        if (!_.isArray(taskDef.location)) {\n            if (!_.isString(taskDef.location)) {\n                throw 'taskDef must contain a \\'location\\' property of either an array or a string type';\n            } else {\n                placeholder = taskDef.location;\n                taskDef.location = [];\n                taskDef.location.push(placeholder);\n            }\n        }\n\n        if (!_.isArray(taskDef.parameter)) {\n            if (!_.isString(taskDef.parameter)) {\n                throw 'taskDef must contain a \\'parameter\\' property of either an array or a string type';\n            } else {\n                placeholder = taskDef.parameter;\n                taskDef.parameter = [];\n                taskDef.parameter.push(placeholder);\n            }\n        }\n\n        if (!_.isNumber(taskDef.resolution)) {\n            throw 'taskDef must contain a \\'resolution\\' property of numeric type';\n        } else if (taskDef.resolution > 0.5) {\n            taskDef.resolution = Math.round(taskDef.resolution);\n        } else {\n            throw 'taskDef.resolution must be a positive integer';\n        }\n\n        if (!_.isNumber(taskDef.start)) {\n            throw 'taskDef must contain a \\'start\\' property of numeric type';\n        }\n\n        if (_.isNumber(taskDef.pointCount)) {\n            if (taskDef.pointCount > 0) {\n                taskDef.end = taskDef.start + (taskDef.pointCount - 1) * taskDef.resolution;\n            } else {\n                throw 'taskDef.pointCount must be greater than zero';\n            }\n        } else if (_.isNumber(taskDef.end)) {\n            if (taskDef.end < taskDef.start) {\n                throw '\\'end\\' must be greater than or equal to \\'start\\'';\n            }\n            endNudge = (taskDef.end - taskDef.start) % taskDef.resolution;\n            if (endNudge !== 0) {\n                taskDef.end = taskDef.end + (taskDef.resolution - endNudge);\n            }\n            taskDef.pointCount = (taskDef.end - taskDef.start) / taskDef.resolution + 1;\n        } else {\n            throw 'taskDef must contain either \\'end\\' or \\'pointCount\\' property of numeric type';\n        }\n    };\n\n    var arrayEqualsAnyOrder = function(arr1, arr2) {\n        var i = 0;\n        if (_.isArray(arr1) && _.isArray(arr2)) {\n            if (arr1.length === arr2.length) {\n                for ( i = 0; i < arr1.length; i++) {\n                    if (_.indexOf(arr2, arr1[i]) === -1) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                return false;\n            }\n        } else if ((arr1 === undefined) || (arr1 === null) || (arr2 === undefined) || (arr2 === null)) {\n            return false;\n        } else {\n            return (arr1 === arr2);\n        }\n    };\n\n    /**\n     * DataBlock constructor\n     *\n     * DataBlock is provided as an internal class.\n     * DataBlock instances are created internally by the cache object.\n     */\n    var DataBlock = (function() {\n        var blockCounter = 0;\n\n        var _constructor = function DataBlock(evtDispatcher) {\n            var id = null;\n            var fetchError = null;\n            var fetcher = null;\n            var data = null;\n            var taskDef = null;\n            var age = 0;\n            var fetching = false;\n            var fetched = false;\n            var pinCount = 0;\n            var waitingRecycling = false;\n            var waitingMerging = false;\n            var ready = false;\n            var callbacks = [];\n            var requestId = 0;\n            var dispatcher = evtDispatcher;\n            var thisBlock = this;\n\n            //Private functions:\n\n            function reset() {\n                fetchError = null;\n                fetcher = null;\n                data = null;\n                taskDef = null;\n                age = 0;\n                fetching = false;\n                fetched = false;\n                pinCount = 0;\n                waitingRecycling = false;\n                waitingMerging = false;\n                ready = false;\n                callbacks = [];\n\n            }\n\n            //Privileged functions:\n            this.getId = function() {\n                return id;\n            };\n\n            this.getTaskDef = function() {\n                return taskDef;\n            };\n\n            this.getStart = function() {\n                return (taskDef !== null) ? taskDef.start : undefined;\n            };\n\n            this.getEnd = function() {\n                return (taskDef !== null) ? taskDef.end : undefined;\n            };\n\n            this.getPointCount = function() {\n                return (taskDef !== null) ? taskDef.pointCount : undefined;\n            };\n\n            this.getResolution = function() {\n                return (taskDef !== null) ? taskDef.resolution : undefined;\n            };\n\n            this.getService = function() {\n                return (taskDef !== null) ? taskDef.service : undefined;\n            };\n\n            this.getLocation = function() {\n                return (taskDef !== null) ? taskDef.location : undefined;\n            };\n\n            this.getParameter = function() {\n                return (taskDef !== null) ? taskDef.parameter : undefined;\n            };\n\n            this.getDataSize = function() {\n                return (taskDef !== null) ? (taskDef.pointCount * taskDef.parameter.length * taskDef.location.length) : 0;\n            };\n\n            this.pin = function() {\n                if (!waitingRecycling) {\n                    pinCount++;\n                    if (dispatcher) {\n                        dispatcher('blockPinned', thisBlock);\n                    }\n                    return pinCount;\n                } else {\n                    return null;\n                }\n            };\n\n            this.unpin = function() {\n                if (pinCount > 0) {\n                    pinCount--;\n                    if (dispatcher) {\n                        dispatcher('blockUnpinned', thisBlock);\n                    }\n                }\n                return pinCount;\n            };\n\n            this.isPinned = function() {\n                return (pinCount > 0);\n            };\n\n            this.getPinCount = function() {\n                return pinCount;\n            };\n\n            this.getRequestId = function() {\n                return requestId;\n            };\n\n            this.isWaitingRecycling = function() {\n                return waitingRecycling;\n            };\n\n            this.isWaitingMerging = function() {\n                return waitingMerging;\n            };\n\n            this.isFetched = function() {\n                return fetched;\n            };\n\n            this.setFetched = function(f) {\n                if (f === true) {\n                    fetched = true;\n                } else {\n                    fetched = false;\n                }\n            };\n\n            this.isFetching = function() {\n                return fetching;\n            };\n\n            this.setFetching = function(f) {\n                if (f === true) {\n                    fetching = true;\n                } else {\n                    fetching = false;\n                }\n            };\n\n            this.increaseNotUsed = function() {\n                age++;\n                if (dispatcher) {\n                    dispatcher('blockAged', thisBlock);\n                }\n            };\n\n            this.getNotUsedSince = function() {\n                return age;\n            };\n\n            this.fetchFailed = function() {\n              return fetchError !== null;\n            };\n\n            this.markForRecycling = function() {\n                waitingRecycling = true;\n                if (dispatcher) {\n                    dispatcher('blockEvicted', thisBlock);\n                }\n            };\n\n            this.markForMerging = function(merge) {\n                if (merge === true){\n                    waitingMerging = true;\n                    if (dispatcher) {\n                        dispatcher('blockMarkedForMerge', thisBlock);\n                    }\n                }\n                else {\n                    waitingMerging = false;\n                    if (dispatcher) {\n                        dispatcher('blockMergeCancelled', thisBlock);\n                    }\n                }\n            };\n\n            this.setData = function(d) {\n                data = d;\n            };\n\n            this.getFetcher = function() {\n                return fetcher;\n            };\n\n            this.recycle = function() {\n                reset();\n                if (dispatcher) {\n                    dispatcher('blockRecycled', thisBlock);\n                }\n            };\n\n            /**\n             * TaskDef: {\n             *          service,\n             *          parameter,\n             *          location,\n             *          start,\n             *          resolution,\n             *          pointCount\n             * }\n             */\n            this.prepare = function(taskDefinition, dataFetcher) {\n                if (!_.isFunction(dataFetcher)) {\n                    throw 'fetcher must be a function';\n                }\n                checkTaskDef(taskDefinition);\n                reset();\n                taskDef = taskDefinition;\n                fetcher = dataFetcher;\n                ready = true;\n                requestId++;\n                if (dispatcher) {\n                    dispatcher('blockPrepared', thisBlock);\n                }\n            };\n\n            /**\n             * @param callback {function(err,data)}\n             */\n            this.getDataAsync = function(callback) {\n                var that = this;\n                if (!ready) {\n                    throw 'Cannot getData in unprepared state, call prepare first';\n                }\n                age = 0;\n                if (!fetched) {\n                    if ((callback !== undefined) && _.isFunction(callback)) {\n                        callbacks.push(callback);\n                    }\n                    if (!fetching) {\n                        fetching = true;\n                        fetcher(taskDef, function(err, result) {\n                            var reqId = that.getRequestId();\n                            if (err) {\n                                fetchError = err;\n                            }\n                            data = result;\n                            fetched = true;\n                            if (callbacks.length === 0) {\n                                fetching = false;\n                            } else {\n                                async.whilst(function() {\n                                    var myReqId = that.getRequestId();\n                                    //We may still be looping here when this block has been recycled, re-prepared and fetching for the next request.\n                                    //So need to check if the request has not changed and we still have callbacks.\n                                    //The callbacks for the next request will still be looped through when the time is right.\n                                    return ((reqId === myReqId) && (callbacks.length > 0));\n                                }, function(notify) {\n                                    try {\n                                        var cb = callbacks.pop();\n                                        cb.call(that, fetchError, data);\n                                    } catch (ex) {\n                                        if (\"undefined\" !== typeof console && console) {\n                                            console.error('Error in block finished callback:' + ex.message);\n                                        }\n                                    } finally {\n                                        notify();\n                                        fetching = false;\n                                    }\n                                }, function(err) {\n                                    //NOOP\n                                });\n                            }\n                            if (dispatcher) {\n                                dispatcher('blockProviderFetchFinished', thisBlock);\n                            }\n                        });\n                        if (dispatcher) {\n                            dispatcher('blockProviderFetchStarted', thisBlock);\n                        }\n                    }\n\n                } else {\n                    if (_.isFunction(callback)) {\n                        _.defer(function(err, d) {\n                            if (dispatcher) {\n                                dispatcher('blockCacheFetchFinished', thisBlock);\n                            }\n                            callback(err, d);\n                        }, fetchError, data);\n                        if (dispatcher) {\n                            dispatcher('blockCacheFetchStarted', thisBlock);\n                        }\n                    } else {\n\n                    }\n                }\n            };\n\n            //Instance initialization:\n            id = 'id#' + blockCounter++;\n\n            if (dispatcher) {\n                dispatcher('blockCreated', thisBlock);\n            }\n        };\n\n        return _constructor;\n    })();\n\n    var eventListenerIdCounter = 0;\n    var fetcherIdCounter = 0;\n\n    /**\n     * SplitterCache constructor\n     *\n     * Constructor contains priviledged methods that are provided as API functions\n     * for the instantiated cache object.\n     */\n    var _constructor = function SplitterCache(properties) {\n        var emptyBlockPool = [];\n        var cachedBlocks = [];\n        var mergedBlocks = [];\n        var stepResolutions = [];\n        var sideFetchBeforeFactor = 0.5;\n        var sideFetchAfterFactor = 1;\n        var maxBlockDataPoints = 500;\n        var minBlockDataPoints = 20;\n        var maxCacheDataSize = 50000;\n        var strictErrorHandling = true;\n        var errorFillValue = NaN;\n\n        var fetchers = {};\n        var cachedDataSize = 0;\n        var cacheHits = 0;\n        var cacheMisses = 0;\n        var thisCache = this;\n\n        var eventListeners = {\n            blockCreated : {},\n            blockPrepared : {},\n            blockProviderFetchStarted : {},\n            blockProviderFetchFinished : {},\n            blockCacheFetchStarted : {},\n            blockCacheFetchFinished : {},\n            blockPinned : {},\n            blockUnpinned : {},\n            blockEvicted : {},\n            blockRecycled : {},\n            blockAged : {},\n            blockMarkedForMerge : {},\n            blockMergeCancelled : {},\n            evictStarted : {},\n            evictFinished : {},\n            fetchStarted : {},\n            fetchFinished : {},\n            cacheCleared : {},\n            dataProviderAdded : {},\n            dataProviderRemoved : {}\n        };\n\n        //Private functions:\n        //Event handling:\n\n        function fireEvent(eventName, eventData) {\n            if (eventListeners[eventName] !== undefined) {\n                _.each(eventListeners[eventName], function(cb) {\n                    try {\n                        cb.call(thisCache, eventData);\n                    } catch (ex) {\n                    }\n                });\n            }\n        }\n\n        function addEventListener(eventName, cb) {\n            var listenerId = null;\n            if (eventListeners[eventName] !== undefined) {\n                if (_.isFunction(cb)) {\n                    listenerId = 'id' + (eventListenerIdCounter++);\n                    eventListeners[eventName][listenerId] = cb;\n                } else {\n                    throw 'Event listener callback is not a function';\n                }\n            } else {\n                throw 'Unknown event \\'' + eventName + '\\', use one of ' + _.reduce(_.keys(eventListeners), function(memo, name, ind) {\n                    if (ind > 0) {\n                        memo = memo + ', ';\n                    }\n                    memo = memo + name;\n                    return memo;\n                });\n            }\n            return listenerId;\n        }\n\n        function removeEventListener(eventName, listenerId) {\n            if (eventListeners[eventName] !== undefined) {\n                if (eventListeners[eventName][listenerId] !== undefined) {\n                    delete eventListeners[eventName][listenerId];\n                }\n            } else {\n                throw 'Unknown event \\'' + eventName + '\\', use one of ' + _.reduce(_.keys(eventListeners), function(memo, name, ind) {\n                    if (ind > 0) {\n                        memo = memo + ', ';\n                    }\n                    memo = memo + name;\n                });\n            }\n        }\n\n        function evict(evictList) {\n            async.each(evictList, function(toEvict, notify) {\n                toEvict.markForRecycling();\n                notify();\n            }, function(err) {\n                if (err && \"undefined\" !== typeof console && console) {\n                    console.error(err);\n                }\n            });\n        }\n\n        function mergeBlocks(block1, block2, callback) {\n            var newBlock = null;\n            var taskDef = {};\n            var combinedData = [];\n            if ((block1.pin() > 0) && (block2.pin() > 0)) {\n                block1.markForMerging(true);\n                block2.markForMerging(true);\n                newBlock = getDataBlock();\n                taskDef = _.clone(block1.getTaskDef());\n                taskDef.end = block2.getEnd();\n                taskDef.pointCount = block1.getPointCount() + block2.getPointCount();\n                newBlock.prepare(taskDef, block1.getFetcher());\n                newBlock.setFetching(true);\n                fireEvent('blockCacheFetchStarted', newBlock);\n                async.parallel({\n                    data1 : function(cb) {\n                        block1.getDataAsync(function(err, data) {\n                            if (err) {\n                                if (\"undefined\" !== typeof console && console) {\n                                    console.log('Warning: getDataAsync from merged block1 returned error:\\'' + err + '\\'');\n                                }\n                                cb(err);\n                            }\n                            else {\n                                fillWith(combinedData, data, taskDef.location, taskDef.parameter, 0, 0, block1.getPointCount(), cb);\n                            }\n                        });\n                    },\n                    data2 : function(cb) {\n                        block2.getDataAsync(function(err, data) {\n                            if (err) {\n                                if (\"undefined\" !== typeof console && console) {\n                                    console.log('Warning: getDataAsync from merged block2 returned error:\\'' + err + '\\'');\n                                }\n                                cb(err);\n                            }\n                            else {\n                                fillWith(combinedData, data, taskDef.location, taskDef.parameter, block1.getPointCount(), 0, block2.getPointCount(), cb);\n                            }\n                        });\n                    }\n                }, function(err, results) {\n                    block1.unpin();\n                    block2.unpin();\n                    if (!err){\n                        block1.markForRecycling();\n                        block2.markForRecycling();\n                        newBlock.setData(combinedData);\n                        newBlock.setFetching(false);\n                        newBlock.setFetched(true);\n                        callback(null, newBlock);\n                        fireEvent('blockCacheFetchFinished', newBlock);\n                    } else {\n                        newBlock.reset();\n                        block1.markForMerging(false);\n                        block2.markForMerging(false);\n                        callback(err);\n                        fireEvent('blockCacheFetchFinished', null);\n                    }\n                });\n            } else {\n                _.defer(function() {\n                    callback(new Error('One or both blocks already marked for recycling'));\n                });\n            }\n        }\n\n        function blocksAreContinuous(block1, block2) {\n            if (block1.getResolution() === block2.getResolution() && (block2.getStart() === block1.getEnd() + block1.getResolution())) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        function shouldBlocksBeMerged(block1, block2) {\n            //It's assumed that service, location and parameter equality has already been checked:\n            if (!block1.fetchFailed() && !block2.fetchFailed() && !block1.isWaitingMerging() && !block2.isWaitingMerging() && ((block1.getPointCount() < minBlockDataPoints) || (block2.getPointCount() < minBlockDataPoints)) && blocksAreContinuous(block1, block2) && (block1.getPointCount() + block2.getPointCount() < maxBlockDataPoints)) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        function getDataBlock() {\n            var dataBlock;\n            if (emptyBlockPool.length > 0) {\n                dataBlock = emptyBlockPool.pop();\n            } else {\n                dataBlock = new DataBlock(fireEvent);\n            }\n            return dataBlock;\n        }\n\n        function blockOverlaps(blockStart, blockEnd, start, end) {\n            var retval = false;\n            //exactly matching steps:\n            if ((blockStart === start) && (blockEnd === end)) {\n                retval = true;\n            }\n            //overlapping steps:\n            else if ((blockStart <= end) && (blockEnd > start)) {\n                retval = true;\n            }\n            return retval;\n        }\n\n        function createMissingBlocksBefore(prevBlockEnd, blockStart, fetchStart, fetchEnd, taskDef) {\n            var retval = null;\n            //if at first block or we've just crossed a gap in steps between cached data blocks:\n            if ((prevBlockEnd === null) || (prevBlockEnd < (blockStart - taskDef.resolution))) {\n                //The current block starts after our interesting step sequence starts:\n                if (blockStart > fetchStart) {\n                    //the current block starts after or at the same step as our interesting step sequence ends:\n                    if (blockStart >= fetchEnd) {\n                        //create new blocks until the end of our interesting step sequence:\n                        if (prevBlockEnd === null) {\n                            retval = allocateAndPrepareContinuousBlocks(taskDef, fetchStart, fetchEnd);\n                        } else {\n                            retval = allocateAndPrepareContinuousBlocks(taskDef, Math.max(prevBlockEnd, fetchStart), fetchEnd);\n                        }\n                    }\n                    //current block starts before our interesting step sequence ends:\n                    else {\n                        //create new blocks until one step before the start of the current block:\n                        if (prevBlockEnd === null) {\n                            retval = allocateAndPrepareContinuousBlocks(taskDef, fetchStart, (blockStart - taskDef.resolution));\n                        } else {\n                            retval = allocateAndPrepareContinuousBlocks(taskDef, Math.max((prevBlockEnd + taskDef.resolution), fetchStart), (blockStart - taskDef.resolution));\n                        }\n                    }\n                }\n            }\n            return retval;\n        }\n\n        function recycleBlock(block) {\n            if (block.isPinned()) {\n                async.whilst(function() {\n                    return block.isPinned();\n                }, function(notify) {\n                    setTimeout(notify, 500);\n                }, function(err) {\n                    block.recycle();\n                    emptyBlockPool.push(block);\n                });\n            } else {\n                block.recycle();\n                emptyBlockPool.push(block);\n            }\n        }\n\n        //A single-line queue for running iterateCache: if more than one\n        //iteration is requested simultaneously, others have to queue for\n        //execution, because iterateCache changes the internal cache state asynchronously.\n        var iterateCacheQueue = async.queue(function(taskDef, callback) {\n            callback(null, iterateCache(taskDef));\n        }, 1);\n\n        function iterateCache(taskDef) {\n            var retval = [];\n            var requestedStart = taskDef.start;\n            var requestedEnd = taskDef.end;\n            var sideFetchBeforeItemCount = Math.ceil(sideFetchBeforeFactor * taskDef.pointCount);\n            var sideFetchAfterItemCount = Math.ceil(sideFetchAfterFactor * taskDef.pointCount);\n            var fetchStart = requestedStart - sideFetchBeforeItemCount * taskDef.resolution;\n            var fetchEnd = requestedEnd + sideFetchAfterItemCount * taskDef.resolution;\n            var blockAgeOrder = [];\n            var newCachedBlocks = [];\n            var mergeInd = -1;\n            var blockToMerge = null;\n            var prevMatchingBlock = null;\n\n            var sortIterator = function(bl) {\n                return bl.getStart();\n            };\n\n            cachedDataSize = 0;\n            //add all merged blocks that are ready:\n            while (mergedBlocks.length > 0) {\n                blockToMerge = mergedBlocks.shift();\n                mergeInd = _.sortedIndex(cachedBlocks, blockToMerge, sortIterator);\n                cachedBlocks.splice(mergeInd, 0, blockToMerge);\n            }\n\n            if (cachedBlocks.length > 0) {\n                _.each(cachedBlocks, function(block, index) {\n                    var selectThisBlock = false;\n                    var newBlocksBefore = null;\n                    var newBlocksAfter = null;\n                    var prevBlockEnd = null;\n                    var blStart = block.getStart();\n                    var blEnd = block.getEnd();\n\n                    if (block.isWaitingRecycling()) {\n                        recycleBlock(block);\n                        return;\n                        //=continue each loop;\n                    }\n\n                    //This block contains data for the relevant service, with the same locations and parameters:\n                    if ((taskDef.service === block.getService()) && arrayEqualsAnyOrder(taskDef.location, block.getLocation()) && arrayEqualsAnyOrder(taskDef.parameter, block.getParameter())) {\n                        if (prevMatchingBlock !== null) {\n                            prevBlockEnd = prevMatchingBlock.getEnd();\n                        }\n\n                        //check if we should create new data blocks before the current block:\n                        newBlocksBefore = createMissingBlocksBefore(prevBlockEnd, blStart, fetchStart, fetchEnd, taskDef);\n                        if ((newBlocksBefore !== null) && (newBlocksBefore.length > 0)) {\n                            Array.prototype.push.apply(newCachedBlocks, newBlocksBefore);\n                            async.reduce(newBlocksBefore, cacheMisses, function(memo, block, callback) {\n                                callback(null, memo + block.getDataSize());\n                            }, function(err, result) {\n                                cacheMisses = result;\n                            });\n                            Array.prototype.push.apply(retval, newBlocksBefore);\n                        }\n\n                        selectThisBlock = blockOverlaps(blStart, blEnd, fetchStart, fetchEnd);\n                        if (selectThisBlock) {\n                            if (block.pin() > 0) {\n                                retval.push(block);\n                                cacheHits += block.getDataSize();\n                            } else {\n                                if (\"undefined\" !== typeof console && console) {\n                                    console.log('Unable to pin a block, it\\'s already marked for recycling (this should not happen)');\n                                }\n                            }\n                        } else {\n                            block.increaseNotUsed();\n                        }\n                        newCachedBlocks.push(block);\n\n                        //check if we should merge this block with the previous one:\n                        if ((prevMatchingBlock !== null) && shouldBlocksBeMerged(prevMatchingBlock, block)) {\n                            mergeBlocks(prevMatchingBlock, block, function(err, merged) {\n                                if (err) {\n                                    //Merge failed. This should only happen if the data for either block\n                                    //could not be fetched.\n                                    if (\"undefined\" !== typeof console && console) {\n                                        console.error(err);\n                                    }\n                                } else {\n                                    //Both merged old blocks have already been marked for recycling at this point.\n                                    //Postpone adding the new block until the beginning of the next fetch cycle:\n                                    mergedBlocks.push(merged);\n                                }\n                            });\n                        }\n                        prevMatchingBlock = block;\n                    } else {\n                        block.increaseNotUsed();\n                        //not matched in this cycle, keep in cache still:\n                        newCachedBlocks.push(block);\n                    }\n\n                    //If we are at the last cached block, check if we should additionally\n                    //create new data blocks after the last matching found block.\n                    if (index === (cachedBlocks.length - 1)) {\n                        //we've found at least one matching block in cache:\n                        if (prevMatchingBlock !== null) {\n                            //If our interesting step sequence ends after the last matching found block ends:\n                            if ((prevMatchingBlock.getEnd() + taskDef.resolution) < fetchEnd) {\n                                newBlocksAfter = allocateAndPrepareContinuousBlocks(taskDef, Math.max(blEnd + taskDef.resolution, fetchStart), fetchEnd);\n                                Array.prototype.push.apply(newCachedBlocks, newBlocksAfter);\n                                async.reduce(newBlocksAfter, cacheMisses, function(memo, block, callback) {\n                                    callback(null, memo + block.getDataSize());\n                                }, function(err, result) {\n                                    cacheMisses = result;\n                                });\n                                Array.prototype.push.apply(retval, newBlocksAfter);\n                            }\n                        }\n                    }\n\n                    //Place the current block at the evictOrder list at the current place based on it's age:\n                    var ageInd = _.sortedIndex(blockAgeOrder, block, function(bl) {\n                        return bl.getNotUsedSince();\n                    });\n                    blockAgeOrder.splice(ageInd, 0, block);\n                    cachedDataSize += block.getDataSize();\n                });\n            }\n\n            //no blocks in cache or none available for use right now, allocate new ones for the whole step sequence:\n            if (retval.length === 0) {\n                retval = allocateAndPrepareContinuousBlocks(taskDef, fetchStart, fetchEnd);\n                Array.prototype.push.apply(newCachedBlocks, retval);\n                async.reduce(retval, cacheMisses, function(memo, block, callback) {\n                    callback(null, memo + block.getDataSize());\n                }, function(err, result) {\n                    cacheMisses = result;\n                });\n            }\n            cachedBlocks = [];\n            cachedBlocks = newCachedBlocks;\n            newCachedBlocks = [];\n\n            async.whilst(function() {\n                return cachedDataSize * 1.01 > maxCacheDataSize;\n            }, function() {\n                var dataToEvict = cachedDataSize * 1.01 - maxCacheDataSize;\n                fireEvent('evictStarted', {\n                    'inCache' : cachedDataSize,\n                    'toEvict' : dataToEvict\n                });\n                var evictList = [];\n                var toEvict = null;\n                var evictListDataSize = 0;\n                while ((evictListDataSize < dataToEvict) && (blockAgeOrder.length > 0)) {\n                    toEvict = blockAgeOrder.pop();\n                    if (toEvict !== undefined) {\n                        evictListDataSize += toEvict.getDataSize();\n                        evictList.push(toEvict);\n                    }\n                }\n                if (evictList.length > 0) {\n                    evict(evictList);\n                    cachedDataSize = cachedDataSize - evictListDataSize;\n                    fireEvent('evictFinished', {\n                        'inCache' : cachedDataSize,\n                        'evicted' : evictListDataSize\n                    });\n                }\n            }, function() {\n                //NOOP\n            });\n            return retval;\n        }\n\n        function allocateAndPrepareContinuousBlocks(parentTaskDef, start, end) {\n            var blocks = [];\n            var totalPointCount = Math.round((end - start) / parentTaskDef.resolution) + 1;\n            var blocksNeeded = Math.ceil(totalPointCount / maxBlockDataPoints);\n            var i = 0;\n            var taskDef;\n            var block = null;\n            for ( i = 0; i < blocksNeeded; i++) {\n                block = getDataBlock();\n                taskDef = _.clone(parentTaskDef);\n                taskDef.start = start + i * (parentTaskDef.resolution * maxBlockDataPoints);\n                taskDef.pointCount = Math.min(maxBlockDataPoints, totalPointCount - (i * maxBlockDataPoints));\n                taskDef.end = taskDef.start + (taskDef.pointCount - 1) * parentTaskDef.resolution;\n                block.prepare(taskDef, getFetcher(parentTaskDef.service));\n                if (block.pin() > 0) {\n                    blocks.push(block);\n                } else {\n                    if (\"undefined\" !== typeof console && console) {\n                        console.error('Strange, unable to pin block!');\n                    }\n                }\n            }\n            return blocks;\n        }\n\n        /**\n         * @param source If source is an object, it should provide source[loc][param][index] structure that is used\n         *                           to get the data value for the target[loc][param][index] object. If source is not an object,\n         *                           the source itself is set directly into the target[loc][param][index].\n         */\n\n        function fillWith(target, source, locations, parameters, targetIndex, sourceIndex, count, callback) {\n            var copyFromArray = _.isObject(source);\n            var ti = 0;\n            var si = 0;\n            var end = 0;\n            async.each(locations, function(loc, locNotify) {\n                if (target[loc] === undefined) {\n                    target[loc] = {};\n                }\n                async.each(parameters, function(param, paramNotify) {\n                    var useErrorValues = false;\n                    if (target[loc][param] === undefined) {\n                        target[loc][param] = [];\n                    }\n                    if (copyFromArray) {\n                        if (!_.isObject(source[loc]) || !_.isArray(source[loc][param])) {\n                            useErrorValues = true;\n\n                        } else if (source[loc][param].length < (sourceIndex + count)) {\n                            useErrorValues = true;\n                            if (\"undefined\" !== typeof console && console) {\n                                console.error('Trying to fill segment with only ' + source[loc][param].length + ' values for location ' + loc + ' and parameter ' + param + ' when ' + (sourceIndex + count) + ' would be needed. Filling the whole segment with \\''+errorFillValue+'\\'');\n                            }\n                        }\n                    }\n                    if (useErrorValues) {\n                        ti = targetIndex;\n                        end = targetIndex + count;\n                        while (ti < end) {\n                            target[loc][param][ti++] = errorFillValue;\n                        }\n                    } else if (copyFromArray) {\n                        ti = targetIndex;\n                        si = sourceIndex;\n                        end = targetIndex + count;\n                        while (ti < end) {\n                            target[loc][param][ti++] = source[loc][param][si++];\n                        }\n                    } else {\n                        ti = targetIndex;\n                        end = targetIndex + count;\n                        while (ti < end) {\n                            target[loc][param][ti++] = source;\n                        }\n                    }\n                    paramNotify();\n                }, function(err) {\n                    //one location completed\n                    locNotify();\n                });\n            }, function(err) {\n                //all done:\n                callback(err, target);\n            });\n        }\n\n        function retrieveDataAsync(origTaskDef, finishCallback, progressCallback) {\n            var taskDef = _.clone(origTaskDef);\n\n            if (!_.isFunction(finishCallback)) {\n                throw 'finishCallback must be a function';\n            }\n\n            if (getFetcher(taskDef.service) === null) {\n                throw 'No data fetcher set for service \\'' + taskDef.service + '\\', unable to provide data';\n            }\n\n            //If the new request does not have the same resolution or the start difference is not a multiple of resolution\n            //then clear all cached results for this service:\n            if (stepResolutions[taskDef.service] !== undefined) {\n                if ((stepResolutions[taskDef.service].resolution !== taskDef.resolution) || (Math.abs(stepResolutions[taskDef.service].start - taskDef.start) % taskDef.resolution !== 0)) {\n                    clear(taskDef.service);\n                }\n            }\n            stepResolutions[taskDef.service] = {\n                start : taskDef.start,\n                resolution : taskDef.resolution\n            };\n\n            iterateCacheQueue.push(taskDef, function(err, dataBlocks) {\n                fetchDataForBlocks(dataBlocks, taskDef, finishCallback, progressCallback);\n            });\n\n        }\n\n        function fetchDataForBlocks(dataBlocks, taskDef, finishCallback, progressCallback) {\n            var errors = null;\n            var notifyProgress = false;\n            var result = {};\n\n            if (_.isFunction(progressCallback)) {\n                notifyProgress = true;\n            }\n            fireEvent('fetchStarted', taskDef);\n            result.steps = _.range(taskDef.start, taskDef.end + taskDef.resolution, taskDef.resolution);\n            result.data = {};\n\n            async.each(dataBlocks, function(dataBlock, notify) {\n                var td = dataBlock.getTaskDef();\n\n                var includeStart = NaN;\n                var includeEnd = NaN;\n                var targetStartIndex = NaN;\n                var targetEndIndex = NaN;\n                var sourceStartIndex = NaN;\n                var valueCount = NaN;\n\n                if (!blockOverlaps(td.start, td.end, taskDef.start, taskDef.end)) {\n                    //For completely out-of-range blocks:\n                    //we fetch them just to cache them, but otherwise\n                    //ignore the results completely:\n                    dataBlock.getDataAsync(function(){\n                        dataBlock.unpin();\n                    });\n\n                    //and continue the loop:\n                    notify();\n                    return;\n                }\n\n                if (td.start < taskDef.start) {\n                    includeStart = taskDef.start;\n                    sourceStartIndex = Math.round((taskDef.start - td.start) / taskDef.resolution);\n                } else {\n                    includeStart = td.start;\n                    sourceStartIndex = 0;\n                }\n                targetStartIndex = _.indexOf(result.steps, includeStart);\n                if (targetStartIndex === -1) {\n                    throw dataBlock.getId() + ':something wrong with indexing, start index for cache block not found in the combined results!';\n                }\n\n                if (td.end > taskDef.end) {\n                    includeEnd = taskDef.end;\n                    targetEndIndex = result.steps.length - 1;\n                } else {\n                    includeEnd = td.end;\n                    targetEndIndex = _.indexOf(result.steps, td.end, true);\n                }\n                valueCount = targetEndIndex - targetStartIndex + 1;\n\n                // See fillWith function description about the structure that data object should have.\n                dataBlock.getDataAsync(function(err, data) {\n                    var fillValue = data;\n\n                    if (err) {\n                        if (errors === null) {\n                            errors = [];\n                        }\n                        errors.push({\n                            start : td.start,\n                            end : td.end,\n                            error : err\n                        });\n\n                        // error in fetching data, fill result with 'errorFillValue' for this step sequence if data is undefined itself.\n                        // Notice, errors may have occurred but data is still given because it should be good enough.\n                        // Therefore, do not ignore given data if it is available. It is up to the data provider to make\n                        // sure that data is undefined if it should not be handled in cache.\n\n                        //Ilkka Rinne/2013-09-02: This is inconsistent with the node.js callback error conventions:\n                        //You should always get either an error or result, never both.\n                        //http://nodemanual.org/latest/nodejs_dev_guide/working_with_callbacks.html\n                        //When would you want to return errors but also useable data?\n\n                        if (strictErrorHandling || !data) {\n                            fillValue = errorFillValue;\n                        }\n                        //do not keep this block in cache:\n                        dataBlock.markForRecycling();\n                    }\n                    fillWith(result.data, fillValue, td.location, td.parameter, targetStartIndex, sourceStartIndex, valueCount, function() {\n                        if (notifyProgress) {\n                            progressCallback(err, includeStart, includeEnd);\n                        }\n                        dataBlock.unpin();\n\n                        //always succeed, even with fetch error: we want to return the rest of the data anyway\n                        notify();\n                    });\n                });\n\n            }, function(err) {\n                finishCallback(errors, result);\n                fireEvent('fetchFinished', taskDef);\n            });\n        }\n\n        function getFetcher(service) {\n            if (fetchers[service] !== undefined) {\n                fetchers[service].nextIndex = (fetchers[service].nextIndex + 1) % fetchers[service].providers.length;\n                return fetchers[service].providers[fetchers[service].nextIndex].cb;\n            } else {\n                return null;\n            }\n        }\n\n        function clear(service) {\n            _.each(cachedBlocks, function(block) {\n                if ((service === undefined) || (block.getService() === service)) {\n                    block.markForRecycling();\n                }\n            });\n            _.each(mergedBlocks, function(block) {\n                if ((service === undefined) || (block.getService() === service)) {\n                    block.markForRecycling();\n                }\n            });\n            fireEvent('cacheCleared', service);\n        }\n\n        //Privileged functions:\n        /**\n         * @param {String} service Describes the service name that identifies the data.\n         *                                               May not be {undefined}, {null} or empty. More than one fetcher\n         *                                               may be added for the same service to enable a round-robin task\n         *                                               distribution between them.\n         * @param {function(taskDef, callback)} fetcher The callback parameter of fetcher callback function is of\n         *                                              the type {function(err, data)}. See {fillWith()} function\n         *                                              for the description for the source data object structure\n         *                                              that should be provided by the fetcher callback function for\n         *                                              its parameter callback function.\n         */\n        this.addDataProvider = function(service, fetcher) {\n            var provider = {};\n            if (_.isFunction(fetcher)) {\n                if (fetchers[service] === undefined) {\n                    fetchers[service] = {\n                        nextIndex : 0,\n                        providers : []\n                    };\n                }\n                provider.id = 'id#' + fetcherIdCounter++;\n                provider.cb = fetcher;\n                fetchers[service].providers.push(provider);\n                fireEvent('dataProviderAdded', {\n                    'service' : service,\n                    'providerId' : provider.id\n                });\n            } else {\n                throw 'Fetcher must be a function';\n            }\n            return provider.id;\n        };\n\n        this.removeDataProvider = function(service, providerId) {\n            var oldLength = 0;\n            var actuallyRemoved = false;\n            if (fetchers[service] !== undefined) {\n                oldLength = fetchers[service].providers.length;\n                fetchers[service].providers = _.reject(fetchers[service].providers, function(provider) {\n                    return provider.id === providerId;\n                });\n                if (fetchers[service].providers.length === 0) {\n                    delete fetchers.service;\n                    actuallyRemoved = true;\n                } else if (oldLength !== fetchers[service].providers.length) {\n                    actuallyRemoved = true;\n                }\n                if (actuallyRemoved) {\n                    fireEvent('dataProviderRemoved', {\n                        'service' : service,\n                        'providerId' : providerId\n                    });\n                }\n            }\n        };\n\n        /**\n         * Removes all content from the cache and resets the hits & misses counters.\n         *\n         */\n        this.clearCache = function() {\n            clear();\n            stepResolutions = [];\n            cacheHits = 0;\n            cacheMisses = 0;\n        };\n\n        this.fetch = function(taskDef, finalCallback, progressCallback) {\n            checkTaskDef(taskDef);\n            retrieveDataAsync(taskDef, finalCallback, progressCallback);\n        };\n\n        this.getCachedItemCount = function() {\n            return cachedDataSize;\n        };\n\n        this.getFillingDegree = function() {\n            return cachedDataSize / maxCacheDataSize;\n        };\n\n        this.getHitRatio = function() {\n            return (cacheHits / (cacheHits + cacheMisses));\n        };\n\n        this.addListener = function(eventName, callback) {\n            return addEventListener(eventName, callback);\n        };\n\n        this.removeListener = function(eventName, providerId) {\n            return removeEventListener(eventName, providerId);\n        };\n\n        //Instance initialization:\n        if (properties.sideFetchBeforeFactor !== undefined) {\n            if (_.isNumber(properties.sideFetchBeforeFactor)) {\n                if (properties.sideFetchBeforeFactor >= 0) {\n                    sideFetchBeforeFactor = properties.sideFetchBeforeFactor;\n                }\n            }\n        }\n        if (properties.sideFetchAfterFactor !== undefined) {\n            if (_.isNumber(properties.sideFetchAfterFactor)) {\n                if (properties.sideFetchAfterFactor >= 0) {\n                    sideFetchAfterFactor = properties.sideFetchAfterFactor;\n                }\n            }\n        }\n        if (properties.maxBlockDataPoints !== undefined) {\n            if (_.isNumber(properties.maxBlockDataPoints)) {\n                if (properties.maxBlockDataPoints > 0) {\n                    maxBlockDataPoints = properties.maxBlockDataPoints;\n                }\n            }\n        }\n        if (properties.minBlockDataPoints !== undefined) {\n            if (_.isNumber(properties.minBlockDataPoints)) {\n                if ((properties.minBlockDataPoints > 0) && (properties.minBlockDataPoints < maxBlockDataPoints)) {\n                    minBlockDataPoints = properties.minBlockDataPoints;\n                } else {\n                    minBlockDataPoints = 0;\n                }\n            }\n        }\n        if (minBlockDataPoints > maxBlockDataPoints) {\n            minBlockDataPoints = maxBlockDataPoints;\n        }\n        if (properties.maxCacheDataSize !== undefined) {\n            if (_.isNumber(properties.maxCacheDataSize)) {\n                if (properties.maxCacheDataSize > 0) {\n                    maxCacheDataSize = properties.maxCacheDataSize;\n                }\n            }\n        }\n        if (properties.strictErrorHandling !== undefined) {\n            if (properties.strictErrorHandling === false) {\n                strictErrorHandling = false;\n            }\n        }\n\n        if (properties.errorFillValue !== undefined) {\n            errorFillValue = properties.errorFillValue;\n        }\n    };\n\n    /**\n     * SplitterCache constructor is returned for later instantiation.\n     */\n    return _constructor;\n})();\n\nmodule.exports = SplitterCache;\n"]},"metadata":{},"sourceType":"script"}