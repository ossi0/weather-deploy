{"ast":null,"code":"/**\n * Metolib.SplitterCache\n * =======================================\n *\n * See https://github.com/fmidev/metolib/wiki/SplitterCache for documentation.\n *\n * Requires:\n * - async.js (https://github.com/caolan/async)\n * - lodash.underscore.js (http://lodash.com/)\n *\n * Original author: Ilkka Rinne / Spatineo Inc. for the Finnish Meteorological Institute\n *\n *\n * This software may be freely distributed and used under the following MIT license:\n *\n * Copyright (c) 2017 Finnish Meteorological Institute\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the\n * Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\n\n// Strict mode for whole file.\n\"use strict\";\n\n// Requires lodash, async\nvar _ = require('lodash');\nvar async = require('async');\n// import _ from 'lodash';\n// import async from 'async';\n\nvar SplitterCache = function () {\n  //Functions and variables shared with all instances:\n  var checkTaskDef = function (taskDef) {\n    var placeholder;\n    var startNudge = 0;\n    var endNudge = 0;\n    if (!_.isObject(taskDef)) {\n      throw 'taskdef must be an object';\n    }\n    if (!_.isString(taskDef.service)) {\n      throw 'taskDef must contain a \\'service\\' property of string type';\n    }\n    if (!_.isArray(taskDef.location)) {\n      if (!_.isString(taskDef.location)) {\n        throw 'taskDef must contain a \\'location\\' property of either an array or a string type';\n      } else {\n        placeholder = taskDef.location;\n        taskDef.location = [];\n        taskDef.location.push(placeholder);\n      }\n    }\n    if (!_.isArray(taskDef.parameter)) {\n      if (!_.isString(taskDef.parameter)) {\n        throw 'taskDef must contain a \\'parameter\\' property of either an array or a string type';\n      } else {\n        placeholder = taskDef.parameter;\n        taskDef.parameter = [];\n        taskDef.parameter.push(placeholder);\n      }\n    }\n    if (!_.isNumber(taskDef.resolution)) {\n      throw 'taskDef must contain a \\'resolution\\' property of numeric type';\n    } else if (taskDef.resolution > 0.5) {\n      taskDef.resolution = Math.round(taskDef.resolution);\n    } else {\n      throw 'taskDef.resolution must be a positive integer';\n    }\n    if (!_.isNumber(taskDef.start)) {\n      throw 'taskDef must contain a \\'start\\' property of numeric type';\n    }\n    if (_.isNumber(taskDef.pointCount)) {\n      if (taskDef.pointCount > 0) {\n        taskDef.end = taskDef.start + (taskDef.pointCount - 1) * taskDef.resolution;\n      } else {\n        throw 'taskDef.pointCount must be greater than zero';\n      }\n    } else if (_.isNumber(taskDef.end)) {\n      if (taskDef.end < taskDef.start) {\n        throw '\\'end\\' must be greater than or equal to \\'start\\'';\n      }\n      endNudge = (taskDef.end - taskDef.start) % taskDef.resolution;\n      if (endNudge !== 0) {\n        taskDef.end = taskDef.end + (taskDef.resolution - endNudge);\n      }\n      taskDef.pointCount = (taskDef.end - taskDef.start) / taskDef.resolution + 1;\n    } else {\n      throw 'taskDef must contain either \\'end\\' or \\'pointCount\\' property of numeric type';\n    }\n  };\n  var arrayEqualsAnyOrder = function (arr1, arr2) {\n    var i = 0;\n    if (_.isArray(arr1) && _.isArray(arr2)) {\n      if (arr1.length === arr2.length) {\n        for (i = 0; i < arr1.length; i++) {\n          if (_.indexOf(arr2, arr1[i]) === -1) {\n            return false;\n          }\n        }\n        return true;\n      } else {\n        return false;\n      }\n    } else if (arr1 === undefined || arr1 === null || arr2 === undefined || arr2 === null) {\n      return false;\n    } else {\n      return arr1 === arr2;\n    }\n  };\n\n  /**\n   * DataBlock constructor\n   *\n   * DataBlock is provided as an internal class.\n   * DataBlock instances are created internally by the cache object.\n   */\n  var DataBlock = function () {\n    var blockCounter = 0;\n    var _constructor = function DataBlock(evtDispatcher) {\n      var id = null;\n      var fetchError = null;\n      var fetcher = null;\n      var data = null;\n      var taskDef = null;\n      var age = 0;\n      var fetching = false;\n      var fetched = false;\n      var pinCount = 0;\n      var waitingRecycling = false;\n      var waitingMerging = false;\n      var ready = false;\n      var callbacks = [];\n      var requestId = 0;\n      var dispatcher = evtDispatcher;\n      var thisBlock = this;\n\n      //Private functions:\n\n      function reset() {\n        fetchError = null;\n        fetcher = null;\n        data = null;\n        taskDef = null;\n        age = 0;\n        fetching = false;\n        fetched = false;\n        pinCount = 0;\n        waitingRecycling = false;\n        waitingMerging = false;\n        ready = false;\n        callbacks = [];\n      }\n\n      //Privileged functions:\n      this.getId = function () {\n        return id;\n      };\n      this.getTaskDef = function () {\n        return taskDef;\n      };\n      this.getStart = function () {\n        return taskDef !== null ? taskDef.start : undefined;\n      };\n      this.getEnd = function () {\n        return taskDef !== null ? taskDef.end : undefined;\n      };\n      this.getPointCount = function () {\n        return taskDef !== null ? taskDef.pointCount : undefined;\n      };\n      this.getResolution = function () {\n        return taskDef !== null ? taskDef.resolution : undefined;\n      };\n      this.getService = function () {\n        return taskDef !== null ? taskDef.service : undefined;\n      };\n      this.getLocation = function () {\n        return taskDef !== null ? taskDef.location : undefined;\n      };\n      this.getParameter = function () {\n        return taskDef !== null ? taskDef.parameter : undefined;\n      };\n      this.getDataSize = function () {\n        return taskDef !== null ? taskDef.pointCount * taskDef.parameter.length * taskDef.location.length : 0;\n      };\n      this.pin = function () {\n        if (!waitingRecycling) {\n          pinCount++;\n          if (dispatcher) {\n            dispatcher('blockPinned', thisBlock);\n          }\n          return pinCount;\n        } else {\n          return null;\n        }\n      };\n      this.unpin = function () {\n        if (pinCount > 0) {\n          pinCount--;\n          if (dispatcher) {\n            dispatcher('blockUnpinned', thisBlock);\n          }\n        }\n        return pinCount;\n      };\n      this.isPinned = function () {\n        return pinCount > 0;\n      };\n      this.getPinCount = function () {\n        return pinCount;\n      };\n      this.getRequestId = function () {\n        return requestId;\n      };\n      this.isWaitingRecycling = function () {\n        return waitingRecycling;\n      };\n      this.isWaitingMerging = function () {\n        return waitingMerging;\n      };\n      this.isFetched = function () {\n        return fetched;\n      };\n      this.setFetched = function (f) {\n        if (f === true) {\n          fetched = true;\n        } else {\n          fetched = false;\n        }\n      };\n      this.isFetching = function () {\n        return fetching;\n      };\n      this.setFetching = function (f) {\n        if (f === true) {\n          fetching = true;\n        } else {\n          fetching = false;\n        }\n      };\n      this.increaseNotUsed = function () {\n        age++;\n        if (dispatcher) {\n          dispatcher('blockAged', thisBlock);\n        }\n      };\n      this.getNotUsedSince = function () {\n        return age;\n      };\n      this.fetchFailed = function () {\n        return fetchError !== null;\n      };\n      this.markForRecycling = function () {\n        waitingRecycling = true;\n        if (dispatcher) {\n          dispatcher('blockEvicted', thisBlock);\n        }\n      };\n      this.markForMerging = function (merge) {\n        if (merge === true) {\n          waitingMerging = true;\n          if (dispatcher) {\n            dispatcher('blockMarkedForMerge', thisBlock);\n          }\n        } else {\n          waitingMerging = false;\n          if (dispatcher) {\n            dispatcher('blockMergeCancelled', thisBlock);\n          }\n        }\n      };\n      this.setData = function (d) {\n        data = d;\n      };\n      this.getFetcher = function () {\n        return fetcher;\n      };\n      this.recycle = function () {\n        reset();\n        if (dispatcher) {\n          dispatcher('blockRecycled', thisBlock);\n        }\n      };\n\n      /**\n       * TaskDef: {\n       *          service,\n       *          parameter,\n       *          location,\n       *          start,\n       *          resolution,\n       *          pointCount\n       * }\n       */\n      this.prepare = function (taskDefinition, dataFetcher) {\n        if (!_.isFunction(dataFetcher)) {\n          throw 'fetcher must be a function';\n        }\n        checkTaskDef(taskDefinition);\n        reset();\n        taskDef = taskDefinition;\n        fetcher = dataFetcher;\n        ready = true;\n        requestId++;\n        if (dispatcher) {\n          dispatcher('blockPrepared', thisBlock);\n        }\n      };\n\n      /**\n       * @param callback {function(err,data)}\n       */\n      this.getDataAsync = function (callback) {\n        var that = this;\n        if (!ready) {\n          throw 'Cannot getData in unprepared state, call prepare first';\n        }\n        age = 0;\n        if (!fetched) {\n          if (callback !== undefined && _.isFunction(callback)) {\n            callbacks.push(callback);\n          }\n          if (!fetching) {\n            fetching = true;\n            fetcher(taskDef, function (err, result) {\n              var reqId = that.getRequestId();\n              if (err) {\n                fetchError = err;\n              }\n              data = result;\n              fetched = true;\n              if (callbacks.length === 0) {\n                fetching = false;\n              } else {\n                async.whilst(function () {\n                  var myReqId = that.getRequestId();\n                  //We may still be looping here when this block has been recycled, re-prepared and fetching for the next request.\n                  //So need to check if the request has not changed and we still have callbacks.\n                  //The callbacks for the next request will still be looped through when the time is right.\n                  return reqId === myReqId && callbacks.length > 0;\n                }, function (notify) {\n                  try {\n                    var cb = callbacks.pop();\n                    cb.call(that, fetchError, data);\n                  } catch (ex) {\n                    if (\"undefined\" !== typeof console && console) {\n                      console.error('Error in block finished callback:' + ex.message);\n                    }\n                  } finally {\n                    notify();\n                    fetching = false;\n                  }\n                }, function (err) {\n                  //NOOP\n                });\n              }\n              if (dispatcher) {\n                dispatcher('blockProviderFetchFinished', thisBlock);\n              }\n            });\n            if (dispatcher) {\n              dispatcher('blockProviderFetchStarted', thisBlock);\n            }\n          }\n        } else {\n          if (_.isFunction(callback)) {\n            _.defer(function (err, d) {\n              if (dispatcher) {\n                dispatcher('blockCacheFetchFinished', thisBlock);\n              }\n              callback(err, d);\n            }, fetchError, data);\n            if (dispatcher) {\n              dispatcher('blockCacheFetchStarted', thisBlock);\n            }\n          } else {}\n        }\n      };\n\n      //Instance initialization:\n      id = 'id#' + blockCounter++;\n      if (dispatcher) {\n        dispatcher('blockCreated', thisBlock);\n      }\n    };\n    return _constructor;\n  }();\n  var eventListenerIdCounter = 0;\n  var fetcherIdCounter = 0;\n\n  /**\n   * SplitterCache constructor\n   *\n   * Constructor contains priviledged methods that are provided as API functions\n   * for the instantiated cache object.\n   */\n  var _constructor = function SplitterCache(properties) {\n    var emptyBlockPool = [];\n    var cachedBlocks = [];\n    var mergedBlocks = [];\n    var stepResolutions = [];\n    var sideFetchBeforeFactor = 0.5;\n    var sideFetchAfterFactor = 1;\n    var maxBlockDataPoints = 500;\n    var minBlockDataPoints = 20;\n    var maxCacheDataSize = 50000;\n    var strictErrorHandling = true;\n    var errorFillValue = NaN;\n    var fetchers = {};\n    var cachedDataSize = 0;\n    var cacheHits = 0;\n    var cacheMisses = 0;\n    var thisCache = this;\n    var eventListeners = {\n      blockCreated: {},\n      blockPrepared: {},\n      blockProviderFetchStarted: {},\n      blockProviderFetchFinished: {},\n      blockCacheFetchStarted: {},\n      blockCacheFetchFinished: {},\n      blockPinned: {},\n      blockUnpinned: {},\n      blockEvicted: {},\n      blockRecycled: {},\n      blockAged: {},\n      blockMarkedForMerge: {},\n      blockMergeCancelled: {},\n      evictStarted: {},\n      evictFinished: {},\n      fetchStarted: {},\n      fetchFinished: {},\n      cacheCleared: {},\n      dataProviderAdded: {},\n      dataProviderRemoved: {}\n    };\n\n    //Private functions:\n    //Event handling:\n\n    function fireEvent(eventName, eventData) {\n      if (eventListeners[eventName] !== undefined) {\n        _.each(eventListeners[eventName], function (cb) {\n          try {\n            cb.call(thisCache, eventData);\n          } catch (ex) {}\n        });\n      }\n    }\n    function addEventListener(eventName, cb) {\n      var listenerId = null;\n      if (eventListeners[eventName] !== undefined) {\n        if (_.isFunction(cb)) {\n          listenerId = 'id' + eventListenerIdCounter++;\n          eventListeners[eventName][listenerId] = cb;\n        } else {\n          throw 'Event listener callback is not a function';\n        }\n      } else {\n        throw 'Unknown event \\'' + eventName + '\\', use one of ' + _.reduce(_.keys(eventListeners), function (memo, name, ind) {\n          if (ind > 0) {\n            memo = memo + ', ';\n          }\n          memo = memo + name;\n          return memo;\n        });\n      }\n      return listenerId;\n    }\n    function removeEventListener(eventName, listenerId) {\n      if (eventListeners[eventName] !== undefined) {\n        if (eventListeners[eventName][listenerId] !== undefined) {\n          delete eventListeners[eventName][listenerId];\n        }\n      } else {\n        throw 'Unknown event \\'' + eventName + '\\', use one of ' + _.reduce(_.keys(eventListeners), function (memo, name, ind) {\n          if (ind > 0) {\n            memo = memo + ', ';\n          }\n          memo = memo + name;\n        });\n      }\n    }\n    function evict(evictList) {\n      async.each(evictList, function (toEvict, notify) {\n        toEvict.markForRecycling();\n        notify();\n      }, function (err) {\n        if (err && \"undefined\" !== typeof console && console) {\n          console.error(err);\n        }\n      });\n    }\n    function mergeBlocks(block1, block2, callback) {\n      var newBlock = null;\n      var taskDef = {};\n      var combinedData = [];\n      if (block1.pin() > 0 && block2.pin() > 0) {\n        block1.markForMerging(true);\n        block2.markForMerging(true);\n        newBlock = getDataBlock();\n        taskDef = _.clone(block1.getTaskDef());\n        taskDef.end = block2.getEnd();\n        taskDef.pointCount = block1.getPointCount() + block2.getPointCount();\n        newBlock.prepare(taskDef, block1.getFetcher());\n        newBlock.setFetching(true);\n        fireEvent('blockCacheFetchStarted', newBlock);\n        async.parallel({\n          data1: function (cb) {\n            block1.getDataAsync(function (err, data) {\n              if (err) {\n                if (\"undefined\" !== typeof console && console) {\n                  console.log('Warning: getDataAsync from merged block1 returned error:\\'' + err + '\\'');\n                }\n                cb(err);\n              } else {\n                fillWith(combinedData, data, taskDef.location, taskDef.parameter, 0, 0, block1.getPointCount(), cb);\n              }\n            });\n          },\n          data2: function (cb) {\n            block2.getDataAsync(function (err, data) {\n              if (err) {\n                if (\"undefined\" !== typeof console && console) {\n                  console.log('Warning: getDataAsync from merged block2 returned error:\\'' + err + '\\'');\n                }\n                cb(err);\n              } else {\n                fillWith(combinedData, data, taskDef.location, taskDef.parameter, block1.getPointCount(), 0, block2.getPointCount(), cb);\n              }\n            });\n          }\n        }, function (err, results) {\n          block1.unpin();\n          block2.unpin();\n          if (!err) {\n            block1.markForRecycling();\n            block2.markForRecycling();\n            newBlock.setData(combinedData);\n            newBlock.setFetching(false);\n            newBlock.setFetched(true);\n            callback(null, newBlock);\n            fireEvent('blockCacheFetchFinished', newBlock);\n          } else {\n            newBlock.reset();\n            block1.markForMerging(false);\n            block2.markForMerging(false);\n            callback(err);\n            fireEvent('blockCacheFetchFinished', null);\n          }\n        });\n      } else {\n        _.defer(function () {\n          callback(new Error('One or both blocks already marked for recycling'));\n        });\n      }\n    }\n    function blocksAreContinuous(block1, block2) {\n      if (block1.getResolution() === block2.getResolution() && block2.getStart() === block1.getEnd() + block1.getResolution()) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    function shouldBlocksBeMerged(block1, block2) {\n      //It's assumed that service, location and parameter equality has already been checked:\n      if (!block1.fetchFailed() && !block2.fetchFailed() && !block1.isWaitingMerging() && !block2.isWaitingMerging() && (block1.getPointCount() < minBlockDataPoints || block2.getPointCount() < minBlockDataPoints) && blocksAreContinuous(block1, block2) && block1.getPointCount() + block2.getPointCount() < maxBlockDataPoints) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    function getDataBlock() {\n      var dataBlock;\n      if (emptyBlockPool.length > 0) {\n        dataBlock = emptyBlockPool.pop();\n      } else {\n        dataBlock = new DataBlock(fireEvent);\n      }\n      return dataBlock;\n    }\n    function blockOverlaps(blockStart, blockEnd, start, end) {\n      var retval = false;\n      //exactly matching steps:\n      if (blockStart === start && blockEnd === end) {\n        retval = true;\n      }\n      //overlapping steps:\n      else if (blockStart <= end && blockEnd > start) {\n        retval = true;\n      }\n      return retval;\n    }\n    function createMissingBlocksBefore(prevBlockEnd, blockStart, fetchStart, fetchEnd, taskDef) {\n      var retval = null;\n      //if at first block or we've just crossed a gap in steps between cached data blocks:\n      if (prevBlockEnd === null || prevBlockEnd < blockStart - taskDef.resolution) {\n        //The current block starts after our interesting step sequence starts:\n        if (blockStart > fetchStart) {\n          //the current block starts after or at the same step as our interesting step sequence ends:\n          if (blockStart >= fetchEnd) {\n            //create new blocks until the end of our interesting step sequence:\n            if (prevBlockEnd === null) {\n              retval = allocateAndPrepareContinuousBlocks(taskDef, fetchStart, fetchEnd);\n            } else {\n              retval = allocateAndPrepareContinuousBlocks(taskDef, Math.max(prevBlockEnd, fetchStart), fetchEnd);\n            }\n          }\n          //current block starts before our interesting step sequence ends:\n          else {\n            //create new blocks until one step before the start of the current block:\n            if (prevBlockEnd === null) {\n              retval = allocateAndPrepareContinuousBlocks(taskDef, fetchStart, blockStart - taskDef.resolution);\n            } else {\n              retval = allocateAndPrepareContinuousBlocks(taskDef, Math.max(prevBlockEnd + taskDef.resolution, fetchStart), blockStart - taskDef.resolution);\n            }\n          }\n        }\n      }\n      return retval;\n    }\n    function recycleBlock(block) {\n      if (block.isPinned()) {\n        async.whilst(function () {\n          return block.isPinned();\n        }, function (notify) {\n          setTimeout(notify, 500);\n        }, function (err) {\n          block.recycle();\n          emptyBlockPool.push(block);\n        });\n      } else {\n        block.recycle();\n        emptyBlockPool.push(block);\n      }\n    }\n\n    //A single-line queue for running iterateCache: if more than one\n    //iteration is requested simultaneously, others have to queue for\n    //execution, because iterateCache changes the internal cache state asynchronously.\n    var iterateCacheQueue = async.queue(function (taskDef, callback) {\n      callback(null, iterateCache(taskDef));\n    }, 1);\n    function iterateCache(taskDef) {\n      var retval = [];\n      var requestedStart = taskDef.start;\n      var requestedEnd = taskDef.end;\n      var sideFetchBeforeItemCount = Math.ceil(sideFetchBeforeFactor * taskDef.pointCount);\n      var sideFetchAfterItemCount = Math.ceil(sideFetchAfterFactor * taskDef.pointCount);\n      var fetchStart = requestedStart - sideFetchBeforeItemCount * taskDef.resolution;\n      var fetchEnd = requestedEnd + sideFetchAfterItemCount * taskDef.resolution;\n      var blockAgeOrder = [];\n      var newCachedBlocks = [];\n      var mergeInd = -1;\n      var blockToMerge = null;\n      var prevMatchingBlock = null;\n      var sortIterator = function (bl) {\n        return bl.getStart();\n      };\n      cachedDataSize = 0;\n      //add all merged blocks that are ready:\n      while (mergedBlocks.length > 0) {\n        blockToMerge = mergedBlocks.shift();\n        mergeInd = _.sortedIndex(cachedBlocks, blockToMerge, sortIterator);\n        cachedBlocks.splice(mergeInd, 0, blockToMerge);\n      }\n      if (cachedBlocks.length > 0) {\n        _.each(cachedBlocks, function (block, index) {\n          var selectThisBlock = false;\n          var newBlocksBefore = null;\n          var newBlocksAfter = null;\n          var prevBlockEnd = null;\n          var blStart = block.getStart();\n          var blEnd = block.getEnd();\n          if (block.isWaitingRecycling()) {\n            recycleBlock(block);\n            return;\n            //=continue each loop;\n          }\n\n          //This block contains data for the relevant service, with the same locations and parameters:\n          if (taskDef.service === block.getService() && arrayEqualsAnyOrder(taskDef.location, block.getLocation()) && arrayEqualsAnyOrder(taskDef.parameter, block.getParameter())) {\n            if (prevMatchingBlock !== null) {\n              prevBlockEnd = prevMatchingBlock.getEnd();\n            }\n\n            //check if we should create new data blocks before the current block:\n            newBlocksBefore = createMissingBlocksBefore(prevBlockEnd, blStart, fetchStart, fetchEnd, taskDef);\n            if (newBlocksBefore !== null && newBlocksBefore.length > 0) {\n              Array.prototype.push.apply(newCachedBlocks, newBlocksBefore);\n              async.reduce(newBlocksBefore, cacheMisses, function (memo, block, callback) {\n                callback(null, memo + block.getDataSize());\n              }, function (err, result) {\n                cacheMisses = result;\n              });\n              Array.prototype.push.apply(retval, newBlocksBefore);\n            }\n            selectThisBlock = blockOverlaps(blStart, blEnd, fetchStart, fetchEnd);\n            if (selectThisBlock) {\n              if (block.pin() > 0) {\n                retval.push(block);\n                cacheHits += block.getDataSize();\n              } else {\n                if (\"undefined\" !== typeof console && console) {\n                  console.log('Unable to pin a block, it\\'s already marked for recycling (this should not happen)');\n                }\n              }\n            } else {\n              block.increaseNotUsed();\n            }\n            newCachedBlocks.push(block);\n\n            //check if we should merge this block with the previous one:\n            if (prevMatchingBlock !== null && shouldBlocksBeMerged(prevMatchingBlock, block)) {\n              mergeBlocks(prevMatchingBlock, block, function (err, merged) {\n                if (err) {\n                  //Merge failed. This should only happen if the data for either block\n                  //could not be fetched.\n                  if (\"undefined\" !== typeof console && console) {\n                    console.error(err);\n                  }\n                } else {\n                  //Both merged old blocks have already been marked for recycling at this point.\n                  //Postpone adding the new block until the beginning of the next fetch cycle:\n                  mergedBlocks.push(merged);\n                }\n              });\n            }\n            prevMatchingBlock = block;\n          } else {\n            block.increaseNotUsed();\n            //not matched in this cycle, keep in cache still:\n            newCachedBlocks.push(block);\n          }\n\n          //If we are at the last cached block, check if we should additionally\n          //create new data blocks after the last matching found block.\n          if (index === cachedBlocks.length - 1) {\n            //we've found at least one matching block in cache:\n            if (prevMatchingBlock !== null) {\n              //If our interesting step sequence ends after the last matching found block ends:\n              if (prevMatchingBlock.getEnd() + taskDef.resolution < fetchEnd) {\n                newBlocksAfter = allocateAndPrepareContinuousBlocks(taskDef, Math.max(blEnd + taskDef.resolution, fetchStart), fetchEnd);\n                Array.prototype.push.apply(newCachedBlocks, newBlocksAfter);\n                async.reduce(newBlocksAfter, cacheMisses, function (memo, block, callback) {\n                  callback(null, memo + block.getDataSize());\n                }, function (err, result) {\n                  cacheMisses = result;\n                });\n                Array.prototype.push.apply(retval, newBlocksAfter);\n              }\n            }\n          }\n\n          //Place the current block at the evictOrder list at the current place based on it's age:\n          var ageInd = _.sortedIndex(blockAgeOrder, block, function (bl) {\n            return bl.getNotUsedSince();\n          });\n          blockAgeOrder.splice(ageInd, 0, block);\n          cachedDataSize += block.getDataSize();\n        });\n      }\n\n      //no blocks in cache or none available for use right now, allocate new ones for the whole step sequence:\n      if (retval.length === 0) {\n        retval = allocateAndPrepareContinuousBlocks(taskDef, fetchStart, fetchEnd);\n        Array.prototype.push.apply(newCachedBlocks, retval);\n        async.reduce(retval, cacheMisses, function (memo, block, callback) {\n          callback(null, memo + block.getDataSize());\n        }, function (err, result) {\n          cacheMisses = result;\n        });\n      }\n      cachedBlocks = [];\n      cachedBlocks = newCachedBlocks;\n      newCachedBlocks = [];\n      async.whilst(function () {\n        return cachedDataSize * 1.01 > maxCacheDataSize;\n      }, function () {\n        var dataToEvict = cachedDataSize * 1.01 - maxCacheDataSize;\n        fireEvent('evictStarted', {\n          'inCache': cachedDataSize,\n          'toEvict': dataToEvict\n        });\n        var evictList = [];\n        var toEvict = null;\n        var evictListDataSize = 0;\n        while (evictListDataSize < dataToEvict && blockAgeOrder.length > 0) {\n          toEvict = blockAgeOrder.pop();\n          if (toEvict !== undefined) {\n            evictListDataSize += toEvict.getDataSize();\n            evictList.push(toEvict);\n          }\n        }\n        if (evictList.length > 0) {\n          evict(evictList);\n          cachedDataSize = cachedDataSize - evictListDataSize;\n          fireEvent('evictFinished', {\n            'inCache': cachedDataSize,\n            'evicted': evictListDataSize\n          });\n        }\n      }, function () {\n        //NOOP\n      });\n      return retval;\n    }\n    function allocateAndPrepareContinuousBlocks(parentTaskDef, start, end) {\n      var blocks = [];\n      var totalPointCount = Math.round((end - start) / parentTaskDef.resolution) + 1;\n      var blocksNeeded = Math.ceil(totalPointCount / maxBlockDataPoints);\n      var i = 0;\n      var taskDef;\n      var block = null;\n      for (i = 0; i < blocksNeeded; i++) {\n        block = getDataBlock();\n        taskDef = _.clone(parentTaskDef);\n        taskDef.start = start + i * (parentTaskDef.resolution * maxBlockDataPoints);\n        taskDef.pointCount = Math.min(maxBlockDataPoints, totalPointCount - i * maxBlockDataPoints);\n        taskDef.end = taskDef.start + (taskDef.pointCount - 1) * parentTaskDef.resolution;\n        block.prepare(taskDef, getFetcher(parentTaskDef.service));\n        if (block.pin() > 0) {\n          blocks.push(block);\n        } else {\n          if (\"undefined\" !== typeof console && console) {\n            console.error('Strange, unable to pin block!');\n          }\n        }\n      }\n      return blocks;\n    }\n\n    /**\n     * @param source If source is an object, it should provide source[loc][param][index] structure that is used\n     *                           to get the data value for the target[loc][param][index] object. If source is not an object,\n     *                           the source itself is set directly into the target[loc][param][index].\n     */\n\n    function fillWith(target, source, locations, parameters, targetIndex, sourceIndex, count, callback) {\n      var copyFromArray = _.isObject(source);\n      var ti = 0;\n      var si = 0;\n      var end = 0;\n      async.each(locations, function (loc, locNotify) {\n        if (target[loc] === undefined) {\n          target[loc] = {};\n        }\n        async.each(parameters, function (param, paramNotify) {\n          var useErrorValues = false;\n          if (target[loc][param] === undefined) {\n            target[loc][param] = [];\n          }\n          if (copyFromArray) {\n            if (!_.isObject(source[loc]) || !_.isArray(source[loc][param])) {\n              useErrorValues = true;\n            } else if (source[loc][param].length < sourceIndex + count) {\n              useErrorValues = true;\n              if (\"undefined\" !== typeof console && console) {\n                console.error('Trying to fill segment with only ' + source[loc][param].length + ' values for location ' + loc + ' and parameter ' + param + ' when ' + (sourceIndex + count) + ' would be needed. Filling the whole segment with \\'' + errorFillValue + '\\'');\n              }\n            }\n          }\n          if (useErrorValues) {\n            ti = targetIndex;\n            end = targetIndex + count;\n            while (ti < end) {\n              target[loc][param][ti++] = errorFillValue;\n            }\n          } else if (copyFromArray) {\n            ti = targetIndex;\n            si = sourceIndex;\n            end = targetIndex + count;\n            while (ti < end) {\n              target[loc][param][ti++] = source[loc][param][si++];\n            }\n          } else {\n            ti = targetIndex;\n            end = targetIndex + count;\n            while (ti < end) {\n              target[loc][param][ti++] = source;\n            }\n          }\n          paramNotify();\n        }, function (err) {\n          //one location completed\n          locNotify();\n        });\n      }, function (err) {\n        //all done:\n        callback(err, target);\n      });\n    }\n    function retrieveDataAsync(origTaskDef, finishCallback, progressCallback) {\n      var taskDef = _.clone(origTaskDef);\n      if (!_.isFunction(finishCallback)) {\n        throw 'finishCallback must be a function';\n      }\n      if (getFetcher(taskDef.service) === null) {\n        throw 'No data fetcher set for service \\'' + taskDef.service + '\\', unable to provide data';\n      }\n\n      //If the new request does not have the same resolution or the start difference is not a multiple of resolution\n      //then clear all cached results for this service:\n      if (stepResolutions[taskDef.service] !== undefined) {\n        if (stepResolutions[taskDef.service].resolution !== taskDef.resolution || Math.abs(stepResolutions[taskDef.service].start - taskDef.start) % taskDef.resolution !== 0) {\n          clear(taskDef.service);\n        }\n      }\n      stepResolutions[taskDef.service] = {\n        start: taskDef.start,\n        resolution: taskDef.resolution\n      };\n      iterateCacheQueue.push(taskDef, function (err, dataBlocks) {\n        fetchDataForBlocks(dataBlocks, taskDef, finishCallback, progressCallback);\n      });\n    }\n    function fetchDataForBlocks(dataBlocks, taskDef, finishCallback, progressCallback) {\n      var errors = null;\n      var notifyProgress = false;\n      var result = {};\n      if (_.isFunction(progressCallback)) {\n        notifyProgress = true;\n      }\n      fireEvent('fetchStarted', taskDef);\n      result.steps = _.range(taskDef.start, taskDef.end + taskDef.resolution, taskDef.resolution);\n      result.data = {};\n      async.each(dataBlocks, function (dataBlock, notify) {\n        var td = dataBlock.getTaskDef();\n        var includeStart = NaN;\n        var includeEnd = NaN;\n        var targetStartIndex = NaN;\n        var targetEndIndex = NaN;\n        var sourceStartIndex = NaN;\n        var valueCount = NaN;\n        if (!blockOverlaps(td.start, td.end, taskDef.start, taskDef.end)) {\n          //For completely out-of-range blocks:\n          //we fetch them just to cache them, but otherwise\n          //ignore the results completely:\n          dataBlock.getDataAsync(function () {\n            dataBlock.unpin();\n          });\n\n          //and continue the loop:\n          notify();\n          return;\n        }\n        if (td.start < taskDef.start) {\n          includeStart = taskDef.start;\n          sourceStartIndex = Math.round((taskDef.start - td.start) / taskDef.resolution);\n        } else {\n          includeStart = td.start;\n          sourceStartIndex = 0;\n        }\n        targetStartIndex = _.indexOf(result.steps, includeStart);\n        if (targetStartIndex === -1) {\n          throw dataBlock.getId() + ':something wrong with indexing, start index for cache block not found in the combined results!';\n        }\n        if (td.end > taskDef.end) {\n          includeEnd = taskDef.end;\n          targetEndIndex = result.steps.length - 1;\n        } else {\n          includeEnd = td.end;\n          targetEndIndex = _.indexOf(result.steps, td.end, true);\n        }\n        valueCount = targetEndIndex - targetStartIndex + 1;\n\n        // See fillWith function description about the structure that data object should have.\n        dataBlock.getDataAsync(function (err, data) {\n          var fillValue = data;\n          if (err) {\n            if (errors === null) {\n              errors = [];\n            }\n            errors.push({\n              start: td.start,\n              end: td.end,\n              error: err\n            });\n\n            // error in fetching data, fill result with 'errorFillValue' for this step sequence if data is undefined itself.\n            // Notice, errors may have occurred but data is still given because it should be good enough.\n            // Therefore, do not ignore given data if it is available. It is up to the data provider to make\n            // sure that data is undefined if it should not be handled in cache.\n\n            //Ilkka Rinne/2013-09-02: This is inconsistent with the node.js callback error conventions:\n            //You should always get either an error or result, never both.\n            //http://nodemanual.org/latest/nodejs_dev_guide/working_with_callbacks.html\n            //When would you want to return errors but also useable data?\n\n            if (strictErrorHandling || !data) {\n              fillValue = errorFillValue;\n            }\n            //do not keep this block in cache:\n            dataBlock.markForRecycling();\n          }\n          fillWith(result.data, fillValue, td.location, td.parameter, targetStartIndex, sourceStartIndex, valueCount, function () {\n            if (notifyProgress) {\n              progressCallback(err, includeStart, includeEnd);\n            }\n            dataBlock.unpin();\n\n            //always succeed, even with fetch error: we want to return the rest of the data anyway\n            notify();\n          });\n        });\n      }, function (err) {\n        finishCallback(errors, result);\n        fireEvent('fetchFinished', taskDef);\n      });\n    }\n    function getFetcher(service) {\n      if (fetchers[service] !== undefined) {\n        fetchers[service].nextIndex = (fetchers[service].nextIndex + 1) % fetchers[service].providers.length;\n        return fetchers[service].providers[fetchers[service].nextIndex].cb;\n      } else {\n        return null;\n      }\n    }\n    function clear(service) {\n      _.each(cachedBlocks, function (block) {\n        if (service === undefined || block.getService() === service) {\n          block.markForRecycling();\n        }\n      });\n      _.each(mergedBlocks, function (block) {\n        if (service === undefined || block.getService() === service) {\n          block.markForRecycling();\n        }\n      });\n      fireEvent('cacheCleared', service);\n    }\n\n    //Privileged functions:\n    /**\n     * @param {String} service Describes the service name that identifies the data.\n     *                                               May not be {undefined}, {null} or empty. More than one fetcher\n     *                                               may be added for the same service to enable a round-robin task\n     *                                               distribution between them.\n     * @param {function(taskDef, callback)} fetcher The callback parameter of fetcher callback function is of\n     *                                              the type {function(err, data)}. See {fillWith()} function\n     *                                              for the description for the source data object structure\n     *                                              that should be provided by the fetcher callback function for\n     *                                              its parameter callback function.\n     */\n    this.addDataProvider = function (service, fetcher) {\n      var provider = {};\n      if (_.isFunction(fetcher)) {\n        if (fetchers[service] === undefined) {\n          fetchers[service] = {\n            nextIndex: 0,\n            providers: []\n          };\n        }\n        provider.id = 'id#' + fetcherIdCounter++;\n        provider.cb = fetcher;\n        fetchers[service].providers.push(provider);\n        fireEvent('dataProviderAdded', {\n          'service': service,\n          'providerId': provider.id\n        });\n      } else {\n        throw 'Fetcher must be a function';\n      }\n      return provider.id;\n    };\n    this.removeDataProvider = function (service, providerId) {\n      var oldLength = 0;\n      var actuallyRemoved = false;\n      if (fetchers[service] !== undefined) {\n        oldLength = fetchers[service].providers.length;\n        fetchers[service].providers = _.reject(fetchers[service].providers, function (provider) {\n          return provider.id === providerId;\n        });\n        if (fetchers[service].providers.length === 0) {\n          delete fetchers.service;\n          actuallyRemoved = true;\n        } else if (oldLength !== fetchers[service].providers.length) {\n          actuallyRemoved = true;\n        }\n        if (actuallyRemoved) {\n          fireEvent('dataProviderRemoved', {\n            'service': service,\n            'providerId': providerId\n          });\n        }\n      }\n    };\n\n    /**\n     * Removes all content from the cache and resets the hits & misses counters.\n     *\n     */\n    this.clearCache = function () {\n      clear();\n      stepResolutions = [];\n      cacheHits = 0;\n      cacheMisses = 0;\n    };\n    this.fetch = function (taskDef, finalCallback, progressCallback) {\n      checkTaskDef(taskDef);\n      retrieveDataAsync(taskDef, finalCallback, progressCallback);\n    };\n    this.getCachedItemCount = function () {\n      return cachedDataSize;\n    };\n    this.getFillingDegree = function () {\n      return cachedDataSize / maxCacheDataSize;\n    };\n    this.getHitRatio = function () {\n      return cacheHits / (cacheHits + cacheMisses);\n    };\n    this.addListener = function (eventName, callback) {\n      return addEventListener(eventName, callback);\n    };\n    this.removeListener = function (eventName, providerId) {\n      return removeEventListener(eventName, providerId);\n    };\n\n    //Instance initialization:\n    if (properties.sideFetchBeforeFactor !== undefined) {\n      if (_.isNumber(properties.sideFetchBeforeFactor)) {\n        if (properties.sideFetchBeforeFactor >= 0) {\n          sideFetchBeforeFactor = properties.sideFetchBeforeFactor;\n        }\n      }\n    }\n    if (properties.sideFetchAfterFactor !== undefined) {\n      if (_.isNumber(properties.sideFetchAfterFactor)) {\n        if (properties.sideFetchAfterFactor >= 0) {\n          sideFetchAfterFactor = properties.sideFetchAfterFactor;\n        }\n      }\n    }\n    if (properties.maxBlockDataPoints !== undefined) {\n      if (_.isNumber(properties.maxBlockDataPoints)) {\n        if (properties.maxBlockDataPoints > 0) {\n          maxBlockDataPoints = properties.maxBlockDataPoints;\n        }\n      }\n    }\n    if (properties.minBlockDataPoints !== undefined) {\n      if (_.isNumber(properties.minBlockDataPoints)) {\n        if (properties.minBlockDataPoints > 0 && properties.minBlockDataPoints < maxBlockDataPoints) {\n          minBlockDataPoints = properties.minBlockDataPoints;\n        } else {\n          minBlockDataPoints = 0;\n        }\n      }\n    }\n    if (minBlockDataPoints > maxBlockDataPoints) {\n      minBlockDataPoints = maxBlockDataPoints;\n    }\n    if (properties.maxCacheDataSize !== undefined) {\n      if (_.isNumber(properties.maxCacheDataSize)) {\n        if (properties.maxCacheDataSize > 0) {\n          maxCacheDataSize = properties.maxCacheDataSize;\n        }\n      }\n    }\n    if (properties.strictErrorHandling !== undefined) {\n      if (properties.strictErrorHandling === false) {\n        strictErrorHandling = false;\n      }\n    }\n    if (properties.errorFillValue !== undefined) {\n      errorFillValue = properties.errorFillValue;\n    }\n  };\n\n  /**\n   * SplitterCache constructor is returned for later instantiation.\n   */\n  return _constructor;\n}();\nmodule.exports = SplitterCache;","map":{"version":3,"names":["_","require","async","SplitterCache","checkTaskDef","taskDef","placeholder","startNudge","endNudge","isObject","isString","service","isArray","location","push","parameter","isNumber","resolution","Math","round","start","pointCount","end","arrayEqualsAnyOrder","arr1","arr2","i","length","indexOf","undefined","DataBlock","blockCounter","_constructor","evtDispatcher","id","fetchError","fetcher","data","age","fetching","fetched","pinCount","waitingRecycling","waitingMerging","ready","callbacks","requestId","dispatcher","thisBlock","reset","getId","getTaskDef","getStart","getEnd","getPointCount","getResolution","getService","getLocation","getParameter","getDataSize","pin","unpin","isPinned","getPinCount","getRequestId","isWaitingRecycling","isWaitingMerging","isFetched","setFetched","f","isFetching","setFetching","increaseNotUsed","getNotUsedSince","fetchFailed","markForRecycling","markForMerging","merge","setData","d","getFetcher","recycle","prepare","taskDefinition","dataFetcher","isFunction","getDataAsync","callback","that","err","result","reqId","whilst","myReqId","notify","cb","pop","call","ex","console","error","message","defer","eventListenerIdCounter","fetcherIdCounter","properties","emptyBlockPool","cachedBlocks","mergedBlocks","stepResolutions","sideFetchBeforeFactor","sideFetchAfterFactor","maxBlockDataPoints","minBlockDataPoints","maxCacheDataSize","strictErrorHandling","errorFillValue","NaN","fetchers","cachedDataSize","cacheHits","cacheMisses","thisCache","eventListeners","blockCreated","blockPrepared","blockProviderFetchStarted","blockProviderFetchFinished","blockCacheFetchStarted","blockCacheFetchFinished","blockPinned","blockUnpinned","blockEvicted","blockRecycled","blockAged","blockMarkedForMerge","blockMergeCancelled","evictStarted","evictFinished","fetchStarted","fetchFinished","cacheCleared","dataProviderAdded","dataProviderRemoved","fireEvent","eventName","eventData","each","addEventListener","listenerId","reduce","keys","memo","name","ind","removeEventListener","evict","evictList","toEvict","mergeBlocks","block1","block2","newBlock","combinedData","getDataBlock","clone","parallel","data1","log","fillWith","data2","results","Error","blocksAreContinuous","shouldBlocksBeMerged","dataBlock","blockOverlaps","blockStart","blockEnd","retval","createMissingBlocksBefore","prevBlockEnd","fetchStart","fetchEnd","allocateAndPrepareContinuousBlocks","max","recycleBlock","block","setTimeout","iterateCacheQueue","queue","iterateCache","requestedStart","requestedEnd","sideFetchBeforeItemCount","ceil","sideFetchAfterItemCount","blockAgeOrder","newCachedBlocks","mergeInd","blockToMerge","prevMatchingBlock","sortIterator","bl","shift","sortedIndex","splice","index","selectThisBlock","newBlocksBefore","newBlocksAfter","blStart","blEnd","Array","prototype","apply","merged","ageInd","dataToEvict","evictListDataSize","parentTaskDef","blocks","totalPointCount","blocksNeeded","min","target","source","locations","parameters","targetIndex","sourceIndex","count","copyFromArray","ti","si","loc","locNotify","param","paramNotify","useErrorValues","retrieveDataAsync","origTaskDef","finishCallback","progressCallback","abs","clear","dataBlocks","fetchDataForBlocks","errors","notifyProgress","steps","range","td","includeStart","includeEnd","targetStartIndex","targetEndIndex","sourceStartIndex","valueCount","fillValue","nextIndex","providers","addDataProvider","provider","removeDataProvider","providerId","oldLength","actuallyRemoved","reject","clearCache","fetch","finalCallback","getCachedItemCount","getFillingDegree","getHitRatio","addListener","removeListener","module","exports"],"sources":["C:/Users/Ossi Laurila/Desktop/weatherapp/node_modules/@fmidev/metolib/splittercache.js"],"sourcesContent":["/**\n * Metolib.SplitterCache\n * =======================================\n *\n * See https://github.com/fmidev/metolib/wiki/SplitterCache for documentation.\n *\n * Requires:\n * - async.js (https://github.com/caolan/async)\n * - lodash.underscore.js (http://lodash.com/)\n *\n * Original author: Ilkka Rinne / Spatineo Inc. for the Finnish Meteorological Institute\n *\n *\n * This software may be freely distributed and used under the following MIT license:\n *\n * Copyright (c) 2017 Finnish Meteorological Institute\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the\n * Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\n\n// Strict mode for whole file.\n\"use strict\";\n\n// Requires lodash, async\nvar _ = require('lodash');\nvar async = require('async');\n// import _ from 'lodash';\n// import async from 'async';\n\nvar SplitterCache = (function(){\n\n    //Functions and variables shared with all instances:\n    var checkTaskDef = function(taskDef) {\n        var placeholder;\n        var startNudge = 0;\n        var endNudge = 0;\n        if (!_.isObject(taskDef)) {\n            throw 'taskdef must be an object';\n        }\n\n        if (!_.isString(taskDef.service)) {\n            throw 'taskDef must contain a \\'service\\' property of string type';\n        }\n\n        if (!_.isArray(taskDef.location)) {\n            if (!_.isString(taskDef.location)) {\n                throw 'taskDef must contain a \\'location\\' property of either an array or a string type';\n            } else {\n                placeholder = taskDef.location;\n                taskDef.location = [];\n                taskDef.location.push(placeholder);\n            }\n        }\n\n        if (!_.isArray(taskDef.parameter)) {\n            if (!_.isString(taskDef.parameter)) {\n                throw 'taskDef must contain a \\'parameter\\' property of either an array or a string type';\n            } else {\n                placeholder = taskDef.parameter;\n                taskDef.parameter = [];\n                taskDef.parameter.push(placeholder);\n            }\n        }\n\n        if (!_.isNumber(taskDef.resolution)) {\n            throw 'taskDef must contain a \\'resolution\\' property of numeric type';\n        } else if (taskDef.resolution > 0.5) {\n            taskDef.resolution = Math.round(taskDef.resolution);\n        } else {\n            throw 'taskDef.resolution must be a positive integer';\n        }\n\n        if (!_.isNumber(taskDef.start)) {\n            throw 'taskDef must contain a \\'start\\' property of numeric type';\n        }\n\n        if (_.isNumber(taskDef.pointCount)) {\n            if (taskDef.pointCount > 0) {\n                taskDef.end = taskDef.start + (taskDef.pointCount - 1) * taskDef.resolution;\n            } else {\n                throw 'taskDef.pointCount must be greater than zero';\n            }\n        } else if (_.isNumber(taskDef.end)) {\n            if (taskDef.end < taskDef.start) {\n                throw '\\'end\\' must be greater than or equal to \\'start\\'';\n            }\n            endNudge = (taskDef.end - taskDef.start) % taskDef.resolution;\n            if (endNudge !== 0) {\n                taskDef.end = taskDef.end + (taskDef.resolution - endNudge);\n            }\n            taskDef.pointCount = (taskDef.end - taskDef.start) / taskDef.resolution + 1;\n        } else {\n            throw 'taskDef must contain either \\'end\\' or \\'pointCount\\' property of numeric type';\n        }\n    };\n\n    var arrayEqualsAnyOrder = function(arr1, arr2) {\n        var i = 0;\n        if (_.isArray(arr1) && _.isArray(arr2)) {\n            if (arr1.length === arr2.length) {\n                for ( i = 0; i < arr1.length; i++) {\n                    if (_.indexOf(arr2, arr1[i]) === -1) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                return false;\n            }\n        } else if ((arr1 === undefined) || (arr1 === null) || (arr2 === undefined) || (arr2 === null)) {\n            return false;\n        } else {\n            return (arr1 === arr2);\n        }\n    };\n\n    /**\n     * DataBlock constructor\n     *\n     * DataBlock is provided as an internal class.\n     * DataBlock instances are created internally by the cache object.\n     */\n    var DataBlock = (function() {\n        var blockCounter = 0;\n\n        var _constructor = function DataBlock(evtDispatcher) {\n            var id = null;\n            var fetchError = null;\n            var fetcher = null;\n            var data = null;\n            var taskDef = null;\n            var age = 0;\n            var fetching = false;\n            var fetched = false;\n            var pinCount = 0;\n            var waitingRecycling = false;\n            var waitingMerging = false;\n            var ready = false;\n            var callbacks = [];\n            var requestId = 0;\n            var dispatcher = evtDispatcher;\n            var thisBlock = this;\n\n            //Private functions:\n\n            function reset() {\n                fetchError = null;\n                fetcher = null;\n                data = null;\n                taskDef = null;\n                age = 0;\n                fetching = false;\n                fetched = false;\n                pinCount = 0;\n                waitingRecycling = false;\n                waitingMerging = false;\n                ready = false;\n                callbacks = [];\n\n            }\n\n            //Privileged functions:\n            this.getId = function() {\n                return id;\n            };\n\n            this.getTaskDef = function() {\n                return taskDef;\n            };\n\n            this.getStart = function() {\n                return (taskDef !== null) ? taskDef.start : undefined;\n            };\n\n            this.getEnd = function() {\n                return (taskDef !== null) ? taskDef.end : undefined;\n            };\n\n            this.getPointCount = function() {\n                return (taskDef !== null) ? taskDef.pointCount : undefined;\n            };\n\n            this.getResolution = function() {\n                return (taskDef !== null) ? taskDef.resolution : undefined;\n            };\n\n            this.getService = function() {\n                return (taskDef !== null) ? taskDef.service : undefined;\n            };\n\n            this.getLocation = function() {\n                return (taskDef !== null) ? taskDef.location : undefined;\n            };\n\n            this.getParameter = function() {\n                return (taskDef !== null) ? taskDef.parameter : undefined;\n            };\n\n            this.getDataSize = function() {\n                return (taskDef !== null) ? (taskDef.pointCount * taskDef.parameter.length * taskDef.location.length) : 0;\n            };\n\n            this.pin = function() {\n                if (!waitingRecycling) {\n                    pinCount++;\n                    if (dispatcher) {\n                        dispatcher('blockPinned', thisBlock);\n                    }\n                    return pinCount;\n                } else {\n                    return null;\n                }\n            };\n\n            this.unpin = function() {\n                if (pinCount > 0) {\n                    pinCount--;\n                    if (dispatcher) {\n                        dispatcher('blockUnpinned', thisBlock);\n                    }\n                }\n                return pinCount;\n            };\n\n            this.isPinned = function() {\n                return (pinCount > 0);\n            };\n\n            this.getPinCount = function() {\n                return pinCount;\n            };\n\n            this.getRequestId = function() {\n                return requestId;\n            };\n\n            this.isWaitingRecycling = function() {\n                return waitingRecycling;\n            };\n\n            this.isWaitingMerging = function() {\n                return waitingMerging;\n            };\n\n            this.isFetched = function() {\n                return fetched;\n            };\n\n            this.setFetched = function(f) {\n                if (f === true) {\n                    fetched = true;\n                } else {\n                    fetched = false;\n                }\n            };\n\n            this.isFetching = function() {\n                return fetching;\n            };\n\n            this.setFetching = function(f) {\n                if (f === true) {\n                    fetching = true;\n                } else {\n                    fetching = false;\n                }\n            };\n\n            this.increaseNotUsed = function() {\n                age++;\n                if (dispatcher) {\n                    dispatcher('blockAged', thisBlock);\n                }\n            };\n\n            this.getNotUsedSince = function() {\n                return age;\n            };\n\n            this.fetchFailed = function() {\n              return fetchError !== null;\n            };\n\n            this.markForRecycling = function() {\n                waitingRecycling = true;\n                if (dispatcher) {\n                    dispatcher('blockEvicted', thisBlock);\n                }\n            };\n\n            this.markForMerging = function(merge) {\n                if (merge === true){\n                    waitingMerging = true;\n                    if (dispatcher) {\n                        dispatcher('blockMarkedForMerge', thisBlock);\n                    }\n                }\n                else {\n                    waitingMerging = false;\n                    if (dispatcher) {\n                        dispatcher('blockMergeCancelled', thisBlock);\n                    }\n                }\n            };\n\n            this.setData = function(d) {\n                data = d;\n            };\n\n            this.getFetcher = function() {\n                return fetcher;\n            };\n\n            this.recycle = function() {\n                reset();\n                if (dispatcher) {\n                    dispatcher('blockRecycled', thisBlock);\n                }\n            };\n\n            /**\n             * TaskDef: {\n             *          service,\n             *          parameter,\n             *          location,\n             *          start,\n             *          resolution,\n             *          pointCount\n             * }\n             */\n            this.prepare = function(taskDefinition, dataFetcher) {\n                if (!_.isFunction(dataFetcher)) {\n                    throw 'fetcher must be a function';\n                }\n                checkTaskDef(taskDefinition);\n                reset();\n                taskDef = taskDefinition;\n                fetcher = dataFetcher;\n                ready = true;\n                requestId++;\n                if (dispatcher) {\n                    dispatcher('blockPrepared', thisBlock);\n                }\n            };\n\n            /**\n             * @param callback {function(err,data)}\n             */\n            this.getDataAsync = function(callback) {\n                var that = this;\n                if (!ready) {\n                    throw 'Cannot getData in unprepared state, call prepare first';\n                }\n                age = 0;\n                if (!fetched) {\n                    if ((callback !== undefined) && _.isFunction(callback)) {\n                        callbacks.push(callback);\n                    }\n                    if (!fetching) {\n                        fetching = true;\n                        fetcher(taskDef, function(err, result) {\n                            var reqId = that.getRequestId();\n                            if (err) {\n                                fetchError = err;\n                            }\n                            data = result;\n                            fetched = true;\n                            if (callbacks.length === 0) {\n                                fetching = false;\n                            } else {\n                                async.whilst(function() {\n                                    var myReqId = that.getRequestId();\n                                    //We may still be looping here when this block has been recycled, re-prepared and fetching for the next request.\n                                    //So need to check if the request has not changed and we still have callbacks.\n                                    //The callbacks for the next request will still be looped through when the time is right.\n                                    return ((reqId === myReqId) && (callbacks.length > 0));\n                                }, function(notify) {\n                                    try {\n                                        var cb = callbacks.pop();\n                                        cb.call(that, fetchError, data);\n                                    } catch (ex) {\n                                        if (\"undefined\" !== typeof console && console) {\n                                            console.error('Error in block finished callback:' + ex.message);\n                                        }\n                                    } finally {\n                                        notify();\n                                        fetching = false;\n                                    }\n                                }, function(err) {\n                                    //NOOP\n                                });\n                            }\n                            if (dispatcher) {\n                                dispatcher('blockProviderFetchFinished', thisBlock);\n                            }\n                        });\n                        if (dispatcher) {\n                            dispatcher('blockProviderFetchStarted', thisBlock);\n                        }\n                    }\n\n                } else {\n                    if (_.isFunction(callback)) {\n                        _.defer(function(err, d) {\n                            if (dispatcher) {\n                                dispatcher('blockCacheFetchFinished', thisBlock);\n                            }\n                            callback(err, d);\n                        }, fetchError, data);\n                        if (dispatcher) {\n                            dispatcher('blockCacheFetchStarted', thisBlock);\n                        }\n                    } else {\n\n                    }\n                }\n            };\n\n            //Instance initialization:\n            id = 'id#' + blockCounter++;\n\n            if (dispatcher) {\n                dispatcher('blockCreated', thisBlock);\n            }\n        };\n\n        return _constructor;\n    })();\n\n    var eventListenerIdCounter = 0;\n    var fetcherIdCounter = 0;\n\n    /**\n     * SplitterCache constructor\n     *\n     * Constructor contains priviledged methods that are provided as API functions\n     * for the instantiated cache object.\n     */\n    var _constructor = function SplitterCache(properties) {\n        var emptyBlockPool = [];\n        var cachedBlocks = [];\n        var mergedBlocks = [];\n        var stepResolutions = [];\n        var sideFetchBeforeFactor = 0.5;\n        var sideFetchAfterFactor = 1;\n        var maxBlockDataPoints = 500;\n        var minBlockDataPoints = 20;\n        var maxCacheDataSize = 50000;\n        var strictErrorHandling = true;\n        var errorFillValue = NaN;\n\n        var fetchers = {};\n        var cachedDataSize = 0;\n        var cacheHits = 0;\n        var cacheMisses = 0;\n        var thisCache = this;\n\n        var eventListeners = {\n            blockCreated : {},\n            blockPrepared : {},\n            blockProviderFetchStarted : {},\n            blockProviderFetchFinished : {},\n            blockCacheFetchStarted : {},\n            blockCacheFetchFinished : {},\n            blockPinned : {},\n            blockUnpinned : {},\n            blockEvicted : {},\n            blockRecycled : {},\n            blockAged : {},\n            blockMarkedForMerge : {},\n            blockMergeCancelled : {},\n            evictStarted : {},\n            evictFinished : {},\n            fetchStarted : {},\n            fetchFinished : {},\n            cacheCleared : {},\n            dataProviderAdded : {},\n            dataProviderRemoved : {}\n        };\n\n        //Private functions:\n        //Event handling:\n\n        function fireEvent(eventName, eventData) {\n            if (eventListeners[eventName] !== undefined) {\n                _.each(eventListeners[eventName], function(cb) {\n                    try {\n                        cb.call(thisCache, eventData);\n                    } catch (ex) {\n                    }\n                });\n            }\n        }\n\n        function addEventListener(eventName, cb) {\n            var listenerId = null;\n            if (eventListeners[eventName] !== undefined) {\n                if (_.isFunction(cb)) {\n                    listenerId = 'id' + (eventListenerIdCounter++);\n                    eventListeners[eventName][listenerId] = cb;\n                } else {\n                    throw 'Event listener callback is not a function';\n                }\n            } else {\n                throw 'Unknown event \\'' + eventName + '\\', use one of ' + _.reduce(_.keys(eventListeners), function(memo, name, ind) {\n                    if (ind > 0) {\n                        memo = memo + ', ';\n                    }\n                    memo = memo + name;\n                    return memo;\n                });\n            }\n            return listenerId;\n        }\n\n        function removeEventListener(eventName, listenerId) {\n            if (eventListeners[eventName] !== undefined) {\n                if (eventListeners[eventName][listenerId] !== undefined) {\n                    delete eventListeners[eventName][listenerId];\n                }\n            } else {\n                throw 'Unknown event \\'' + eventName + '\\', use one of ' + _.reduce(_.keys(eventListeners), function(memo, name, ind) {\n                    if (ind > 0) {\n                        memo = memo + ', ';\n                    }\n                    memo = memo + name;\n                });\n            }\n        }\n\n        function evict(evictList) {\n            async.each(evictList, function(toEvict, notify) {\n                toEvict.markForRecycling();\n                notify();\n            }, function(err) {\n                if (err && \"undefined\" !== typeof console && console) {\n                    console.error(err);\n                }\n            });\n        }\n\n        function mergeBlocks(block1, block2, callback) {\n            var newBlock = null;\n            var taskDef = {};\n            var combinedData = [];\n            if ((block1.pin() > 0) && (block2.pin() > 0)) {\n                block1.markForMerging(true);\n                block2.markForMerging(true);\n                newBlock = getDataBlock();\n                taskDef = _.clone(block1.getTaskDef());\n                taskDef.end = block2.getEnd();\n                taskDef.pointCount = block1.getPointCount() + block2.getPointCount();\n                newBlock.prepare(taskDef, block1.getFetcher());\n                newBlock.setFetching(true);\n                fireEvent('blockCacheFetchStarted', newBlock);\n                async.parallel({\n                    data1 : function(cb) {\n                        block1.getDataAsync(function(err, data) {\n                            if (err) {\n                                if (\"undefined\" !== typeof console && console) {\n                                    console.log('Warning: getDataAsync from merged block1 returned error:\\'' + err + '\\'');\n                                }\n                                cb(err);\n                            }\n                            else {\n                                fillWith(combinedData, data, taskDef.location, taskDef.parameter, 0, 0, block1.getPointCount(), cb);\n                            }\n                        });\n                    },\n                    data2 : function(cb) {\n                        block2.getDataAsync(function(err, data) {\n                            if (err) {\n                                if (\"undefined\" !== typeof console && console) {\n                                    console.log('Warning: getDataAsync from merged block2 returned error:\\'' + err + '\\'');\n                                }\n                                cb(err);\n                            }\n                            else {\n                                fillWith(combinedData, data, taskDef.location, taskDef.parameter, block1.getPointCount(), 0, block2.getPointCount(), cb);\n                            }\n                        });\n                    }\n                }, function(err, results) {\n                    block1.unpin();\n                    block2.unpin();\n                    if (!err){\n                        block1.markForRecycling();\n                        block2.markForRecycling();\n                        newBlock.setData(combinedData);\n                        newBlock.setFetching(false);\n                        newBlock.setFetched(true);\n                        callback(null, newBlock);\n                        fireEvent('blockCacheFetchFinished', newBlock);\n                    } else {\n                        newBlock.reset();\n                        block1.markForMerging(false);\n                        block2.markForMerging(false);\n                        callback(err);\n                        fireEvent('blockCacheFetchFinished', null);\n                    }\n                });\n            } else {\n                _.defer(function() {\n                    callback(new Error('One or both blocks already marked for recycling'));\n                });\n            }\n        }\n\n        function blocksAreContinuous(block1, block2) {\n            if (block1.getResolution() === block2.getResolution() && (block2.getStart() === block1.getEnd() + block1.getResolution())) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        function shouldBlocksBeMerged(block1, block2) {\n            //It's assumed that service, location and parameter equality has already been checked:\n            if (!block1.fetchFailed() && !block2.fetchFailed() && !block1.isWaitingMerging() && !block2.isWaitingMerging() && ((block1.getPointCount() < minBlockDataPoints) || (block2.getPointCount() < minBlockDataPoints)) && blocksAreContinuous(block1, block2) && (block1.getPointCount() + block2.getPointCount() < maxBlockDataPoints)) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        function getDataBlock() {\n            var dataBlock;\n            if (emptyBlockPool.length > 0) {\n                dataBlock = emptyBlockPool.pop();\n            } else {\n                dataBlock = new DataBlock(fireEvent);\n            }\n            return dataBlock;\n        }\n\n        function blockOverlaps(blockStart, blockEnd, start, end) {\n            var retval = false;\n            //exactly matching steps:\n            if ((blockStart === start) && (blockEnd === end)) {\n                retval = true;\n            }\n            //overlapping steps:\n            else if ((blockStart <= end) && (blockEnd > start)) {\n                retval = true;\n            }\n            return retval;\n        }\n\n        function createMissingBlocksBefore(prevBlockEnd, blockStart, fetchStart, fetchEnd, taskDef) {\n            var retval = null;\n            //if at first block or we've just crossed a gap in steps between cached data blocks:\n            if ((prevBlockEnd === null) || (prevBlockEnd < (blockStart - taskDef.resolution))) {\n                //The current block starts after our interesting step sequence starts:\n                if (blockStart > fetchStart) {\n                    //the current block starts after or at the same step as our interesting step sequence ends:\n                    if (blockStart >= fetchEnd) {\n                        //create new blocks until the end of our interesting step sequence:\n                        if (prevBlockEnd === null) {\n                            retval = allocateAndPrepareContinuousBlocks(taskDef, fetchStart, fetchEnd);\n                        } else {\n                            retval = allocateAndPrepareContinuousBlocks(taskDef, Math.max(prevBlockEnd, fetchStart), fetchEnd);\n                        }\n                    }\n                    //current block starts before our interesting step sequence ends:\n                    else {\n                        //create new blocks until one step before the start of the current block:\n                        if (prevBlockEnd === null) {\n                            retval = allocateAndPrepareContinuousBlocks(taskDef, fetchStart, (blockStart - taskDef.resolution));\n                        } else {\n                            retval = allocateAndPrepareContinuousBlocks(taskDef, Math.max((prevBlockEnd + taskDef.resolution), fetchStart), (blockStart - taskDef.resolution));\n                        }\n                    }\n                }\n            }\n            return retval;\n        }\n\n        function recycleBlock(block) {\n            if (block.isPinned()) {\n                async.whilst(function() {\n                    return block.isPinned();\n                }, function(notify) {\n                    setTimeout(notify, 500);\n                }, function(err) {\n                    block.recycle();\n                    emptyBlockPool.push(block);\n                });\n            } else {\n                block.recycle();\n                emptyBlockPool.push(block);\n            }\n        }\n\n        //A single-line queue for running iterateCache: if more than one\n        //iteration is requested simultaneously, others have to queue for\n        //execution, because iterateCache changes the internal cache state asynchronously.\n        var iterateCacheQueue = async.queue(function(taskDef, callback) {\n            callback(null, iterateCache(taskDef));\n        }, 1);\n\n        function iterateCache(taskDef) {\n            var retval = [];\n            var requestedStart = taskDef.start;\n            var requestedEnd = taskDef.end;\n            var sideFetchBeforeItemCount = Math.ceil(sideFetchBeforeFactor * taskDef.pointCount);\n            var sideFetchAfterItemCount = Math.ceil(sideFetchAfterFactor * taskDef.pointCount);\n            var fetchStart = requestedStart - sideFetchBeforeItemCount * taskDef.resolution;\n            var fetchEnd = requestedEnd + sideFetchAfterItemCount * taskDef.resolution;\n            var blockAgeOrder = [];\n            var newCachedBlocks = [];\n            var mergeInd = -1;\n            var blockToMerge = null;\n            var prevMatchingBlock = null;\n\n            var sortIterator = function(bl) {\n                return bl.getStart();\n            };\n\n            cachedDataSize = 0;\n            //add all merged blocks that are ready:\n            while (mergedBlocks.length > 0) {\n                blockToMerge = mergedBlocks.shift();\n                mergeInd = _.sortedIndex(cachedBlocks, blockToMerge, sortIterator);\n                cachedBlocks.splice(mergeInd, 0, blockToMerge);\n            }\n\n            if (cachedBlocks.length > 0) {\n                _.each(cachedBlocks, function(block, index) {\n                    var selectThisBlock = false;\n                    var newBlocksBefore = null;\n                    var newBlocksAfter = null;\n                    var prevBlockEnd = null;\n                    var blStart = block.getStart();\n                    var blEnd = block.getEnd();\n\n                    if (block.isWaitingRecycling()) {\n                        recycleBlock(block);\n                        return;\n                        //=continue each loop;\n                    }\n\n                    //This block contains data for the relevant service, with the same locations and parameters:\n                    if ((taskDef.service === block.getService()) && arrayEqualsAnyOrder(taskDef.location, block.getLocation()) && arrayEqualsAnyOrder(taskDef.parameter, block.getParameter())) {\n                        if (prevMatchingBlock !== null) {\n                            prevBlockEnd = prevMatchingBlock.getEnd();\n                        }\n\n                        //check if we should create new data blocks before the current block:\n                        newBlocksBefore = createMissingBlocksBefore(prevBlockEnd, blStart, fetchStart, fetchEnd, taskDef);\n                        if ((newBlocksBefore !== null) && (newBlocksBefore.length > 0)) {\n                            Array.prototype.push.apply(newCachedBlocks, newBlocksBefore);\n                            async.reduce(newBlocksBefore, cacheMisses, function(memo, block, callback) {\n                                callback(null, memo + block.getDataSize());\n                            }, function(err, result) {\n                                cacheMisses = result;\n                            });\n                            Array.prototype.push.apply(retval, newBlocksBefore);\n                        }\n\n                        selectThisBlock = blockOverlaps(blStart, blEnd, fetchStart, fetchEnd);\n                        if (selectThisBlock) {\n                            if (block.pin() > 0) {\n                                retval.push(block);\n                                cacheHits += block.getDataSize();\n                            } else {\n                                if (\"undefined\" !== typeof console && console) {\n                                    console.log('Unable to pin a block, it\\'s already marked for recycling (this should not happen)');\n                                }\n                            }\n                        } else {\n                            block.increaseNotUsed();\n                        }\n                        newCachedBlocks.push(block);\n\n                        //check if we should merge this block with the previous one:\n                        if ((prevMatchingBlock !== null) && shouldBlocksBeMerged(prevMatchingBlock, block)) {\n                            mergeBlocks(prevMatchingBlock, block, function(err, merged) {\n                                if (err) {\n                                    //Merge failed. This should only happen if the data for either block\n                                    //could not be fetched.\n                                    if (\"undefined\" !== typeof console && console) {\n                                        console.error(err);\n                                    }\n                                } else {\n                                    //Both merged old blocks have already been marked for recycling at this point.\n                                    //Postpone adding the new block until the beginning of the next fetch cycle:\n                                    mergedBlocks.push(merged);\n                                }\n                            });\n                        }\n                        prevMatchingBlock = block;\n                    } else {\n                        block.increaseNotUsed();\n                        //not matched in this cycle, keep in cache still:\n                        newCachedBlocks.push(block);\n                    }\n\n                    //If we are at the last cached block, check if we should additionally\n                    //create new data blocks after the last matching found block.\n                    if (index === (cachedBlocks.length - 1)) {\n                        //we've found at least one matching block in cache:\n                        if (prevMatchingBlock !== null) {\n                            //If our interesting step sequence ends after the last matching found block ends:\n                            if ((prevMatchingBlock.getEnd() + taskDef.resolution) < fetchEnd) {\n                                newBlocksAfter = allocateAndPrepareContinuousBlocks(taskDef, Math.max(blEnd + taskDef.resolution, fetchStart), fetchEnd);\n                                Array.prototype.push.apply(newCachedBlocks, newBlocksAfter);\n                                async.reduce(newBlocksAfter, cacheMisses, function(memo, block, callback) {\n                                    callback(null, memo + block.getDataSize());\n                                }, function(err, result) {\n                                    cacheMisses = result;\n                                });\n                                Array.prototype.push.apply(retval, newBlocksAfter);\n                            }\n                        }\n                    }\n\n                    //Place the current block at the evictOrder list at the current place based on it's age:\n                    var ageInd = _.sortedIndex(blockAgeOrder, block, function(bl) {\n                        return bl.getNotUsedSince();\n                    });\n                    blockAgeOrder.splice(ageInd, 0, block);\n                    cachedDataSize += block.getDataSize();\n                });\n            }\n\n            //no blocks in cache or none available for use right now, allocate new ones for the whole step sequence:\n            if (retval.length === 0) {\n                retval = allocateAndPrepareContinuousBlocks(taskDef, fetchStart, fetchEnd);\n                Array.prototype.push.apply(newCachedBlocks, retval);\n                async.reduce(retval, cacheMisses, function(memo, block, callback) {\n                    callback(null, memo + block.getDataSize());\n                }, function(err, result) {\n                    cacheMisses = result;\n                });\n            }\n            cachedBlocks = [];\n            cachedBlocks = newCachedBlocks;\n            newCachedBlocks = [];\n\n            async.whilst(function() {\n                return cachedDataSize * 1.01 > maxCacheDataSize;\n            }, function() {\n                var dataToEvict = cachedDataSize * 1.01 - maxCacheDataSize;\n                fireEvent('evictStarted', {\n                    'inCache' : cachedDataSize,\n                    'toEvict' : dataToEvict\n                });\n                var evictList = [];\n                var toEvict = null;\n                var evictListDataSize = 0;\n                while ((evictListDataSize < dataToEvict) && (blockAgeOrder.length > 0)) {\n                    toEvict = blockAgeOrder.pop();\n                    if (toEvict !== undefined) {\n                        evictListDataSize += toEvict.getDataSize();\n                        evictList.push(toEvict);\n                    }\n                }\n                if (evictList.length > 0) {\n                    evict(evictList);\n                    cachedDataSize = cachedDataSize - evictListDataSize;\n                    fireEvent('evictFinished', {\n                        'inCache' : cachedDataSize,\n                        'evicted' : evictListDataSize\n                    });\n                }\n            }, function() {\n                //NOOP\n            });\n            return retval;\n        }\n\n        function allocateAndPrepareContinuousBlocks(parentTaskDef, start, end) {\n            var blocks = [];\n            var totalPointCount = Math.round((end - start) / parentTaskDef.resolution) + 1;\n            var blocksNeeded = Math.ceil(totalPointCount / maxBlockDataPoints);\n            var i = 0;\n            var taskDef;\n            var block = null;\n            for ( i = 0; i < blocksNeeded; i++) {\n                block = getDataBlock();\n                taskDef = _.clone(parentTaskDef);\n                taskDef.start = start + i * (parentTaskDef.resolution * maxBlockDataPoints);\n                taskDef.pointCount = Math.min(maxBlockDataPoints, totalPointCount - (i * maxBlockDataPoints));\n                taskDef.end = taskDef.start + (taskDef.pointCount - 1) * parentTaskDef.resolution;\n                block.prepare(taskDef, getFetcher(parentTaskDef.service));\n                if (block.pin() > 0) {\n                    blocks.push(block);\n                } else {\n                    if (\"undefined\" !== typeof console && console) {\n                        console.error('Strange, unable to pin block!');\n                    }\n                }\n            }\n            return blocks;\n        }\n\n        /**\n         * @param source If source is an object, it should provide source[loc][param][index] structure that is used\n         *                           to get the data value for the target[loc][param][index] object. If source is not an object,\n         *                           the source itself is set directly into the target[loc][param][index].\n         */\n\n        function fillWith(target, source, locations, parameters, targetIndex, sourceIndex, count, callback) {\n            var copyFromArray = _.isObject(source);\n            var ti = 0;\n            var si = 0;\n            var end = 0;\n            async.each(locations, function(loc, locNotify) {\n                if (target[loc] === undefined) {\n                    target[loc] = {};\n                }\n                async.each(parameters, function(param, paramNotify) {\n                    var useErrorValues = false;\n                    if (target[loc][param] === undefined) {\n                        target[loc][param] = [];\n                    }\n                    if (copyFromArray) {\n                        if (!_.isObject(source[loc]) || !_.isArray(source[loc][param])) {\n                            useErrorValues = true;\n\n                        } else if (source[loc][param].length < (sourceIndex + count)) {\n                            useErrorValues = true;\n                            if (\"undefined\" !== typeof console && console) {\n                                console.error('Trying to fill segment with only ' + source[loc][param].length + ' values for location ' + loc + ' and parameter ' + param + ' when ' + (sourceIndex + count) + ' would be needed. Filling the whole segment with \\''+errorFillValue+'\\'');\n                            }\n                        }\n                    }\n                    if (useErrorValues) {\n                        ti = targetIndex;\n                        end = targetIndex + count;\n                        while (ti < end) {\n                            target[loc][param][ti++] = errorFillValue;\n                        }\n                    } else if (copyFromArray) {\n                        ti = targetIndex;\n                        si = sourceIndex;\n                        end = targetIndex + count;\n                        while (ti < end) {\n                            target[loc][param][ti++] = source[loc][param][si++];\n                        }\n                    } else {\n                        ti = targetIndex;\n                        end = targetIndex + count;\n                        while (ti < end) {\n                            target[loc][param][ti++] = source;\n                        }\n                    }\n                    paramNotify();\n                }, function(err) {\n                    //one location completed\n                    locNotify();\n                });\n            }, function(err) {\n                //all done:\n                callback(err, target);\n            });\n        }\n\n        function retrieveDataAsync(origTaskDef, finishCallback, progressCallback) {\n            var taskDef = _.clone(origTaskDef);\n\n            if (!_.isFunction(finishCallback)) {\n                throw 'finishCallback must be a function';\n            }\n\n            if (getFetcher(taskDef.service) === null) {\n                throw 'No data fetcher set for service \\'' + taskDef.service + '\\', unable to provide data';\n            }\n\n            //If the new request does not have the same resolution or the start difference is not a multiple of resolution\n            //then clear all cached results for this service:\n            if (stepResolutions[taskDef.service] !== undefined) {\n                if ((stepResolutions[taskDef.service].resolution !== taskDef.resolution) || (Math.abs(stepResolutions[taskDef.service].start - taskDef.start) % taskDef.resolution !== 0)) {\n                    clear(taskDef.service);\n                }\n            }\n            stepResolutions[taskDef.service] = {\n                start : taskDef.start,\n                resolution : taskDef.resolution\n            };\n\n            iterateCacheQueue.push(taskDef, function(err, dataBlocks) {\n                fetchDataForBlocks(dataBlocks, taskDef, finishCallback, progressCallback);\n            });\n\n        }\n\n        function fetchDataForBlocks(dataBlocks, taskDef, finishCallback, progressCallback) {\n            var errors = null;\n            var notifyProgress = false;\n            var result = {};\n\n            if (_.isFunction(progressCallback)) {\n                notifyProgress = true;\n            }\n            fireEvent('fetchStarted', taskDef);\n            result.steps = _.range(taskDef.start, taskDef.end + taskDef.resolution, taskDef.resolution);\n            result.data = {};\n\n            async.each(dataBlocks, function(dataBlock, notify) {\n                var td = dataBlock.getTaskDef();\n\n                var includeStart = NaN;\n                var includeEnd = NaN;\n                var targetStartIndex = NaN;\n                var targetEndIndex = NaN;\n                var sourceStartIndex = NaN;\n                var valueCount = NaN;\n\n                if (!blockOverlaps(td.start, td.end, taskDef.start, taskDef.end)) {\n                    //For completely out-of-range blocks:\n                    //we fetch them just to cache them, but otherwise\n                    //ignore the results completely:\n                    dataBlock.getDataAsync(function(){\n                        dataBlock.unpin();\n                    });\n\n                    //and continue the loop:\n                    notify();\n                    return;\n                }\n\n                if (td.start < taskDef.start) {\n                    includeStart = taskDef.start;\n                    sourceStartIndex = Math.round((taskDef.start - td.start) / taskDef.resolution);\n                } else {\n                    includeStart = td.start;\n                    sourceStartIndex = 0;\n                }\n                targetStartIndex = _.indexOf(result.steps, includeStart);\n                if (targetStartIndex === -1) {\n                    throw dataBlock.getId() + ':something wrong with indexing, start index for cache block not found in the combined results!';\n                }\n\n                if (td.end > taskDef.end) {\n                    includeEnd = taskDef.end;\n                    targetEndIndex = result.steps.length - 1;\n                } else {\n                    includeEnd = td.end;\n                    targetEndIndex = _.indexOf(result.steps, td.end, true);\n                }\n                valueCount = targetEndIndex - targetStartIndex + 1;\n\n                // See fillWith function description about the structure that data object should have.\n                dataBlock.getDataAsync(function(err, data) {\n                    var fillValue = data;\n\n                    if (err) {\n                        if (errors === null) {\n                            errors = [];\n                        }\n                        errors.push({\n                            start : td.start,\n                            end : td.end,\n                            error : err\n                        });\n\n                        // error in fetching data, fill result with 'errorFillValue' for this step sequence if data is undefined itself.\n                        // Notice, errors may have occurred but data is still given because it should be good enough.\n                        // Therefore, do not ignore given data if it is available. It is up to the data provider to make\n                        // sure that data is undefined if it should not be handled in cache.\n\n                        //Ilkka Rinne/2013-09-02: This is inconsistent with the node.js callback error conventions:\n                        //You should always get either an error or result, never both.\n                        //http://nodemanual.org/latest/nodejs_dev_guide/working_with_callbacks.html\n                        //When would you want to return errors but also useable data?\n\n                        if (strictErrorHandling || !data) {\n                            fillValue = errorFillValue;\n                        }\n                        //do not keep this block in cache:\n                        dataBlock.markForRecycling();\n                    }\n                    fillWith(result.data, fillValue, td.location, td.parameter, targetStartIndex, sourceStartIndex, valueCount, function() {\n                        if (notifyProgress) {\n                            progressCallback(err, includeStart, includeEnd);\n                        }\n                        dataBlock.unpin();\n\n                        //always succeed, even with fetch error: we want to return the rest of the data anyway\n                        notify();\n                    });\n                });\n\n            }, function(err) {\n                finishCallback(errors, result);\n                fireEvent('fetchFinished', taskDef);\n            });\n        }\n\n        function getFetcher(service) {\n            if (fetchers[service] !== undefined) {\n                fetchers[service].nextIndex = (fetchers[service].nextIndex + 1) % fetchers[service].providers.length;\n                return fetchers[service].providers[fetchers[service].nextIndex].cb;\n            } else {\n                return null;\n            }\n        }\n\n        function clear(service) {\n            _.each(cachedBlocks, function(block) {\n                if ((service === undefined) || (block.getService() === service)) {\n                    block.markForRecycling();\n                }\n            });\n            _.each(mergedBlocks, function(block) {\n                if ((service === undefined) || (block.getService() === service)) {\n                    block.markForRecycling();\n                }\n            });\n            fireEvent('cacheCleared', service);\n        }\n\n        //Privileged functions:\n        /**\n         * @param {String} service Describes the service name that identifies the data.\n         *                                               May not be {undefined}, {null} or empty. More than one fetcher\n         *                                               may be added for the same service to enable a round-robin task\n         *                                               distribution between them.\n         * @param {function(taskDef, callback)} fetcher The callback parameter of fetcher callback function is of\n         *                                              the type {function(err, data)}. See {fillWith()} function\n         *                                              for the description for the source data object structure\n         *                                              that should be provided by the fetcher callback function for\n         *                                              its parameter callback function.\n         */\n        this.addDataProvider = function(service, fetcher) {\n            var provider = {};\n            if (_.isFunction(fetcher)) {\n                if (fetchers[service] === undefined) {\n                    fetchers[service] = {\n                        nextIndex : 0,\n                        providers : []\n                    };\n                }\n                provider.id = 'id#' + fetcherIdCounter++;\n                provider.cb = fetcher;\n                fetchers[service].providers.push(provider);\n                fireEvent('dataProviderAdded', {\n                    'service' : service,\n                    'providerId' : provider.id\n                });\n            } else {\n                throw 'Fetcher must be a function';\n            }\n            return provider.id;\n        };\n\n        this.removeDataProvider = function(service, providerId) {\n            var oldLength = 0;\n            var actuallyRemoved = false;\n            if (fetchers[service] !== undefined) {\n                oldLength = fetchers[service].providers.length;\n                fetchers[service].providers = _.reject(fetchers[service].providers, function(provider) {\n                    return provider.id === providerId;\n                });\n                if (fetchers[service].providers.length === 0) {\n                    delete fetchers.service;\n                    actuallyRemoved = true;\n                } else if (oldLength !== fetchers[service].providers.length) {\n                    actuallyRemoved = true;\n                }\n                if (actuallyRemoved) {\n                    fireEvent('dataProviderRemoved', {\n                        'service' : service,\n                        'providerId' : providerId\n                    });\n                }\n            }\n        };\n\n        /**\n         * Removes all content from the cache and resets the hits & misses counters.\n         *\n         */\n        this.clearCache = function() {\n            clear();\n            stepResolutions = [];\n            cacheHits = 0;\n            cacheMisses = 0;\n        };\n\n        this.fetch = function(taskDef, finalCallback, progressCallback) {\n            checkTaskDef(taskDef);\n            retrieveDataAsync(taskDef, finalCallback, progressCallback);\n        };\n\n        this.getCachedItemCount = function() {\n            return cachedDataSize;\n        };\n\n        this.getFillingDegree = function() {\n            return cachedDataSize / maxCacheDataSize;\n        };\n\n        this.getHitRatio = function() {\n            return (cacheHits / (cacheHits + cacheMisses));\n        };\n\n        this.addListener = function(eventName, callback) {\n            return addEventListener(eventName, callback);\n        };\n\n        this.removeListener = function(eventName, providerId) {\n            return removeEventListener(eventName, providerId);\n        };\n\n        //Instance initialization:\n        if (properties.sideFetchBeforeFactor !== undefined) {\n            if (_.isNumber(properties.sideFetchBeforeFactor)) {\n                if (properties.sideFetchBeforeFactor >= 0) {\n                    sideFetchBeforeFactor = properties.sideFetchBeforeFactor;\n                }\n            }\n        }\n        if (properties.sideFetchAfterFactor !== undefined) {\n            if (_.isNumber(properties.sideFetchAfterFactor)) {\n                if (properties.sideFetchAfterFactor >= 0) {\n                    sideFetchAfterFactor = properties.sideFetchAfterFactor;\n                }\n            }\n        }\n        if (properties.maxBlockDataPoints !== undefined) {\n            if (_.isNumber(properties.maxBlockDataPoints)) {\n                if (properties.maxBlockDataPoints > 0) {\n                    maxBlockDataPoints = properties.maxBlockDataPoints;\n                }\n            }\n        }\n        if (properties.minBlockDataPoints !== undefined) {\n            if (_.isNumber(properties.minBlockDataPoints)) {\n                if ((properties.minBlockDataPoints > 0) && (properties.minBlockDataPoints < maxBlockDataPoints)) {\n                    minBlockDataPoints = properties.minBlockDataPoints;\n                } else {\n                    minBlockDataPoints = 0;\n                }\n            }\n        }\n        if (minBlockDataPoints > maxBlockDataPoints) {\n            minBlockDataPoints = maxBlockDataPoints;\n        }\n        if (properties.maxCacheDataSize !== undefined) {\n            if (_.isNumber(properties.maxCacheDataSize)) {\n                if (properties.maxCacheDataSize > 0) {\n                    maxCacheDataSize = properties.maxCacheDataSize;\n                }\n            }\n        }\n        if (properties.strictErrorHandling !== undefined) {\n            if (properties.strictErrorHandling === false) {\n                strictErrorHandling = false;\n            }\n        }\n\n        if (properties.errorFillValue !== undefined) {\n            errorFillValue = properties.errorFillValue;\n        }\n    };\n\n    /**\n     * SplitterCache constructor is returned for later instantiation.\n     */\n    return _constructor;\n})();\n\nmodule.exports = SplitterCache;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}